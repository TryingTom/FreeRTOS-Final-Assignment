
Atmega2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000016e  00800200  000046c4  00004758  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000046c4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001367  0080036e  0080036e  000048c6  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000048c6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004924  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000698  00000000  00000000  00004964  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000a78a  00000000  00000000  00004ffc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000242f  00000000  00000000  0000f786  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000683d  00000000  00000000  00011bb5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000190c  00000000  00000000  000183f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000218e  00000000  00000000  00019d00  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a49e  00000000  00000000  0001be8e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000ba8  00000000  00000000  0002632c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	f3 c1       	rjmp	.+998    	; 0x3e8 <__ctors_end>
       2:	00 00       	nop
       4:	11 c2       	rjmp	.+1058   	; 0x428 <__bad_interrupt>
       6:	00 00       	nop
       8:	0f c2       	rjmp	.+1054   	; 0x428 <__bad_interrupt>
       a:	00 00       	nop
       c:	0d c2       	rjmp	.+1050   	; 0x428 <__bad_interrupt>
       e:	00 00       	nop
      10:	0b c2       	rjmp	.+1046   	; 0x428 <__bad_interrupt>
      12:	00 00       	nop
      14:	09 c2       	rjmp	.+1042   	; 0x428 <__bad_interrupt>
      16:	00 00       	nop
      18:	07 c2       	rjmp	.+1038   	; 0x428 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	05 c2       	rjmp	.+1034   	; 0x428 <__bad_interrupt>
      1e:	00 00       	nop
      20:	03 c2       	rjmp	.+1030   	; 0x428 <__bad_interrupt>
      22:	00 00       	nop
      24:	01 c2       	rjmp	.+1026   	; 0x428 <__bad_interrupt>
      26:	00 00       	nop
      28:	ff c1       	rjmp	.+1022   	; 0x428 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	fd c1       	rjmp	.+1018   	; 0x428 <__bad_interrupt>
      2e:	00 00       	nop
      30:	fb c1       	rjmp	.+1014   	; 0x428 <__bad_interrupt>
      32:	00 00       	nop
      34:	f9 c1       	rjmp	.+1010   	; 0x428 <__bad_interrupt>
      36:	00 00       	nop
      38:	f7 c1       	rjmp	.+1006   	; 0x428 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	f5 c1       	rjmp	.+1002   	; 0x428 <__bad_interrupt>
      3e:	00 00       	nop
      40:	f3 c1       	rjmp	.+998    	; 0x428 <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 d0 0c 	jmp	0x19a0	; 0x19a0 <__vector_17>
      48:	ef c1       	rjmp	.+990    	; 0x428 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ed c1       	rjmp	.+986    	; 0x428 <__bad_interrupt>
      4e:	00 00       	nop
      50:	eb c1       	rjmp	.+982    	; 0x428 <__bad_interrupt>
      52:	00 00       	nop
      54:	bf c3       	rjmp	.+1918   	; 0x7d4 <__vector_21>
      56:	00 00       	nop
      58:	e7 c1       	rjmp	.+974    	; 0x428 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	e5 c1       	rjmp	.+970    	; 0x428 <__bad_interrupt>
      5e:	00 00       	nop
      60:	e3 c1       	rjmp	.+966    	; 0x428 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 09 1d 	jmp	0x3a12	; 0x3a12 <__vector_25>
      68:	0c 94 68 1d 	jmp	0x3ad0	; 0x3ad0 <__vector_26>
      6c:	dd c1       	rjmp	.+954    	; 0x428 <__bad_interrupt>
      6e:	00 00       	nop
      70:	db c1       	rjmp	.+950    	; 0x428 <__bad_interrupt>
      72:	00 00       	nop
      74:	d9 c1       	rjmp	.+946    	; 0x428 <__bad_interrupt>
      76:	00 00       	nop
      78:	d7 c1       	rjmp	.+942    	; 0x428 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	d5 c1       	rjmp	.+938    	; 0x428 <__bad_interrupt>
      7e:	00 00       	nop
      80:	d3 c1       	rjmp	.+934    	; 0x428 <__bad_interrupt>
      82:	00 00       	nop
      84:	d1 c1       	rjmp	.+930    	; 0x428 <__bad_interrupt>
      86:	00 00       	nop
      88:	cf c1       	rjmp	.+926    	; 0x428 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	cd c1       	rjmp	.+922    	; 0x428 <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 b1 1d 	jmp	0x3b62	; 0x3b62 <__vector_36>
      94:	0c 94 10 1e 	jmp	0x3c20	; 0x3c20 <__vector_37>
      98:	c7 c1       	rjmp	.+910    	; 0x428 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	c5 c1       	rjmp	.+906    	; 0x428 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	c3 c1       	rjmp	.+902    	; 0x428 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	c1 c1       	rjmp	.+898    	; 0x428 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	bf c1       	rjmp	.+894    	; 0x428 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	bd c1       	rjmp	.+890    	; 0x428 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	bb c1       	rjmp	.+886    	; 0x428 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	b9 c1       	rjmp	.+882    	; 0x428 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	b7 c1       	rjmp	.+878    	; 0x428 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	b5 c1       	rjmp	.+874    	; 0x428 <__bad_interrupt>
      be:	00 00       	nop
      c0:	b3 c1       	rjmp	.+870    	; 0x428 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	b1 c1       	rjmp	.+866    	; 0x428 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	af c1       	rjmp	.+862    	; 0x428 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 59 1e 	jmp	0x3cb2	; 0x3cb2 <__vector_51>
      d0:	0c 94 b8 1e 	jmp	0x3d70	; 0x3d70 <__vector_52>
      d4:	a9 c1       	rjmp	.+850    	; 0x428 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 01 1f 	jmp	0x3e02	; 0x3e02 <__vector_54>
      dc:	0c 94 60 1f 	jmp	0x3ec0	; 0x3ec0 <__vector_55>
      e0:	a3 c1       	rjmp	.+838    	; 0x428 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	83 1a       	sub	r8, r19
      e6:	83 1a       	sub	r8, r19
      e8:	88 1a       	sub	r8, r24
      ea:	88 1a       	sub	r8, r24
      ec:	8d 1a       	sub	r8, r29
      ee:	8d 1a       	sub	r8, r29
      f0:	92 1a       	sub	r9, r18
      f2:	92 1a       	sub	r9, r18
      f4:	3f 1b       	sub	r19, r31
      f6:	6f 1b       	sub	r22, r31
      f8:	a8 1b       	sub	r26, r24
      fa:	d8 1b       	sub	r29, r24
      fc:	11 1c       	adc	r1, r1
      fe:	41 1c       	adc	r4, r1
     100:	7e 1c       	adc	r7, r14
     102:	ae 1c       	adc	r10, r14

00000104 <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     104:	0f 2e       	mov	r0, r31
     106:	f1 eb       	ldi	r31, 0xB1	; 177
     108:	af 2e       	mov	r10, r31
     10a:	f5 e1       	ldi	r31, 0x15	; 21
     10c:	bf 2e       	mov	r11, r31
     10e:	f0 2d       	mov	r31, r0
     110:	0a eb       	ldi	r16, 0xBA	; 186
     112:	15 e1       	ldi	r17, 0x15	; 21
     114:	88 24       	eor	r8, r8
     116:	8a 94       	dec	r8
     118:	98 2c       	mov	r9, r8
     11a:	33 24       	eor	r3, r3
     11c:	33 94       	inc	r3
     11e:	43 2c       	mov	r4, r3
     120:	73 2c       	mov	r7, r3
     122:	52 c1       	rjmp	.+676    	; 0x3c8 <prvIdleTask+0x2c4>
     124:	80 91 9b 15 	lds	r24, 0x159B	; 0x80159b <uxSchedulerSuspended>
     128:	8f 5f       	subi	r24, 0xFF	; 255
     12a:	80 93 9b 15 	sts	0x159B, r24	; 0x80159b <uxSchedulerSuspended>
     12e:	d5 01       	movw	r26, r10
     130:	6c 90       	ld	r6, X
     132:	0f b6       	in	r0, 0x3f	; 63
     134:	f8 94       	cli
     136:	0f 92       	push	r0
     138:	80 91 9b 15 	lds	r24, 0x159B	; 0x80159b <uxSchedulerSuspended>
     13c:	81 50       	subi	r24, 0x01	; 1
     13e:	80 93 9b 15 	sts	0x159B, r24	; 0x80159b <uxSchedulerSuspended>
     142:	80 91 9b 15 	lds	r24, 0x159B	; 0x80159b <uxSchedulerSuspended>
     146:	81 11       	cpse	r24, r1
     148:	1a c1       	rjmp	.+564    	; 0x37e <prvIdleTask+0x27a>
     14a:	80 91 a6 15 	lds	r24, 0x15A6	; 0x8015a6 <uxCurrentNumberOfTasks>
     14e:	81 11       	cpse	r24, r1
     150:	33 c0       	rjmp	.+102    	; 0x1b8 <prvIdleTask+0xb4>
     152:	15 c1       	rjmp	.+554    	; 0x37e <prvIdleTask+0x27a>
     154:	d8 01       	movw	r26, r16
     156:	15 96       	adiw	r26, 0x05	; 5
     158:	ed 91       	ld	r30, X+
     15a:	fc 91       	ld	r31, X
     15c:	16 97       	sbiw	r26, 0x06	; 6
     15e:	c6 81       	ldd	r28, Z+6	; 0x06
     160:	d7 81       	ldd	r29, Z+7	; 0x07
     162:	ce 01       	movw	r24, r28
     164:	0c 96       	adiw	r24, 0x0c	; 12
     166:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
     16a:	7e 01       	movw	r14, r28
     16c:	b2 e0       	ldi	r27, 0x02	; 2
     16e:	eb 0e       	add	r14, r27
     170:	f1 1c       	adc	r15, r1
     172:	c7 01       	movw	r24, r14
     174:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
     178:	8e 89       	ldd	r24, Y+22	; 0x16
     17a:	90 91 a3 15 	lds	r25, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
     17e:	98 17       	cp	r25, r24
     180:	10 f4       	brcc	.+4      	; 0x186 <prvIdleTask+0x82>
     182:	80 93 a3 15 	sts	0x15A3, r24	; 0x8015a3 <uxTopReadyPriority>
     186:	90 e0       	ldi	r25, 0x00	; 0
     188:	9c 01       	movw	r18, r24
     18a:	22 0f       	add	r18, r18
     18c:	33 1f       	adc	r19, r19
     18e:	22 0f       	add	r18, r18
     190:	33 1f       	adc	r19, r19
     192:	22 0f       	add	r18, r18
     194:	33 1f       	adc	r19, r19
     196:	82 0f       	add	r24, r18
     198:	93 1f       	adc	r25, r19
     19a:	b7 01       	movw	r22, r14
     19c:	87 52       	subi	r24, 0x27	; 39
     19e:	9a 4e       	sbci	r25, 0xEA	; 234
     1a0:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
     1a4:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
     1a8:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
     1ac:	9e 89       	ldd	r25, Y+22	; 0x16
     1ae:	86 89       	ldd	r24, Z+22	; 0x16
     1b0:	98 17       	cp	r25, r24
     1b2:	10 f0       	brcs	.+4      	; 0x1b8 <prvIdleTask+0xb4>
     1b4:	40 92 a0 15 	sts	0x15A0, r4	; 0x8015a0 <xYieldPending>
     1b8:	f8 01       	movw	r30, r16
     1ba:	80 81       	ld	r24, Z
     1bc:	81 11       	cpse	r24, r1
     1be:	ca cf       	rjmp	.-108    	; 0x154 <prvIdleTask+0x50>
     1c0:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
     1c4:	88 23       	and	r24, r24
     1c6:	09 f4       	brne	.+2      	; 0x1ca <prvIdleTask+0xc6>
     1c8:	d4 c0       	rjmp	.+424    	; 0x372 <prvIdleTask+0x26e>
     1ca:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
     1ce:	88 23       	and	r24, r24
     1d0:	09 f4       	brne	.+2      	; 0x1d4 <prvIdleTask+0xd0>
     1d2:	cf c0       	rjmp	.+414    	; 0x372 <prvIdleTask+0x26e>
     1d4:	80 91 9b 15 	lds	r24, 0x159B	; 0x80159b <uxSchedulerSuspended>
     1d8:	81 11       	cpse	r24, r1
     1da:	b1 c0       	rjmp	.+354    	; 0x33e <prvIdleTask+0x23a>
     1dc:	80 91 a4 15 	lds	r24, 0x15A4	; 0x8015a4 <xTickCount>
     1e0:	90 91 a5 15 	lds	r25, 0x15A5	; 0x8015a5 <xTickCount+0x1>
     1e4:	01 96       	adiw	r24, 0x01	; 1
     1e6:	90 93 a5 15 	sts	0x15A5, r25	; 0x8015a5 <xTickCount+0x1>
     1ea:	80 93 a4 15 	sts	0x15A4, r24	; 0x8015a4 <xTickCount>
     1ee:	c0 90 a4 15 	lds	r12, 0x15A4	; 0x8015a4 <xTickCount>
     1f2:	d0 90 a5 15 	lds	r13, 0x15A5	; 0x8015a5 <xTickCount+0x1>
     1f6:	c1 14       	cp	r12, r1
     1f8:	d1 04       	cpc	r13, r1
     1fa:	89 f5       	brne	.+98     	; 0x25e <prvIdleTask+0x15a>
     1fc:	80 91 c5 15 	lds	r24, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
     200:	90 91 c6 15 	lds	r25, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
     204:	20 91 c3 15 	lds	r18, 0x15C3	; 0x8015c3 <pxOverflowDelayedTaskList>
     208:	30 91 c4 15 	lds	r19, 0x15C4	; 0x8015c4 <pxOverflowDelayedTaskList+0x1>
     20c:	30 93 c6 15 	sts	0x15C6, r19	; 0x8015c6 <pxDelayedTaskList+0x1>
     210:	20 93 c5 15 	sts	0x15C5, r18	; 0x8015c5 <pxDelayedTaskList>
     214:	90 93 c4 15 	sts	0x15C4, r25	; 0x8015c4 <pxOverflowDelayedTaskList+0x1>
     218:	80 93 c3 15 	sts	0x15C3, r24	; 0x8015c3 <pxOverflowDelayedTaskList>
     21c:	80 91 9f 15 	lds	r24, 0x159F	; 0x80159f <xNumOfOverflows>
     220:	8f 5f       	subi	r24, 0xFF	; 255
     222:	80 93 9f 15 	sts	0x159F, r24	; 0x80159f <xNumOfOverflows>
     226:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
     22a:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
     22e:	80 81       	ld	r24, Z
     230:	81 11       	cpse	r24, r1
     232:	05 c0       	rjmp	.+10     	; 0x23e <prvIdleTask+0x13a>
     234:	90 92 9d 15 	sts	0x159D, r9	; 0x80159d <xNextTaskUnblockTime+0x1>
     238:	80 92 9c 15 	sts	0x159C, r8	; 0x80159c <xNextTaskUnblockTime>
     23c:	10 c0       	rjmp	.+32     	; 0x25e <prvIdleTask+0x15a>
     23e:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
     242:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
     246:	05 80       	ldd	r0, Z+5	; 0x05
     248:	f6 81       	ldd	r31, Z+6	; 0x06
     24a:	e0 2d       	mov	r30, r0
     24c:	06 80       	ldd	r0, Z+6	; 0x06
     24e:	f7 81       	ldd	r31, Z+7	; 0x07
     250:	e0 2d       	mov	r30, r0
     252:	82 81       	ldd	r24, Z+2	; 0x02
     254:	93 81       	ldd	r25, Z+3	; 0x03
     256:	90 93 9d 15 	sts	0x159D, r25	; 0x80159d <xNextTaskUnblockTime+0x1>
     25a:	80 93 9c 15 	sts	0x159C, r24	; 0x80159c <xNextTaskUnblockTime>
     25e:	80 91 9c 15 	lds	r24, 0x159C	; 0x80159c <xNextTaskUnblockTime>
     262:	90 91 9d 15 	lds	r25, 0x159D	; 0x80159d <xNextTaskUnblockTime+0x1>
     266:	c8 16       	cp	r12, r24
     268:	d9 06       	cpc	r13, r25
     26a:	10 f4       	brcc	.+4      	; 0x270 <prvIdleTask+0x16c>
     26c:	25 2c       	mov	r2, r5
     26e:	50 c0       	rjmp	.+160    	; 0x310 <prvIdleTask+0x20c>
     270:	25 2c       	mov	r2, r5
     272:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
     276:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
     27a:	80 81       	ld	r24, Z
     27c:	81 11       	cpse	r24, r1
     27e:	05 c0       	rjmp	.+10     	; 0x28a <prvIdleTask+0x186>
     280:	90 92 9d 15 	sts	0x159D, r9	; 0x80159d <xNextTaskUnblockTime+0x1>
     284:	80 92 9c 15 	sts	0x159C, r8	; 0x80159c <xNextTaskUnblockTime>
     288:	43 c0       	rjmp	.+134    	; 0x310 <prvIdleTask+0x20c>
     28a:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
     28e:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
     292:	05 80       	ldd	r0, Z+5	; 0x05
     294:	f6 81       	ldd	r31, Z+6	; 0x06
     296:	e0 2d       	mov	r30, r0
     298:	c6 81       	ldd	r28, Z+6	; 0x06
     29a:	d7 81       	ldd	r29, Z+7	; 0x07
     29c:	8a 81       	ldd	r24, Y+2	; 0x02
     29e:	9b 81       	ldd	r25, Y+3	; 0x03
     2a0:	c8 16       	cp	r12, r24
     2a2:	d9 06       	cpc	r13, r25
     2a4:	28 f4       	brcc	.+10     	; 0x2b0 <prvIdleTask+0x1ac>
     2a6:	90 93 9d 15 	sts	0x159D, r25	; 0x80159d <xNextTaskUnblockTime+0x1>
     2aa:	80 93 9c 15 	sts	0x159C, r24	; 0x80159c <xNextTaskUnblockTime>
     2ae:	30 c0       	rjmp	.+96     	; 0x310 <prvIdleTask+0x20c>
     2b0:	7e 01       	movw	r14, r28
     2b2:	f2 e0       	ldi	r31, 0x02	; 2
     2b4:	ef 0e       	add	r14, r31
     2b6:	f1 1c       	adc	r15, r1
     2b8:	c7 01       	movw	r24, r14
     2ba:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
     2be:	8c 89       	ldd	r24, Y+20	; 0x14
     2c0:	9d 89       	ldd	r25, Y+21	; 0x15
     2c2:	89 2b       	or	r24, r25
     2c4:	21 f0       	breq	.+8      	; 0x2ce <prvIdleTask+0x1ca>
     2c6:	ce 01       	movw	r24, r28
     2c8:	0c 96       	adiw	r24, 0x0c	; 12
     2ca:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
     2ce:	8e 89       	ldd	r24, Y+22	; 0x16
     2d0:	90 91 a3 15 	lds	r25, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
     2d4:	98 17       	cp	r25, r24
     2d6:	10 f4       	brcc	.+4      	; 0x2dc <prvIdleTask+0x1d8>
     2d8:	80 93 a3 15 	sts	0x15A3, r24	; 0x8015a3 <uxTopReadyPriority>
     2dc:	90 e0       	ldi	r25, 0x00	; 0
     2de:	9c 01       	movw	r18, r24
     2e0:	22 0f       	add	r18, r18
     2e2:	33 1f       	adc	r19, r19
     2e4:	22 0f       	add	r18, r18
     2e6:	33 1f       	adc	r19, r19
     2e8:	22 0f       	add	r18, r18
     2ea:	33 1f       	adc	r19, r19
     2ec:	82 0f       	add	r24, r18
     2ee:	93 1f       	adc	r25, r19
     2f0:	b7 01       	movw	r22, r14
     2f2:	87 52       	subi	r24, 0x27	; 39
     2f4:	9a 4e       	sbci	r25, 0xEA	; 234
     2f6:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
     2fa:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
     2fe:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
     302:	9e 89       	ldd	r25, Y+22	; 0x16
     304:	86 89       	ldd	r24, Z+22	; 0x16
     306:	98 17       	cp	r25, r24
     308:	08 f4       	brcc	.+2      	; 0x30c <prvIdleTask+0x208>
     30a:	b3 cf       	rjmp	.-154    	; 0x272 <prvIdleTask+0x16e>
     30c:	27 2c       	mov	r2, r7
     30e:	b1 cf       	rjmp	.-158    	; 0x272 <prvIdleTask+0x16e>
     310:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
     314:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
     318:	86 89       	ldd	r24, Z+22	; 0x16
     31a:	90 e0       	ldi	r25, 0x00	; 0
     31c:	fc 01       	movw	r30, r24
     31e:	ee 0f       	add	r30, r30
     320:	ff 1f       	adc	r31, r31
     322:	ee 0f       	add	r30, r30
     324:	ff 1f       	adc	r31, r31
     326:	ee 0f       	add	r30, r30
     328:	ff 1f       	adc	r31, r31
     32a:	8e 0f       	add	r24, r30
     32c:	9f 1f       	adc	r25, r31
     32e:	fc 01       	movw	r30, r24
     330:	e7 52       	subi	r30, 0x27	; 39
     332:	fa 4e       	sbci	r31, 0xEA	; 234
     334:	80 81       	ld	r24, Z
     336:	82 30       	cpi	r24, 0x02	; 2
     338:	08 f0       	brcs	.+2      	; 0x33c <prvIdleTask+0x238>
     33a:	53 c0       	rjmp	.+166    	; 0x3e2 <prvIdleTask+0x2de>
     33c:	0a c0       	rjmp	.+20     	; 0x352 <prvIdleTask+0x24e>
     33e:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
     342:	8f 5f       	subi	r24, 0xFF	; 255
     344:	80 93 a1 15 	sts	0x15A1, r24	; 0x8015a1 <uxPendedTicks>
     348:	80 91 a0 15 	lds	r24, 0x15A0	; 0x8015a0 <xYieldPending>
     34c:	88 23       	and	r24, r24
     34e:	41 f0       	breq	.+16     	; 0x360 <prvIdleTask+0x25c>
     350:	05 c0       	rjmp	.+10     	; 0x35c <prvIdleTask+0x258>
     352:	80 91 a0 15 	lds	r24, 0x15A0	; 0x8015a0 <xYieldPending>
     356:	81 11       	cpse	r24, r1
     358:	01 c0       	rjmp	.+2      	; 0x35c <prvIdleTask+0x258>
     35a:	21 10       	cpse	r2, r1
     35c:	70 92 a0 15 	sts	0x15A0, r7	; 0x8015a0 <xYieldPending>
     360:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
     364:	81 50       	subi	r24, 0x01	; 1
     366:	80 93 a1 15 	sts	0x15A1, r24	; 0x8015a1 <uxPendedTicks>
     36a:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
     36e:	81 11       	cpse	r24, r1
     370:	31 cf       	rjmp	.-414    	; 0x1d4 <prvIdleTask+0xd0>
     372:	80 91 a0 15 	lds	r24, 0x15A0	; 0x8015a0 <xYieldPending>
     376:	81 30       	cpi	r24, 0x01	; 1
     378:	11 f4       	brne	.+4      	; 0x37e <prvIdleTask+0x27a>
     37a:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <vPortYield>
     37e:	0f 90       	pop	r0
     380:	0f be       	out	0x3f, r0	; 63
     382:	66 20       	and	r6, r6
     384:	11 f1       	breq	.+68     	; 0x3ca <prvIdleTask+0x2c6>
     386:	0f b6       	in	r0, 0x3f	; 63
     388:	f8 94       	cli
     38a:	0f 92       	push	r0
     38c:	d5 01       	movw	r26, r10
     38e:	15 96       	adiw	r26, 0x05	; 5
     390:	ed 91       	ld	r30, X+
     392:	fc 91       	ld	r31, X
     394:	16 97       	sbiw	r26, 0x06	; 6
     396:	c6 81       	ldd	r28, Z+6	; 0x06
     398:	d7 81       	ldd	r29, Z+7	; 0x07
     39a:	ce 01       	movw	r24, r28
     39c:	02 96       	adiw	r24, 0x02	; 2
     39e:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
     3a2:	80 91 a6 15 	lds	r24, 0x15A6	; 0x8015a6 <uxCurrentNumberOfTasks>
     3a6:	81 50       	subi	r24, 0x01	; 1
     3a8:	80 93 a6 15 	sts	0x15A6, r24	; 0x8015a6 <uxCurrentNumberOfTasks>
     3ac:	80 91 b0 15 	lds	r24, 0x15B0	; 0x8015b0 <uxTasksDeleted>
     3b0:	81 50       	subi	r24, 0x01	; 1
     3b2:	80 93 b0 15 	sts	0x15B0, r24	; 0x8015b0 <uxTasksDeleted>
     3b6:	0f 90       	pop	r0
     3b8:	0f be       	out	0x3f, r0	; 63
     3ba:	8f 89       	ldd	r24, Y+23	; 0x17
     3bc:	98 8d       	ldd	r25, Y+24	; 0x18
     3be:	0e 94 af 0a 	call	0x155e	; 0x155e <vPortFree>
     3c2:	ce 01       	movw	r24, r28
     3c4:	0e 94 af 0a 	call	0x155e	; 0x155e <vPortFree>
     3c8:	51 2c       	mov	r5, r1
     3ca:	80 91 b0 15 	lds	r24, 0x15B0	; 0x8015b0 <uxTasksDeleted>
     3ce:	81 11       	cpse	r24, r1
     3d0:	a9 ce       	rjmp	.-686    	; 0x124 <prvIdleTask+0x20>
     3d2:	80 91 d9 15 	lds	r24, 0x15D9	; 0x8015d9 <pxReadyTasksLists>
     3d6:	82 30       	cpi	r24, 0x02	; 2
     3d8:	08 f4       	brcc	.+2      	; 0x3dc <prvIdleTask+0x2d8>
     3da:	a1 ce       	rjmp	.-702    	; 0x11e <prvIdleTask+0x1a>
     3dc:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <vPortYield>
     3e0:	9c ce       	rjmp	.-712    	; 0x11a <prvIdleTask+0x16>
     3e2:	80 91 a0 15 	lds	r24, 0x15A0	; 0x8015a0 <xYieldPending>
     3e6:	ba cf       	rjmp	.-140    	; 0x35c <prvIdleTask+0x258>

000003e8 <__ctors_end>:
     3e8:	11 24       	eor	r1, r1
     3ea:	1f be       	out	0x3f, r1	; 63
     3ec:	cf ef       	ldi	r28, 0xFF	; 255
     3ee:	d1 e2       	ldi	r29, 0x21	; 33
     3f0:	de bf       	out	0x3e, r29	; 62
     3f2:	cd bf       	out	0x3d, r28	; 61
     3f4:	00 e0       	ldi	r16, 0x00	; 0
     3f6:	0c bf       	out	0x3c, r16	; 60

000003f8 <__do_copy_data>:
     3f8:	13 e0       	ldi	r17, 0x03	; 3
     3fa:	a0 e0       	ldi	r26, 0x00	; 0
     3fc:	b2 e0       	ldi	r27, 0x02	; 2
     3fe:	e4 ec       	ldi	r30, 0xC4	; 196
     400:	f6 e4       	ldi	r31, 0x46	; 70
     402:	00 e0       	ldi	r16, 0x00	; 0
     404:	0b bf       	out	0x3b, r16	; 59
     406:	02 c0       	rjmp	.+4      	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
     408:	07 90       	elpm	r0, Z+
     40a:	0d 92       	st	X+, r0
     40c:	ae 36       	cpi	r26, 0x6E	; 110
     40e:	b1 07       	cpc	r27, r17
     410:	d9 f7       	brne	.-10     	; 0x408 <__LOCK_REGION_LENGTH__+0x8>

00000412 <__do_clear_bss>:
     412:	26 e1       	ldi	r18, 0x16	; 22
     414:	ae e6       	ldi	r26, 0x6E	; 110
     416:	b3 e0       	ldi	r27, 0x03	; 3
     418:	01 c0       	rjmp	.+2      	; 0x41c <.do_clear_bss_start>

0000041a <.do_clear_bss_loop>:
     41a:	1d 92       	st	X+, r1

0000041c <.do_clear_bss_start>:
     41c:	a5 3d       	cpi	r26, 0xD5	; 213
     41e:	b2 07       	cpc	r27, r18
     420:	e1 f7       	brne	.-8      	; 0x41a <.do_clear_bss_loop>
     422:	d4 d0       	rcall	.+424    	; 0x5cc <main>
     424:	0c 94 60 23 	jmp	0x46c0	; 0x46c0 <_exit>

00000428 <__bad_interrupt>:
     428:	eb cd       	rjmp	.-1066   	; 0x0 <__vectors>

0000042a <system_tick>:
     42a:	8f 93       	push	r24
     42c:	8f b7       	in	r24, 0x3f	; 63
     42e:	8f 93       	push	r24
     430:	f8 94       	cli
     432:	80 91 d1 16 	lds	r24, 0x16D1	; 0x8016d1 <__system_time>
     436:	8f 5f       	subi	r24, 0xFF	; 255
     438:	80 93 d1 16 	sts	0x16D1, r24	; 0x8016d1 <__system_time>
     43c:	80 91 d2 16 	lds	r24, 0x16D2	; 0x8016d2 <__system_time+0x1>
     440:	8f 4f       	sbci	r24, 0xFF	; 255
     442:	80 93 d2 16 	sts	0x16D2, r24	; 0x8016d2 <__system_time+0x1>
     446:	80 91 d3 16 	lds	r24, 0x16D3	; 0x8016d3 <__system_time+0x2>
     44a:	8f 4f       	sbci	r24, 0xFF	; 255
     44c:	80 93 d3 16 	sts	0x16D3, r24	; 0x8016d3 <__system_time+0x2>
     450:	80 91 d4 16 	lds	r24, 0x16D4	; 0x8016d4 <__system_time+0x3>
     454:	8f 4f       	sbci	r24, 0xFF	; 255
     456:	80 93 d4 16 	sts	0x16D4, r24	; 0x8016d4 <__system_time+0x3>
     45a:	8f 91       	pop	r24
     45c:	8f bf       	out	0x3f, r24	; 63
     45e:	8f 91       	pop	r24
     460:	08 95       	ret

00000462 <vTerminal>:
{
	static char  line[80] = {0};

	( void ) pvParameters; /* Just to stop compiler warnings. */

	xSerialxPrintf(&xSerialPort,"\r\nArduino running..\r\n");
     462:	80 e0       	ldi	r24, 0x00	; 0
     464:	92 e0       	ldi	r25, 0x02	; 2
     466:	9f 93       	push	r25
     468:	8f 93       	push	r24
     46a:	8f ef       	ldi	r24, 0xFF	; 255
     46c:	95 e1       	ldi	r25, 0x15	; 21
     46e:	9f 93       	push	r25
     470:	8f 93       	push	r24
     472:	0e 94 ab 1a 	call	0x3556	; 0x3556 <xSerialxPrintf>
     476:	0f 90       	pop	r0
     478:	0f 90       	pop	r0
     47a:	0f 90       	pop	r0
     47c:	0f 90       	pop	r0
     47e:	ff cf       	rjmp	.-2      	; 0x47e <vTerminal+0x1c>

00000480 <vKeyPadHandler>:
			xQueueSend( xDisplay, (void*)&message,0);
			break;
			
			case IDK_RIGHT: case IDK_LEFT:
			taskENTER_CRITICAL(); //////////////////////////////////
			ints[IDD_LASTKEY] = ch;                             ////
     480:	0d e8       	ldi	r16, 0x8D	; 141
     482:	13 e0       	ldi	r17, 0x03	; 3
			taskEXIT_CRITICAL();  //////////////////////////////////
			// lähetään viesti lcd-näyttötaskille,jotta se päivittää näytön
			message.data      = 0; // näytön numero
     484:	c4 e7       	ldi	r28, 0x74	; 116
     486:	d3 e0       	ldi	r29, 0x03	; 3
			//message.idMessage = IDM_DISPLAY_HISTORY;
			message.idMessage = IDM_DISPLAY_TIME;
     488:	0f 2e       	mov	r0, r31
     48a:	f5 e0       	ldi	r31, 0x05	; 5
     48c:	df 2e       	mov	r13, r31
     48e:	f0 2d       	mov	r31, r0
			taskENTER_CRITICAL(); //////////////////////////////////
			ints[IDD_LASTKEY] = ch;                             ////
			taskEXIT_CRITICAL();  //////////////////////////////////
			// lähetään viesti lcd-näyttötaskille,jotta se päivittää näytön
			message.data      = 0; // näytön numero
			message.idMessage = IDM_UPDATE_DISPLAY;
     490:	68 94       	set
     492:	ee 24       	eor	r14, r14
     494:	e1 f8       	bld	r14, 1
			taskENTER_CRITICAL(); //////////////////////////////////
			ints[IDD_LASTKEY] = ch;                             ////
			taskEXIT_CRITICAL();  //////////////////////////////////
			// lähetään viesti lcd-näyttötaskille,jotta se päivittää näytön
			message.data      = 0; // näytön numero
			message.idMessage = IDM_DISPLAY_MINMAX;
     496:	0f 2e       	mov	r0, r31
     498:	f3 e0       	ldi	r31, 0x03	; 3
     49a:	ff 2e       	mov	r15, r31
     49c:	f0 2d       	mov	r31, r0
	// taskilla tulee aina  olla ikisilmukka
	for( ;; )//=================
	{
		do  //tämä silmukka kuormittaa!!!
		{
			xSemaphoreTake( xADC, portMAX_DELAY );
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	4f ef       	ldi	r20, 0xFF	; 255
     4a2:	5f ef       	ldi	r21, 0xFF	; 255
     4a4:	60 e0       	ldi	r22, 0x00	; 0
     4a6:	70 e0       	ldi	r23, 0x00	; 0
     4a8:	80 91 89 03 	lds	r24, 0x0389	; 0x800389 <xADC>
     4ac:	90 91 8a 03 	lds	r25, 0x038A	; 0x80038a <xADC+0x1>
     4b0:	0e 94 84 10 	call	0x2108	; 0x2108 <xQueueGenericReceive>
			ch =GetKey();vTaskDelay(1);
     4b4:	45 d4       	rcall	.+2186   	; 0xd40 <GetKey>
     4b6:	80 93 76 03 	sts	0x0376, r24	; 0x800376 <ch.3070>
     4ba:	81 e0       	ldi	r24, 0x01	; 1
     4bc:	90 e0       	ldi	r25, 0x00	; 0
     4be:	0e 94 20 13 	call	0x2640	; 0x2640 <vTaskDelay>
			xSemaphoreGive( xADC );
     4c2:	60 e0       	ldi	r22, 0x00	; 0
     4c4:	70 e0       	ldi	r23, 0x00	; 0
     4c6:	80 91 89 03 	lds	r24, 0x0389	; 0x800389 <xADC>
     4ca:	90 91 8a 03 	lds	r25, 0x038A	; 0x80038a <xADC+0x1>
     4ce:	0e 94 ec 0e 	call	0x1dd8	; 0x1dd8 <xQueueGive>

		}while (ch == NO_KEY);
     4d2:	80 91 76 03 	lds	r24, 0x0376	; 0x800376 <ch.3070>
     4d6:	83 36       	cpi	r24, 0x63	; 99
     4d8:	11 f3       	breq	.-60     	; 0x49e <vKeyPadHandler+0x1e>

		switch( ch )
     4da:	84 30       	cpi	r24, 0x04	; 4
     4dc:	30 f4       	brcc	.+12     	; 0x4ea <vKeyPadHandler+0x6a>
     4de:	82 30       	cpi	r24, 0x02	; 2
     4e0:	08 f5       	brcc	.+66     	; 0x524 <vKeyPadHandler+0xa4>
     4e2:	81 30       	cpi	r24, 0x01	; 1
     4e4:	09 f4       	brne	.+2      	; 0x4e8 <vKeyPadHandler+0x68>
     4e6:	36 c0       	rjmp	.+108    	; 0x554 <vKeyPadHandler+0xd4>
     4e8:	da cf       	rjmp	.-76     	; 0x49e <vKeyPadHandler+0x1e>
     4ea:	84 30       	cpi	r24, 0x04	; 4
     4ec:	09 f4       	brne	.+2      	; 0x4f0 <vKeyPadHandler+0x70>
     4ee:	32 c0       	rjmp	.+100    	; 0x554 <vKeyPadHandler+0xd4>
     4f0:	85 30       	cpi	r24, 0x05	; 5
     4f2:	a9 f6       	brne	.-86     	; 0x49e <vKeyPadHandler+0x1e>
		{
			case IDK_SELECT:  // näppäinten käyttö
			
			taskENTER_CRITICAL(); //////////////////////////////////
     4f4:	0f b6       	in	r0, 0x3f	; 63
     4f6:	f8 94       	cli
     4f8:	0f 92       	push	r0
			ints[IDD_LASTKEY] = ch;                             ////
     4fa:	80 91 76 03 	lds	r24, 0x0376	; 0x800376 <ch.3070>
     4fe:	90 e0       	ldi	r25, 0x00	; 0
     500:	f8 01       	movw	r30, r16
     502:	95 83       	std	Z+5, r25	; 0x05
     504:	84 83       	std	Z+4, r24	; 0x04
			taskEXIT_CRITICAL();  //////////////////////////////////
     506:	0f 90       	pop	r0
     508:	0f be       	out	0x3f, r0	; 63
			// lähetään viesti lcd-näyttötaskille,jotta se päivittää näytön
			message.data      = 0; // näytön numero
     50a:	19 82       	std	Y+1, r1	; 0x01
			message.idMessage = IDM_UPDATE_DISPLAY;
     50c:	e8 82       	st	Y, r14
			xQueueSend( xDisplay, (void*)&message,0);
     50e:	20 e0       	ldi	r18, 0x00	; 0
     510:	40 e0       	ldi	r20, 0x00	; 0
     512:	50 e0       	ldi	r21, 0x00	; 0
     514:	be 01       	movw	r22, r28
     516:	80 91 8b 03 	lds	r24, 0x038B	; 0x80038b <xDisplay>
     51a:	90 91 8c 03 	lds	r25, 0x038C	; 0x80038c <xDisplay+0x1>
     51e:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <xQueueGenericSend>
			break;
     522:	bd cf       	rjmp	.-134    	; 0x49e <vKeyPadHandler+0x1e>
			
			case IDK_DOWN: case IDK_UP: 
			taskENTER_CRITICAL(); //////////////////////////////////
     524:	0f b6       	in	r0, 0x3f	; 63
     526:	f8 94       	cli
     528:	0f 92       	push	r0
			ints[IDD_LASTKEY] = ch;                             ////
     52a:	80 91 76 03 	lds	r24, 0x0376	; 0x800376 <ch.3070>
     52e:	90 e0       	ldi	r25, 0x00	; 0
     530:	f8 01       	movw	r30, r16
     532:	95 83       	std	Z+5, r25	; 0x05
     534:	84 83       	std	Z+4, r24	; 0x04
			taskEXIT_CRITICAL();  //////////////////////////////////
     536:	0f 90       	pop	r0
     538:	0f be       	out	0x3f, r0	; 63
			// lähetään viesti lcd-näyttötaskille,jotta se päivittää näytön
			message.data      = 0; // näytön numero
     53a:	19 82       	std	Y+1, r1	; 0x01
			message.idMessage = IDM_DISPLAY_MINMAX;
     53c:	f8 82       	st	Y, r15
			xQueueSend( xDisplay, (void*)&message,0);
     53e:	20 e0       	ldi	r18, 0x00	; 0
     540:	40 e0       	ldi	r20, 0x00	; 0
     542:	50 e0       	ldi	r21, 0x00	; 0
     544:	be 01       	movw	r22, r28
     546:	80 91 8b 03 	lds	r24, 0x038B	; 0x80038b <xDisplay>
     54a:	90 91 8c 03 	lds	r25, 0x038C	; 0x80038c <xDisplay+0x1>
     54e:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <xQueueGenericSend>
			break;
     552:	a5 cf       	rjmp	.-182    	; 0x49e <vKeyPadHandler+0x1e>
			
			case IDK_RIGHT: case IDK_LEFT:
			taskENTER_CRITICAL(); //////////////////////////////////
     554:	0f b6       	in	r0, 0x3f	; 63
     556:	f8 94       	cli
     558:	0f 92       	push	r0
			ints[IDD_LASTKEY] = ch;                             ////
     55a:	80 91 76 03 	lds	r24, 0x0376	; 0x800376 <ch.3070>
     55e:	90 e0       	ldi	r25, 0x00	; 0
     560:	f8 01       	movw	r30, r16
     562:	95 83       	std	Z+5, r25	; 0x05
     564:	84 83       	std	Z+4, r24	; 0x04
			taskEXIT_CRITICAL();  //////////////////////////////////
     566:	0f 90       	pop	r0
     568:	0f be       	out	0x3f, r0	; 63
			// lähetään viesti lcd-näyttötaskille,jotta se päivittää näytön
			message.data      = 0; // näytön numero
     56a:	19 82       	std	Y+1, r1	; 0x01
			//message.idMessage = IDM_DISPLAY_HISTORY;
			message.idMessage = IDM_DISPLAY_TIME;
     56c:	d8 82       	st	Y, r13
			xQueueSend( xDisplay, (void*)&message,0);
     56e:	20 e0       	ldi	r18, 0x00	; 0
     570:	40 e0       	ldi	r20, 0x00	; 0
     572:	50 e0       	ldi	r21, 0x00	; 0
     574:	be 01       	movw	r22, r28
     576:	80 91 8b 03 	lds	r24, 0x038B	; 0x80038b <xDisplay>
     57a:	90 91 8c 03 	lds	r25, 0x038C	; 0x80038c <xDisplay+0x1>
     57e:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <xQueueGenericSend>
			break;
     582:	8d cf       	rjmp	.-230    	; 0x49e <vKeyPadHandler+0x1e>

00000584 <vDoMeasurements>:
	( void ) pvParameters; // Just to stop compiler warnings.
	int value ;

		static unsigned char  numberOfSensors;
		
		numberOfSensors = GetSensorCount(); // samassa johtimessa lämpöantureiden määrä
     584:	85 d7       	rcall	.+3850   	; 0x1490 <GetSensorCount>
     586:	80 93 73 03 	sts	0x0373, r24	; 0x800373 <numberOfSensors.3025>

			if (numberOfSensors)
			{
				value  = (int)(GetTemperature(0)/1000);
		        taskENTER_CRITICAL(); //////////////////////////
		        ints[ IDD_BUTTON ] = value ;                ////
     58a:	cd e8       	ldi	r28, 0x8D	; 141
     58c:	d3 e0       	ldi	r29, 0x03	; 3
     58e:	0f 2e       	mov	r0, r31
     590:	f8 ee       	ldi	r31, 0xE8	; 232
     592:	cf 2e       	mov	r12, r31
     594:	f3 e0       	ldi	r31, 0x03	; 3
     596:	df 2e       	mov	r13, r31
     598:	e1 2c       	mov	r14, r1
     59a:	f1 2c       	mov	r15, r1
     59c:	f0 2d       	mov	r31, r0


		for( ;; )
		{

			if (numberOfSensors)
     59e:	80 91 73 03 	lds	r24, 0x0373	; 0x800373 <numberOfSensors.3025>
     5a2:	88 23       	and	r24, r24
     5a4:	71 f0       	breq	.+28     	; 0x5c2 <vDoMeasurements+0x3e>
			{
				value  = (int)(GetTemperature(0)/1000);
     5a6:	80 e0       	ldi	r24, 0x00	; 0
     5a8:	90 e0       	ldi	r25, 0x00	; 0
     5aa:	74 d7       	rcall	.+3816   	; 0x1494 <GetTemperature>
		        taskENTER_CRITICAL(); //////////////////////////
     5ac:	0f b6       	in	r0, 0x3f	; 63
     5ae:	f8 94       	cli
     5b0:	0f 92       	push	r0
		        ints[ IDD_BUTTON ] = value ;                ////
     5b2:	a7 01       	movw	r20, r14
     5b4:	96 01       	movw	r18, r12
     5b6:	0e 94 f2 1f 	call	0x3fe4	; 0x3fe4 <__divmodsi4>
     5ba:	3f 83       	std	Y+7, r19	; 0x07
     5bc:	2e 83       	std	Y+6, r18	; 0x06
		        taskEXIT_CRITICAL(); ///////////////////////////
     5be:	0f 90       	pop	r0
     5c0:	0f be       	out	0x3f, r0	; 63
			}

			vTaskDelay(100);
     5c2:	84 e6       	ldi	r24, 0x64	; 100
     5c4:	90 e0       	ldi	r25, 0x00	; 0
     5c6:	0e 94 20 13 	call	0x2640	; 0x2640 <vTaskDelay>
		}
     5ca:	e9 cf       	rjmp	.-46     	; 0x59e <vDoMeasurements+0x1a>

000005cc <main>:
void OwnGets(char *pText);

//--------------------------------------------------------
// pääohjelma luo taskit ja käynnistää systeemin
int main( void )
{
     5cc:	af 92       	push	r10
     5ce:	bf 92       	push	r11
     5d0:	cf 92       	push	r12
     5d2:	df 92       	push	r13
     5d4:	ef 92       	push	r14
     5d6:	ff 92       	push	r15
     5d8:	0f 93       	push	r16
     5da:	1f 93       	push	r17
     5dc:	cf 93       	push	r28
     5de:	df 93       	push	r29
     5e0:	cd b7       	in	r28, 0x3d	; 61
     5e2:	de b7       	in	r29, 0x3e	; 62
     5e4:	a2 97       	sbiw	r28, 0x22	; 34
     5e6:	0f b6       	in	r0, 0x3f	; 63
     5e8:	f8 94       	cli
     5ea:	de bf       	out	0x3e, r29	; 62
     5ec:	0f be       	out	0x3f, r0	; 63
     5ee:	cd bf       	out	0x3d, r28	; 61
	xDisplay = xQueueCreate( 2, sizeof(DISPLAY_MESSAGE));// luodaan postilaatikko näyttötaskille
     5f0:	40 e0       	ldi	r20, 0x00	; 0
     5f2:	62 e0       	ldi	r22, 0x02	; 2
     5f4:	82 e0       	ldi	r24, 0x02	; 2
     5f6:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <xQueueGenericCreate>
     5fa:	90 93 8c 03 	sts	0x038C, r25	; 0x80038c <xDisplay+0x1>
     5fe:	80 93 8b 03 	sts	0x038B, r24	; 0x80038b <xDisplay>

	vSemaphoreCreateBinary( xADC );// luodaan semafori
     602:	43 e0       	ldi	r20, 0x03	; 3
     604:	60 e0       	ldi	r22, 0x00	; 0
     606:	81 e0       	ldi	r24, 0x01	; 1
     608:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <xQueueGenericCreate>
     60c:	90 93 8a 03 	sts	0x038A, r25	; 0x80038a <xADC+0x1>
     610:	80 93 89 03 	sts	0x0389, r24	; 0x800389 <xADC>
     614:	00 97       	sbiw	r24, 0x00	; 0
     616:	21 f0       	breq	.+8      	; 0x620 <main+0x54>
     618:	60 e0       	ldi	r22, 0x00	; 0
     61a:	70 e0       	ldi	r23, 0x00	; 0
     61c:	0e 94 ec 0e 	call	0x1dd8	; 0x1dd8 <xQueueGive>
	vSemaphoreCreateBinary( xDisplaySemaphore);
     620:	43 e0       	ldi	r20, 0x03	; 3
     622:	60 e0       	ldi	r22, 0x00	; 0
     624:	81 e0       	ldi	r24, 0x01	; 1
     626:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <xQueueGenericCreate>
     62a:	90 93 88 03 	sts	0x0388, r25	; 0x800388 <xDisplaySemaphore+0x1>
     62e:	80 93 87 03 	sts	0x0387, r24	; 0x800387 <xDisplaySemaphore>
     632:	00 97       	sbiw	r24, 0x00	; 0
     634:	21 f0       	breq	.+8      	; 0x63e <main+0x72>
     636:	60 e0       	ldi	r22, 0x00	; 0
     638:	70 e0       	ldi	r23, 0x00	; 0
     63a:	0e 94 ec 0e 	call	0x1dd8	; 0x1dd8 <xQueueGive>

	// alustetaan sarjaportti
    xSerialPort = xSerialPortInitMinimal(0, mainCOM_BAUD_RATE, comBUFFER_LEN ,10);
     63e:	0f 2e       	mov	r0, r31
     640:	fa e0       	ldi	r31, 0x0A	; 10
     642:	ef 2e       	mov	r14, r31
     644:	f1 2c       	mov	r15, r1
     646:	f0 2d       	mov	r31, r0
     648:	02 e3       	ldi	r16, 0x32	; 50
     64a:	10 e0       	ldi	r17, 0x00	; 0
     64c:	20 e8       	ldi	r18, 0x80	; 128
     64e:	35 e2       	ldi	r19, 0x25	; 37
     650:	40 e0       	ldi	r20, 0x00	; 0
     652:	50 e0       	ldi	r21, 0x00	; 0
     654:	60 e0       	ldi	r22, 0x00	; 0
     656:	ce 01       	movw	r24, r28
     658:	01 96       	adiw	r24, 0x01	; 1
     65a:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <xSerialPortInitMinimal>
     65e:	82 e2       	ldi	r24, 0x22	; 34
     660:	fe 01       	movw	r30, r28
     662:	31 96       	adiw	r30, 0x01	; 1
     664:	af ef       	ldi	r26, 0xFF	; 255
     666:	b5 e1       	ldi	r27, 0x15	; 21
     668:	01 90       	ld	r0, Z+
     66a:	0d 92       	st	X+, r0
     66c:	8a 95       	dec	r24
     66e:	e1 f7       	brne	.-8      	; 0x668 <main+0x9c>
	lcd_init(LCD_DISP_ON);  // lcd-kuntoon
     670:	8c e0       	ldi	r24, 0x0C	; 12
     672:	67 d4       	rcall	.+2254   	; 0xf42 <lcd_init>

	// luodaan taskit
	xTaskCreate( vLcdHandler, 0, configMINIMAL_STACK_SIZE, 0,  (tskIDLE_PRIORITY + 2), NULL );
     674:	a1 2c       	mov	r10, r1
     676:	b1 2c       	mov	r11, r1
     678:	c1 2c       	mov	r12, r1
     67a:	d1 2c       	mov	r13, r1
     67c:	e1 2c       	mov	r14, r1
     67e:	f1 2c       	mov	r15, r1
     680:	02 e0       	ldi	r16, 0x02	; 2
     682:	20 e0       	ldi	r18, 0x00	; 0
     684:	30 e0       	ldi	r19, 0x00	; 0
     686:	44 e6       	ldi	r20, 0x64	; 100
     688:	50 e0       	ldi	r21, 0x00	; 0
     68a:	60 e0       	ldi	r22, 0x00	; 0
     68c:	70 e0       	ldi	r23, 0x00	; 0
     68e:	83 e9       	ldi	r24, 0x93	; 147
     690:	94 e0       	ldi	r25, 0x04	; 4
     692:	0e 94 10 12 	call	0x2420	; 0x2420 <xTaskGenericCreate>
	xTaskCreate( vDoMeasurements, 0, configMINIMAL_STACK_SIZE, 0,  (tskIDLE_PRIORITY + 2), NULL );
     696:	20 e0       	ldi	r18, 0x00	; 0
     698:	30 e0       	ldi	r19, 0x00	; 0
     69a:	44 e6       	ldi	r20, 0x64	; 100
     69c:	50 e0       	ldi	r21, 0x00	; 0
     69e:	60 e0       	ldi	r22, 0x00	; 0
     6a0:	70 e0       	ldi	r23, 0x00	; 0
     6a2:	82 ec       	ldi	r24, 0xC2	; 194
     6a4:	92 e0       	ldi	r25, 0x02	; 2
     6a6:	0e 94 10 12 	call	0x2420	; 0x2420 <xTaskGenericCreate>
	xTaskCreate( vKeyPadHandler, 0, configMINIMAL_STACK_SIZE, 0,  (tskIDLE_PRIORITY + 2), NULL );
     6aa:	20 e0       	ldi	r18, 0x00	; 0
     6ac:	30 e0       	ldi	r19, 0x00	; 0
     6ae:	44 e6       	ldi	r20, 0x64	; 100
     6b0:	50 e0       	ldi	r21, 0x00	; 0
     6b2:	60 e0       	ldi	r22, 0x00	; 0
     6b4:	70 e0       	ldi	r23, 0x00	; 0
     6b6:	80 e4       	ldi	r24, 0x40	; 64
     6b8:	92 e0       	ldi	r25, 0x02	; 2
     6ba:	0e 94 10 12 	call	0x2420	; 0x2420 <xTaskGenericCreate>
	
	xTaskCreate( vClock, 0, configMINIMAL_STACK_SIZE, 0,  (tskIDLE_PRIORITY + 2), NULL );
     6be:	20 e0       	ldi	r18, 0x00	; 0
     6c0:	30 e0       	ldi	r19, 0x00	; 0
     6c2:	44 e6       	ldi	r20, 0x64	; 100
     6c4:	50 e0       	ldi	r21, 0x00	; 0
     6c6:	60 e0       	ldi	r22, 0x00	; 0
     6c8:	70 e0       	ldi	r23, 0x00	; 0
     6ca:	82 e9       	ldi	r24, 0x92	; 146
     6cc:	93 e0       	ldi	r25, 0x03	; 3
     6ce:	0e 94 10 12 	call	0x2420	; 0x2420 <xTaskGenericCreate>
	xTaskCreate( vTerminal, 0, configMINIMAL_STACK_SIZE, 0,  (tskIDLE_PRIORITY + 2), NULL );
     6d2:	20 e0       	ldi	r18, 0x00	; 0
     6d4:	30 e0       	ldi	r19, 0x00	; 0
     6d6:	44 e6       	ldi	r20, 0x64	; 100
     6d8:	50 e0       	ldi	r21, 0x00	; 0
     6da:	60 e0       	ldi	r22, 0x00	; 0
     6dc:	70 e0       	ldi	r23, 0x00	; 0
     6de:	81 e3       	ldi	r24, 0x31	; 49
     6e0:	92 e0       	ldi	r25, 0x02	; 2
     6e2:	0e 94 10 12 	call	0x2420	; 0x2420 <xTaskGenericCreate>
	
	vTaskStartScheduler();  // ajastus päälle
     6e6:	0e 94 be 14 	call	0x297c	; 0x297c <vTaskStartScheduler>

	return 0;
}
     6ea:	80 e0       	ldi	r24, 0x00	; 0
     6ec:	90 e0       	ldi	r25, 0x00	; 0
     6ee:	a2 96       	adiw	r28, 0x22	; 34
     6f0:	0f b6       	in	r0, 0x3f	; 63
     6f2:	f8 94       	cli
     6f4:	de bf       	out	0x3e, r29	; 62
     6f6:	0f be       	out	0x3f, r0	; 63
     6f8:	cd bf       	out	0x3d, r28	; 61
     6fa:	df 91       	pop	r29
     6fc:	cf 91       	pop	r28
     6fe:	1f 91       	pop	r17
     700:	0f 91       	pop	r16
     702:	ff 90       	pop	r15
     704:	ef 90       	pop	r14
     706:	df 90       	pop	r13
     708:	cf 90       	pop	r12
     70a:	bf 90       	pop	r11
     70c:	af 90       	pop	r10
     70e:	08 95       	ret

00000710 <StartTimer>:
////////////////////////////////////////////////////////////////
void StartTimer( int ticks)
{
	// ks. manuaalia doc2549.pdf sivulta 118 alkaen
	// 0 = stop  1 = clock  2 = clock/8 3 = clock/64  4 = clock/256 5 = clock/1024
	TCCR0B = (1<<FOC0A) | ( 1<<CS02) | (1<<CS00); // prosessorin kellotaajuus/1024   , jos 16MHz => 64 us
     710:	95 e8       	ldi	r25, 0x85	; 133
     712:	95 bd       	out	0x25, r25	; 37
	TIMSK0 |= (1 << OCIE0A); // vertailuarvokeskeytys
     714:	ee e6       	ldi	r30, 0x6E	; 110
     716:	f0 e0       	ldi	r31, 0x00	; 0
     718:	90 81       	ld	r25, Z
     71a:	92 60       	ori	r25, 0x02	; 2
     71c:	90 83       	st	Z, r25
	OCR0A = ticks; // laitetaan vertailuarvoksi annettu lukema
     71e:	87 bd       	out	0x27, r24	; 39
	TCNT0 = 0;    // laskuri alkuun
     720:	16 bc       	out	0x26, r1	; 38
     722:	08 95       	ret

00000724 <vClock>:
}
static void vClock( void *pvParameters )
{
	( void ) pvParameters; // Just to stop compiler warnings.

	vSemaphoreCreateBinary( xClock );// luodaan semafori
     724:	43 e0       	ldi	r20, 0x03	; 3
     726:	60 e0       	ldi	r22, 0x00	; 0
     728:	81 e0       	ldi	r24, 0x01	; 1
     72a:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <xQueueGenericCreate>
     72e:	90 93 78 03 	sts	0x0378, r25	; 0x800378 <xClock+0x1>
     732:	80 93 77 03 	sts	0x0377, r24	; 0x800377 <xClock>
     736:	00 97       	sbiw	r24, 0x00	; 0
     738:	21 f0       	breq	.+8      	; 0x742 <vClock+0x1e>
     73a:	60 e0       	ldi	r22, 0x00	; 0
     73c:	70 e0       	ldi	r23, 0x00	; 0
     73e:	0e 94 ec 0e 	call	0x1dd8	; 0x1dd8 <xQueueGive>

	StartTimer(125); // = 8 msekunnin välein keskeytys 8*125 = 1000ms = 1s
     742:	8d e7       	ldi	r24, 0x7D	; 125
     744:	90 e0       	ldi	r25, 0x00	; 0
     746:	e4 df       	rcall	.-56     	; 0x710 <StartTimer>
	for( ;; )//.........
	{
		xSemaphoreTake( xClock, portMAX_DELAY ); // odotetaan tietoa keskeytyksestä

		taskENTER_CRITICAL(); /////////////////////////////////////////
		intsTime[ IDD_HOUR ]   =  secondsFromMidNight / 3600L;         ////
     748:	c9 e7       	ldi	r28, 0x79	; 121
     74a:	d3 e0       	ldi	r29, 0x03	; 3
     74c:	00 e1       	ldi	r16, 0x10	; 16
     74e:	1e e0       	ldi	r17, 0x0E	; 14
		intsTime[ IDD_MINUTES ]= (secondsFromMidNight % 3600L) / 60L ; ////
		intsTime[ IDD_SECONDS ]=  secondsFromMidNight % 60L;           ////
     750:	0f 2e       	mov	r0, r31
     752:	fc e3       	ldi	r31, 0x3C	; 60
     754:	ff 2e       	mov	r15, r31
     756:	f0 2d       	mov	r31, r0
	StartTimer(125); // = 8 msekunnin välein keskeytys 8*125 = 1000ms = 1s
	
	// taskilla tulee aina  olla ikisilmukka
	for( ;; )//.........
	{
		xSemaphoreTake( xClock, portMAX_DELAY ); // odotetaan tietoa keskeytyksestä
     758:	20 e0       	ldi	r18, 0x00	; 0
     75a:	4f ef       	ldi	r20, 0xFF	; 255
     75c:	5f ef       	ldi	r21, 0xFF	; 255
     75e:	60 e0       	ldi	r22, 0x00	; 0
     760:	70 e0       	ldi	r23, 0x00	; 0
     762:	80 91 77 03 	lds	r24, 0x0377	; 0x800377 <xClock>
     766:	90 91 78 03 	lds	r25, 0x0378	; 0x800378 <xClock+0x1>
     76a:	0e 94 84 10 	call	0x2108	; 0x2108 <xQueueGenericReceive>

		taskENTER_CRITICAL(); /////////////////////////////////////////
     76e:	0f b6       	in	r0, 0x3f	; 63
     770:	f8 94       	cli
     772:	0f 92       	push	r0
		intsTime[ IDD_HOUR ]   =  secondsFromMidNight / 3600L;         ////
     774:	e0 91 85 03 	lds	r30, 0x0385	; 0x800385 <secondsFromMidNight>
     778:	f0 91 86 03 	lds	r31, 0x0386	; 0x800386 <secondsFromMidNight+0x1>
     77c:	cf 01       	movw	r24, r30
     77e:	b8 01       	movw	r22, r16
     780:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <__udivmodhi4>
     784:	79 83       	std	Y+1, r23	; 0x01
     786:	68 83       	st	Y, r22
		intsTime[ IDD_MINUTES ]= (secondsFromMidNight % 3600L) / 60L ; ////
     788:	9c 01       	movw	r18, r24
     78a:	a9 e8       	ldi	r26, 0x89	; 137
     78c:	b8 e8       	ldi	r27, 0x88	; 136
     78e:	0e 94 16 20 	call	0x402c	; 0x402c <__umulhisi3>
     792:	96 95       	lsr	r25
     794:	87 95       	ror	r24
     796:	92 95       	swap	r25
     798:	82 95       	swap	r24
     79a:	8f 70       	andi	r24, 0x0F	; 15
     79c:	89 27       	eor	r24, r25
     79e:	9f 70       	andi	r25, 0x0F	; 15
     7a0:	89 27       	eor	r24, r25
     7a2:	9b 83       	std	Y+3, r25	; 0x03
     7a4:	8a 83       	std	Y+2, r24	; 0x02
		intsTime[ IDD_SECONDS ]=  secondsFromMidNight % 60L;           ////
     7a6:	9f 01       	movw	r18, r30
     7a8:	0e 94 16 20 	call	0x402c	; 0x402c <__umulhisi3>
     7ac:	96 95       	lsr	r25
     7ae:	87 95       	ror	r24
     7b0:	92 95       	swap	r25
     7b2:	82 95       	swap	r24
     7b4:	8f 70       	andi	r24, 0x0F	; 15
     7b6:	89 27       	eor	r24, r25
     7b8:	9f 70       	andi	r25, 0x0F	; 15
     7ba:	89 27       	eor	r24, r25
     7bc:	f8 9e       	mul	r15, r24
     7be:	90 01       	movw	r18, r0
     7c0:	f9 9e       	mul	r15, r25
     7c2:	30 0d       	add	r19, r0
     7c4:	11 24       	eor	r1, r1
     7c6:	e2 1b       	sub	r30, r18
     7c8:	f3 0b       	sbc	r31, r19
     7ca:	fd 83       	std	Y+5, r31	; 0x05
     7cc:	ec 83       	std	Y+4, r30	; 0x04
		taskEXIT_CRITICAL(); //////////////////////////////////////////
     7ce:	0f 90       	pop	r0
     7d0:	0f be       	out	0x3f, r0	; 63
     7d2:	c2 cf       	rjmp	.-124    	; 0x758 <vClock+0x34>

000007d4 <__vector_21>:
	OCR0A = ticks; // laitetaan vertailuarvoksi annettu lukema
	TCNT0 = 0;    // laskuri alkuun
}

////////////////////////////////////////////////////////////////
SIGNAL(TIMER0_COMPA_vect) {
     7d4:	1f 92       	push	r1
     7d6:	0f 92       	push	r0
     7d8:	0f b6       	in	r0, 0x3f	; 63
     7da:	0f 92       	push	r0
     7dc:	11 24       	eor	r1, r1
     7de:	0b b6       	in	r0, 0x3b	; 59
     7e0:	0f 92       	push	r0
     7e2:	2f 93       	push	r18
     7e4:	3f 93       	push	r19
     7e6:	4f 93       	push	r20
     7e8:	5f 93       	push	r21
     7ea:	6f 93       	push	r22
     7ec:	7f 93       	push	r23
     7ee:	8f 93       	push	r24
     7f0:	9f 93       	push	r25
     7f2:	af 93       	push	r26
     7f4:	bf 93       	push	r27
     7f6:	ef 93       	push	r30
     7f8:	ff 93       	push	r31
	static BaseType_t xTaskWoken = pdFALSE;
	static unsigned msCounter = 0;
	msCounter += 8 ; // interval 8ms
     7fa:	80 91 6f 03 	lds	r24, 0x036F	; 0x80036f <msCounter.3091>
     7fe:	90 91 70 03 	lds	r25, 0x0370	; 0x800370 <msCounter.3091+0x1>
     802:	08 96       	adiw	r24, 0x08	; 8
     804:	90 93 70 03 	sts	0x0370, r25	; 0x800370 <msCounter.3091+0x1>
     808:	80 93 6f 03 	sts	0x036F, r24	; 0x80036f <msCounter.3091>
	TCNT0 = 0; // laskuri alkuun
     80c:	16 bc       	out	0x26, r1	; 38
	//timer0 interrupt handler
	if ( msCounter == 1000)
     80e:	80 91 6f 03 	lds	r24, 0x036F	; 0x80036f <msCounter.3091>
     812:	90 91 70 03 	lds	r25, 0x0370	; 0x800370 <msCounter.3091+0x1>
     816:	88 3e       	cpi	r24, 0xE8	; 232
     818:	93 40       	sbci	r25, 0x03	; 3
     81a:	a9 f4       	brne	.+42     	; 0x846 <__vector_21+0x72>
	{
		secondsFromMidNight++;
     81c:	80 91 85 03 	lds	r24, 0x0385	; 0x800385 <secondsFromMidNight>
     820:	90 91 86 03 	lds	r25, 0x0386	; 0x800386 <secondsFromMidNight+0x1>
     824:	01 96       	adiw	r24, 0x01	; 1
     826:	90 93 86 03 	sts	0x0386, r25	; 0x800386 <secondsFromMidNight+0x1>
     82a:	80 93 85 03 	sts	0x0385, r24	; 0x800385 <secondsFromMidNight>
		xSemaphoreGiveFromISR( xClock, &xTaskWoken ); // ilmoitetaan kellonajan muutos
     82e:	6e e6       	ldi	r22, 0x6E	; 110
     830:	73 e0       	ldi	r23, 0x03	; 3
     832:	80 91 77 03 	lds	r24, 0x0377	; 0x800377 <xClock>
     836:	90 91 78 03 	lds	r25, 0x0378	; 0x800378 <xClock+0x1>
     83a:	0e 94 59 10 	call	0x20b2	; 0x20b2 <xQueueGiveFromISR>
		msCounter = 0;
     83e:	10 92 70 03 	sts	0x0370, r1	; 0x800370 <msCounter.3091+0x1>
     842:	10 92 6f 03 	sts	0x036F, r1	; 0x80036f <msCounter.3091>
	}
}
     846:	ff 91       	pop	r31
     848:	ef 91       	pop	r30
     84a:	bf 91       	pop	r27
     84c:	af 91       	pop	r26
     84e:	9f 91       	pop	r25
     850:	8f 91       	pop	r24
     852:	7f 91       	pop	r23
     854:	6f 91       	pop	r22
     856:	5f 91       	pop	r21
     858:	4f 91       	pop	r20
     85a:	3f 91       	pop	r19
     85c:	2f 91       	pop	r18
     85e:	0f 90       	pop	r0
     860:	0b be       	out	0x3b, r0	; 59
     862:	0f 90       	pop	r0
     864:	0f be       	out	0x3f, r0	; 63
     866:	0f 90       	pop	r0
     868:	1f 90       	pop	r1
     86a:	18 95       	reti

0000086c <ShowTime>:
////////////////////////////////////////////////////////////////

void ShowTime(void)
{
     86c:	0f 93       	push	r16
     86e:	1f 93       	push	r17
     870:	cf 93       	push	r28
     872:	df 93       	push	r29
     874:	cd b7       	in	r28, 0x3d	; 61
     876:	de b7       	in	r29, 0x3e	; 62
     878:	28 97       	sbiw	r28, 0x08	; 8
     87a:	0f b6       	in	r0, 0x3f	; 63
     87c:	f8 94       	cli
     87e:	de bf       	out	0x3e, r29	; 62
     880:	0f be       	out	0x3f, r0	; 63
     882:	cd bf       	out	0x3d, r28	; 61
	char  szVariable[8];  // muuttujan arvo tulostetaan tähän

	lcd_gotoxy(0,0);
     884:	60 e0       	ldi	r22, 0x00	; 0
     886:	80 e0       	ldi	r24, 0x00	; 0
     888:	2c d3       	rcall	.+1624   	; 0xee2 <lcd_gotoxy>
	// tunnit
	if( intsTime[IDD_HOUR] < 10)
     88a:	80 91 79 03 	lds	r24, 0x0379	; 0x800379 <intsTime>
     88e:	90 91 7a 03 	lds	r25, 0x037A	; 0x80037a <intsTime+0x1>
     892:	0a 97       	sbiw	r24, 0x0a	; 10
     894:	14 f4       	brge	.+4      	; 0x89a <ShowTime+0x2e>
	lcd_putc('0');
     896:	80 e3       	ldi	r24, 0x30	; 48
     898:	41 d3       	rcall	.+1666   	; 0xf1c <lcd_putc>
	itoa(intsTime[IDD_HOUR],szVariable,10);
     89a:	09 e7       	ldi	r16, 0x79	; 121
     89c:	13 e0       	ldi	r17, 0x03	; 3
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     89e:	4a e0       	ldi	r20, 0x0A	; 10
     8a0:	be 01       	movw	r22, r28
     8a2:	6f 5f       	subi	r22, 0xFF	; 255
     8a4:	7f 4f       	sbci	r23, 0xFF	; 255
     8a6:	f8 01       	movw	r30, r16
     8a8:	80 81       	ld	r24, Z
     8aa:	91 81       	ldd	r25, Z+1	; 0x01
     8ac:	0e 94 35 20 	call	0x406a	; 0x406a <__itoa_ncheck>
	lcd_puts(szVariable);
     8b0:	ce 01       	movw	r24, r28
     8b2:	01 96       	adiw	r24, 0x01	; 1
	lcd_putc(':');
     8b4:	37 d3       	rcall	.+1646   	; 0xf24 <lcd_puts>
     8b6:	8a e3       	ldi	r24, 0x3A	; 58
     8b8:	31 d3       	rcall	.+1634   	; 0xf1c <lcd_putc>
	// minuutit
	if( intsTime[IDD_MINUTES] < 10)
     8ba:	f8 01       	movw	r30, r16
     8bc:	82 81       	ldd	r24, Z+2	; 0x02
     8be:	93 81       	ldd	r25, Z+3	; 0x03
     8c0:	0a 97       	sbiw	r24, 0x0a	; 10
	lcd_putc('0');
     8c2:	14 f4       	brge	.+4      	; 0x8c8 <ShowTime+0x5c>
     8c4:	80 e3       	ldi	r24, 0x30	; 48
     8c6:	2a d3       	rcall	.+1620   	; 0xf1c <lcd_putc>
	itoa(intsTime[IDD_MINUTES],szVariable,10);
     8c8:	09 e7       	ldi	r16, 0x79	; 121
     8ca:	13 e0       	ldi	r17, 0x03	; 3
     8cc:	4a e0       	ldi	r20, 0x0A	; 10
     8ce:	be 01       	movw	r22, r28
     8d0:	6f 5f       	subi	r22, 0xFF	; 255
     8d2:	7f 4f       	sbci	r23, 0xFF	; 255
     8d4:	f8 01       	movw	r30, r16
     8d6:	82 81       	ldd	r24, Z+2	; 0x02
     8d8:	93 81       	ldd	r25, Z+3	; 0x03
     8da:	0e 94 35 20 	call	0x406a	; 0x406a <__itoa_ncheck>
	lcd_puts(szVariable);
     8de:	ce 01       	movw	r24, r28
     8e0:	01 96       	adiw	r24, 0x01	; 1
     8e2:	20 d3       	rcall	.+1600   	; 0xf24 <lcd_puts>
	lcd_putc(':');
     8e4:	8a e3       	ldi	r24, 0x3A	; 58
     8e6:	1a d3       	rcall	.+1588   	; 0xf1c <lcd_putc>
	// sekunnit
	if( intsTime[IDD_SECONDS] < 10)
     8e8:	f8 01       	movw	r30, r16
     8ea:	84 81       	ldd	r24, Z+4	; 0x04
     8ec:	95 81       	ldd	r25, Z+5	; 0x05
     8ee:	0a 97       	sbiw	r24, 0x0a	; 10
     8f0:	14 f4       	brge	.+4      	; 0x8f6 <ShowTime+0x8a>
	lcd_putc('0');
     8f2:	80 e3       	ldi	r24, 0x30	; 48
     8f4:	13 d3       	rcall	.+1574   	; 0xf1c <lcd_putc>
     8f6:	4a e0       	ldi	r20, 0x0A	; 10
     8f8:	be 01       	movw	r22, r28
     8fa:	6f 5f       	subi	r22, 0xFF	; 255
     8fc:	7f 4f       	sbci	r23, 0xFF	; 255
     8fe:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <intsTime+0x4>
     902:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <intsTime+0x5>
     906:	0e 94 35 20 	call	0x406a	; 0x406a <__itoa_ncheck>
	itoa(intsTime[IDD_SECONDS],szVariable,10);
	lcd_puts(szVariable);
     90a:	ce 01       	movw	r24, r28
     90c:	01 96       	adiw	r24, 0x01	; 1
     90e:	0a d3       	rcall	.+1556   	; 0xf24 <lcd_puts>
     910:	28 96       	adiw	r28, 0x08	; 8
}
     912:	0f b6       	in	r0, 0x3f	; 63
     914:	f8 94       	cli
     916:	de bf       	out	0x3e, r29	; 62
     918:	0f be       	out	0x3f, r0	; 63
     91a:	cd bf       	out	0x3d, r28	; 61
     91c:	df 91       	pop	r29
     91e:	cf 91       	pop	r28
     920:	1f 91       	pop	r17
     922:	0f 91       	pop	r16
     924:	08 95       	ret

00000926 <vLcdHandler>:
     926:	cf 93       	push	r28
		}
	
}
//--------------------- lcd-näyttöä päivittävä taski -------------------------------
static void vLcdHandler( void *pvParameters )
{
     928:	df 93       	push	r29
     92a:	cd b7       	in	r28, 0x3d	; 61
     92c:	de b7       	in	r29, 0x3e	; 62
     92e:	28 97       	sbiw	r28, 0x08	; 8
     930:	0f b6       	in	r0, 0x3f	; 63
     932:	f8 94       	cli
     934:	de bf       	out	0x3e, r29	; 62
     936:	0f be       	out	0x3f, r0	; 63
     938:	cd bf       	out	0x3d, r28	; 61

	char *pDisplay[] = {"VALUE=%i03   \nBUTTON=%i02"};
     93a:	0f 2e       	mov	r0, r31
     93c:	fe e6       	ldi	r31, 0x6E	; 110
     93e:	af 2e       	mov	r10, r31
     940:	f2 e0       	ldi	r31, 0x02	; 2
     942:	bf 2e       	mov	r11, r31
     944:	f0 2d       	mov	r31, r0
	volatile  char *pChDisplay =0,  // osoitin, jota osoittaa nytn pohjatekstiss olevaan kirjaimeen
     946:	00 e0       	ldi	r16, 0x00	; 0
     948:	10 e0       	ldi	r17, 0x00	; 0
						i +=  (*pChDisplay- '0'); // indeksi ints-taulukkoon
						taskENTER_CRITICAL(); //////////////////////////////////
						itoa(ints[i],szVariable,10);                        ////
						taskEXIT_CRITICAL();  //////////////////////////////////
						szVariable[3] = szVariable[2];
						szVariable[2] = ',';
     94a:	0f 2e       	mov	r0, r31
     94c:	fc e2       	ldi	r31, 0x2C	; 44
     94e:	9f 2e       	mov	r9, r31
     950:	f0 2d       	mov	r31, r0
			
			case IDM_DISPLAY_MINMAX:
			xSemaphoreTake( xDisplaySemaphore, portMAX_DELAY ); 
			if( message.data == 0 )
			pChDisplay = pDisplay[0];
			*pDisplay = "Display=%i03 C  \nMinMax=%i02";
     952:	0f 2e       	mov	r0, r31
     954:	f1 e5       	ldi	r31, 0x51	; 81
     956:	cf 2e       	mov	r12, r31
     958:	f2 e0       	ldi	r31, 0x02	; 2
     95a:	df 2e       	mov	r13, r31
     95c:	f0 2d       	mov	r31, r0
			
			case IDM_DISPLAY_HISTORY:
			xSemaphoreTake( xDisplaySemaphore, portMAX_DELAY ); // ei tarpeen, koska portissa B ei muita laitteita
			if( message.data == 0 )
			pChDisplay = pDisplay[0];
			*pDisplay = "Display=%i03 C  \nHistory=%i02";
     95e:	0f 2e       	mov	r0, r31
     960:	f6 e1       	ldi	r31, 0x16	; 22
     962:	ef 2e       	mov	r14, r31
     964:	f2 e0       	ldi	r31, 0x02	; 2
     966:	ff 2e       	mov	r15, r31
     968:	f0 2d       	mov	r31, r0
			case IDM_UPDATE_DISPLAY:
			xSemaphoreTake( xDisplaySemaphore, portMAX_DELAY ); // ei tarpeen, koska portissa B ei muita laitteita
			if( message.data == 0 )
			pChDisplay = pDisplay[0];
			
			*pDisplay = "Update=%i03 C  \nDisplay=%i02";
     96a:	0f 2e       	mov	r0, r31
     96c:	f4 e3       	ldi	r31, 0x34	; 52
     96e:	6f 2e       	mov	r6, r31
     970:	f2 e0       	ldi	r31, 0x02	; 2
     972:	7f 2e       	mov	r7, r31
     974:	f0 2d       	mov	r31, r0


	// taskilla tulee aina  olla ikisilmukka
	for( ;; )//.................
	{
		xQueueReceive(xDisplay,&message, portMAX_DELAY); // odotetaan viestiä
     976:	20 e0       	ldi	r18, 0x00	; 0
     978:	4f ef       	ldi	r20, 0xFF	; 255
     97a:	5f ef       	ldi	r21, 0xFF	; 255
     97c:	61 e7       	ldi	r22, 0x71	; 113
     97e:	73 e0       	ldi	r23, 0x03	; 3
     980:	80 91 8b 03 	lds	r24, 0x038B	; 0x80038b <xDisplay>
     984:	90 91 8c 03 	lds	r25, 0x038C	; 0x80038c <xDisplay+0x1>
     988:	0e 94 84 10 	call	0x2108	; 0x2108 <xQueueGenericReceive>
	
		switch( message.idMessage)
     98c:	80 91 71 03 	lds	r24, 0x0371	; 0x800371 <message.3035>
     990:	83 30       	cpi	r24, 0x03	; 3
     992:	09 f4       	brne	.+2      	; 0x996 <vLcdHandler+0x70>
     994:	03 c1       	rjmp	.+518    	; 0xb9c <vLcdHandler+0x276>
     996:	18 f4       	brcc	.+6      	; 0x99e <vLcdHandler+0x78>
     998:	82 30       	cpi	r24, 0x02	; 2
     99a:	41 f0       	breq	.+16     	; 0x9ac <vLcdHandler+0x86>
     99c:	90 c1       	rjmp	.+800    	; 0xcbe <vLcdHandler+0x398>
     99e:	84 30       	cpi	r24, 0x04	; 4
     9a0:	09 f4       	brne	.+2      	; 0x9a4 <vLcdHandler+0x7e>
     9a2:	80 c0       	rjmp	.+256    	; 0xaa4 <vLcdHandler+0x17e>
     9a4:	85 30       	cpi	r24, 0x05	; 5
     9a6:	09 f4       	brne	.+2      	; 0x9aa <vLcdHandler+0x84>
     9a8:	75 c1       	rjmp	.+746    	; 0xc94 <vLcdHandler+0x36e>
     9aa:	89 c1       	rjmp	.+786    	; 0xcbe <vLcdHandler+0x398>
		{
			case IDM_UPDATE_DISPLAY:
			xSemaphoreTake( xDisplaySemaphore, portMAX_DELAY ); // ei tarpeen, koska portissa B ei muita laitteita
     9ac:	20 e0       	ldi	r18, 0x00	; 0
     9ae:	4f ef       	ldi	r20, 0xFF	; 255
     9b0:	5f ef       	ldi	r21, 0xFF	; 255
     9b2:	60 e0       	ldi	r22, 0x00	; 0
     9b4:	70 e0       	ldi	r23, 0x00	; 0
     9b6:	80 91 87 03 	lds	r24, 0x0387	; 0x800387 <xDisplaySemaphore>
     9ba:	90 91 88 03 	lds	r25, 0x0388	; 0x800388 <xDisplaySemaphore+0x1>
     9be:	0e 94 84 10 	call	0x2108	; 0x2108 <xQueueGenericReceive>
			if( message.data == 0 )
     9c2:	80 91 72 03 	lds	r24, 0x0372	; 0x800372 <message.3035+0x1>
     9c6:	81 11       	cpse	r24, r1
     9c8:	01 c0       	rjmp	.+2      	; 0x9cc <vLcdHandler+0xa6>
			pChDisplay = pDisplay[0];
     9ca:	85 01       	movw	r16, r10
			
			*pDisplay = "Update=%i03 C  \nDisplay=%i02";
			
			// ja vain tämä taski käyttää lcd:tä
			lcd_gotoxy(0,0); // lcd-näytön alkuun
     9cc:	60 e0       	ldi	r22, 0x00	; 0
     9ce:	80 e0       	ldi	r24, 0x00	; 0
     9d0:	88 d2       	rcall	.+1296   	; 0xee2 <lcd_gotoxy>
			//// tulostetaan näyttö tässä silmukassa
			while(*pChDisplay != 0)
     9d2:	d8 01       	movw	r26, r16
     9d4:	8c 91       	ld	r24, X
     9d6:	88 23       	and	r24, r24
     9d8:	09 f4       	brne	.+2      	; 0x9dc <vLcdHandler+0xb6>
     9da:	5a c0       	rjmp	.+180    	; 0xa90 <vLcdHandler+0x16a>
			{
				// onko muuttujan tulostuspaikka?
				if( *pChDisplay == '%')
     9dc:	f8 01       	movw	r30, r16
     9de:	80 81       	ld	r24, Z
     9e0:	85 32       	cpi	r24, 0x25	; 37
     9e2:	09 f0       	breq	.+2      	; 0x9e6 <vLcdHandler+0xc0>
     9e4:	42 c0       	rjmp	.+132    	; 0xa6a <vLcdHandler+0x144>
				{
					pChDisplay++; //ohitetaan %-merkki
					// minkä tyypin dataa?
					switch(*pChDisplay)
     9e6:	81 81       	ldd	r24, Z+1	; 0x01
     9e8:	89 36       	cpi	r24, 0x69	; 105
     9ea:	29 f0       	breq	.+10     	; 0x9f6 <vLcdHandler+0xd0>
			while(*pChDisplay != 0)
			{
				// onko muuttujan tulostuspaikka?
				if( *pChDisplay == '%')
				{
					pChDisplay++; //ohitetaan %-merkki
     9ec:	58 01       	movw	r10, r16
     9ee:	ff ef       	ldi	r31, 0xFF	; 255
     9f0:	af 1a       	sub	r10, r31
     9f2:	bf 0a       	sbc	r11, r31
     9f4:	2b c0       	rjmp	.+86     	; 0xa4c <vLcdHandler+0x126>
					{
						// int-tyypin kokonaislukuja
						// muuttujan arvo poimitaan ints-taulukosta indeksin määräämästä paikasta
						case 'i': pChDisplay++;
						// indeksi annettu muodossa 09, 10,11,..
						i = (*pChDisplay - '0')*10;
     9f6:	82 81       	ldd	r24, Z+2	; 0x02
     9f8:	90 e0       	ldi	r25, 0x00	; 0
     9fa:	c0 97       	sbiw	r24, 0x30	; 48
     9fc:	fc 01       	movw	r30, r24
     9fe:	ee 0f       	add	r30, r30
     a00:	ff 1f       	adc	r31, r31
     a02:	88 0f       	add	r24, r24
     a04:	99 1f       	adc	r25, r25
     a06:	88 0f       	add	r24, r24
     a08:	99 1f       	adc	r25, r25
     a0a:	88 0f       	add	r24, r24
     a0c:	99 1f       	adc	r25, r25
     a0e:	e8 0f       	add	r30, r24
     a10:	f9 1f       	adc	r31, r25
						pChDisplay++;
     a12:	58 01       	movw	r10, r16
     a14:	b3 e0       	ldi	r27, 0x03	; 3
     a16:	ab 0e       	add	r10, r27
     a18:	b1 1c       	adc	r11, r1
						i +=  (*pChDisplay- '0'); // indeksi ints-taulukkoon
     a1a:	d8 01       	movw	r26, r16
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	8c 91       	ld	r24, X
						taskENTER_CRITICAL(); //////////////////////////////////
     a20:	0f b6       	in	r0, 0x3f	; 63
     a22:	f8 94       	cli
     a24:	0f 92       	push	r0
						itoa(ints[i],szVariable,10);                        //// // itoa transfers int to string inside the szVariable array
     a26:	e8 0f       	add	r30, r24
     a28:	f1 1d       	adc	r31, r1
     a2a:	ee 0f       	add	r30, r30
     a2c:	ff 1f       	adc	r31, r31
     a2e:	e3 5d       	subi	r30, 0xD3	; 211
     a30:	fc 4f       	sbci	r31, 0xFC	; 252
     a32:	4a e0       	ldi	r20, 0x0A	; 10
     a34:	be 01       	movw	r22, r28
     a36:	6f 5f       	subi	r22, 0xFF	; 255
     a38:	7f 4f       	sbci	r23, 0xFF	; 255
     a3a:	80 81       	ld	r24, Z
     a3c:	91 81       	ldd	r25, Z+1	; 0x01
     a3e:	0e 94 35 20 	call	0x406a	; 0x406a <__itoa_ncheck>
						taskEXIT_CRITICAL();  //////////////////////////////////
     a42:	0f 90       	pop	r0
     a44:	0f be       	out	0x3f, r0	; 63
						szVariable[3] = szVariable[2];
     a46:	8b 81       	ldd	r24, Y+3	; 0x03
     a48:	8c 83       	std	Y+4, r24	; 0x04
						szVariable[2] = ',';
     a4a:	9b 82       	std	Y+3, r9	; 0x03
						break;
					}
					// tulostetaan muuttuja
					pChVariable = szVariable;
					while(*pChVariable != 0)
     a4c:	89 81       	ldd	r24, Y+1	; 0x01
     a4e:	88 23       	and	r24, r24
     a50:	c1 f0       	breq	.+48     	; 0xa82 <vLcdHandler+0x15c>
     a52:	8e 01       	movw	r16, r28
     a54:	0f 5f       	subi	r16, 0xFF	; 255
     a56:	1f 4f       	sbci	r17, 0xFF	; 255
					{
						lcd_putc(*pChVariable); // merkki näkyviin
     a58:	f8 01       	movw	r30, r16
     a5a:	81 91       	ld	r24, Z+
     a5c:	8f 01       	movw	r16, r30
     a5e:	5e d2       	rcall	.+1212   	; 0xf1c <lcd_putc>
						szVariable[2] = ',';
						break;
					}
					// tulostetaan muuttuja
					pChVariable = szVariable;
					while(*pChVariable != 0)
     a60:	d8 01       	movw	r26, r16
     a62:	8c 91       	ld	r24, X
     a64:	81 11       	cpse	r24, r1
     a66:	f8 cf       	rjmp	.-16     	; 0xa58 <vLcdHandler+0x132>
     a68:	0c c0       	rjmp	.+24     	; 0xa82 <vLcdHandler+0x15c>
					{
						lcd_putc(*pChVariable); // merkki näkyviin
						pChVariable++; // seuraava kirjain
					}
				}
				else if(*pChDisplay == '\n')
     a6a:	f8 01       	movw	r30, r16
     a6c:	80 81       	ld	r24, Z
     a6e:	8a 30       	cpi	r24, 0x0A	; 10
     a70:	29 f4       	brne	.+10     	; 0xa7c <vLcdHandler+0x156>
				{
					lcd_gotoxy(0,1);
     a72:	61 e0       	ldi	r22, 0x01	; 1
     a74:	80 e0       	ldi	r24, 0x00	; 0
     a76:	35 d2       	rcall	.+1130   	; 0xee2 <lcd_gotoxy>
     a78:	58 01       	movw	r10, r16
				}
				else
				// näytön pohjateksti
				lcd_putc(*pChDisplay); // merkki näkyviin
     a7a:	03 c0       	rjmp	.+6      	; 0xa82 <vLcdHandler+0x15c>
     a7c:	80 81       	ld	r24, Z
     a7e:	4e d2       	rcall	.+1180   	; 0xf1c <lcd_putc>
     a80:	58 01       	movw	r10, r16

				pChDisplay++; // seuraava kirjain
     a82:	85 01       	movw	r16, r10
     a84:	0f 5f       	subi	r16, 0xFF	; 255
     a86:	1f 4f       	sbci	r17, 0xFF	; 255
			*pDisplay = "Update=%i03 C  \nDisplay=%i02";
			
			// ja vain tämä taski käyttää lcd:tä
			lcd_gotoxy(0,0); // lcd-näytön alkuun
			//// tulostetaan näyttö tässä silmukassa
			while(*pChDisplay != 0)
     a88:	f5 01       	movw	r30, r10
     a8a:	81 81       	ldd	r24, Z+1	; 0x01
     a8c:	81 11       	cpse	r24, r1
     a8e:	a6 cf       	rjmp	.-180    	; 0x9dc <vLcdHandler+0xb6>
				// näytön pohjateksti
				lcd_putc(*pChDisplay); // merkki näkyviin

				pChDisplay++; // seuraava kirjain
			}
			xSemaphoreGive( xDisplaySemaphore); // Vapautetaan semaphori
     a90:	60 e0       	ldi	r22, 0x00	; 0
     a92:	70 e0       	ldi	r23, 0x00	; 0
     a94:	80 91 87 03 	lds	r24, 0x0387	; 0x800387 <xDisplaySemaphore>
     a98:	90 91 88 03 	lds	r25, 0x0388	; 0x800388 <xDisplaySemaphore+0x1>
     a9c:	0e 94 ec 0e 	call	0x1dd8	; 0x1dd8 <xQueueGive>
			case IDM_UPDATE_DISPLAY:
			xSemaphoreTake( xDisplaySemaphore, portMAX_DELAY ); // ei tarpeen, koska portissa B ei muita laitteita
			if( message.data == 0 )
			pChDisplay = pDisplay[0];
			
			*pDisplay = "Update=%i03 C  \nDisplay=%i02";
     aa0:	53 01       	movw	r10, r6
				lcd_putc(*pChDisplay); // merkki näkyviin

				pChDisplay++; // seuraava kirjain
			}
			xSemaphoreGive( xDisplaySemaphore); // Vapautetaan semaphori
			break;
     aa2:	69 cf       	rjmp	.-302    	; 0x976 <vLcdHandler+0x50>
			
			case IDM_DISPLAY_HISTORY:
			xSemaphoreTake( xDisplaySemaphore, portMAX_DELAY ); // ei tarpeen, koska portissa B ei muita laitteita
     aa4:	20 e0       	ldi	r18, 0x00	; 0
     aa6:	4f ef       	ldi	r20, 0xFF	; 255
     aa8:	5f ef       	ldi	r21, 0xFF	; 255
     aaa:	60 e0       	ldi	r22, 0x00	; 0
     aac:	70 e0       	ldi	r23, 0x00	; 0
     aae:	80 91 87 03 	lds	r24, 0x0387	; 0x800387 <xDisplaySemaphore>
     ab2:	90 91 88 03 	lds	r25, 0x0388	; 0x800388 <xDisplaySemaphore+0x1>
     ab6:	0e 94 84 10 	call	0x2108	; 0x2108 <xQueueGenericReceive>
			if( message.data == 0 )
     aba:	80 91 72 03 	lds	r24, 0x0372	; 0x800372 <message.3035+0x1>
     abe:	81 11       	cpse	r24, r1
			pChDisplay = pDisplay[0];
     ac0:	01 c0       	rjmp	.+2      	; 0xac4 <vLcdHandler+0x19e>
			*pDisplay = "Display=%i03 C  \nHistory=%i02";
			
			// ja vain tämä taski käyttää lcd:tä
			lcd_gotoxy(0,0); // lcd-näytön alkuun
     ac2:	85 01       	movw	r16, r10
     ac4:	60 e0       	ldi	r22, 0x00	; 0
     ac6:	80 e0       	ldi	r24, 0x00	; 0
     ac8:	0c d2       	rcall	.+1048   	; 0xee2 <lcd_gotoxy>
			// tulostetaan näyttö tässä silmukassa
			while(*pChDisplay != 0)
     aca:	d8 01       	movw	r26, r16
     acc:	8c 91       	ld	r24, X
     ace:	88 23       	and	r24, r24
     ad0:	09 f4       	brne	.+2      	; 0xad4 <vLcdHandler+0x1ae>
     ad2:	5a c0       	rjmp	.+180    	; 0xb88 <vLcdHandler+0x262>
			{
				// onko muuttujan tulostuspaikka?
				if( *pChDisplay == '%')
     ad4:	f8 01       	movw	r30, r16
     ad6:	80 81       	ld	r24, Z
     ad8:	85 32       	cpi	r24, 0x25	; 37
     ada:	09 f0       	breq	.+2      	; 0xade <vLcdHandler+0x1b8>
     adc:	42 c0       	rjmp	.+132    	; 0xb62 <vLcdHandler+0x23c>
				{
					pChDisplay++; //ohitetaan %-merkki
					// minkä tyypin dataa?
					switch(*pChDisplay)
     ade:	81 81       	ldd	r24, Z+1	; 0x01
     ae0:	89 36       	cpi	r24, 0x69	; 105
     ae2:	29 f0       	breq	.+10     	; 0xaee <vLcdHandler+0x1c8>
			while(*pChDisplay != 0)
			{
				// onko muuttujan tulostuspaikka?
				if( *pChDisplay == '%')
				{
					pChDisplay++; //ohitetaan %-merkki
     ae4:	58 01       	movw	r10, r16
     ae6:	ff ef       	ldi	r31, 0xFF	; 255
     ae8:	af 1a       	sub	r10, r31
     aea:	bf 0a       	sbc	r11, r31
     aec:	2b c0       	rjmp	.+86     	; 0xb44 <vLcdHandler+0x21e>
					{
						// int-tyypin kokonaislukuja
						// muuttujan arvo poimitaan ints-taulukosta indeksin määräämästä paikasta
						case 'i': pChDisplay++;
						// indeksi annettu muodossa 09, 10,11,..
						i = (*pChDisplay - '0')*10;
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	90 e0       	ldi	r25, 0x00	; 0
     af2:	c0 97       	sbiw	r24, 0x30	; 48
     af4:	fc 01       	movw	r30, r24
     af6:	ee 0f       	add	r30, r30
     af8:	ff 1f       	adc	r31, r31
     afa:	88 0f       	add	r24, r24
     afc:	99 1f       	adc	r25, r25
     afe:	88 0f       	add	r24, r24
     b00:	99 1f       	adc	r25, r25
     b02:	88 0f       	add	r24, r24
     b04:	99 1f       	adc	r25, r25
     b06:	e8 0f       	add	r30, r24
     b08:	f9 1f       	adc	r31, r25
						pChDisplay++;
     b0a:	58 01       	movw	r10, r16
     b0c:	b3 e0       	ldi	r27, 0x03	; 3
     b0e:	ab 0e       	add	r10, r27
     b10:	b1 1c       	adc	r11, r1
						i +=  (*pChDisplay- '0'); // indeksi ints-taulukkoon
     b12:	d8 01       	movw	r26, r16
     b14:	13 96       	adiw	r26, 0x03	; 3
     b16:	8c 91       	ld	r24, X
						taskENTER_CRITICAL(); //////////////////////////////////
     b18:	0f b6       	in	r0, 0x3f	; 63
     b1a:	f8 94       	cli
     b1c:	0f 92       	push	r0
						itoa(ints[i],szVariable,10);                        ////
     b1e:	e8 0f       	add	r30, r24
     b20:	f1 1d       	adc	r31, r1
     b22:	ee 0f       	add	r30, r30
     b24:	ff 1f       	adc	r31, r31
     b26:	e3 5d       	subi	r30, 0xD3	; 211
     b28:	fc 4f       	sbci	r31, 0xFC	; 252
     b2a:	4a e0       	ldi	r20, 0x0A	; 10
     b2c:	be 01       	movw	r22, r28
     b2e:	6f 5f       	subi	r22, 0xFF	; 255
     b30:	7f 4f       	sbci	r23, 0xFF	; 255
     b32:	80 81       	ld	r24, Z
     b34:	91 81       	ldd	r25, Z+1	; 0x01
     b36:	0e 94 35 20 	call	0x406a	; 0x406a <__itoa_ncheck>
						taskEXIT_CRITICAL();  //////////////////////////////////
     b3a:	0f 90       	pop	r0
     b3c:	0f be       	out	0x3f, r0	; 63
						szVariable[3] = szVariable[2];
     b3e:	8b 81       	ldd	r24, Y+3	; 0x03
     b40:	8c 83       	std	Y+4, r24	; 0x04
						szVariable[2] = ',';
     b42:	9b 82       	std	Y+3, r9	; 0x03
						break;
					}
					// tulostetaan muuttuja
					pChVariable = szVariable;
					while(*pChVariable != 0)
     b44:	89 81       	ldd	r24, Y+1	; 0x01
     b46:	88 23       	and	r24, r24
     b48:	c1 f0       	breq	.+48     	; 0xb7a <vLcdHandler+0x254>
     b4a:	8e 01       	movw	r16, r28
     b4c:	0f 5f       	subi	r16, 0xFF	; 255
					{
						lcd_putc(*pChVariable); // merkki näkyviin
     b4e:	1f 4f       	sbci	r17, 0xFF	; 255
     b50:	f8 01       	movw	r30, r16
     b52:	81 91       	ld	r24, Z+
     b54:	8f 01       	movw	r16, r30
     b56:	e2 d1       	rcall	.+964    	; 0xf1c <lcd_putc>
						szVariable[2] = ',';
						break;
					}
					// tulostetaan muuttuja
					pChVariable = szVariable;
					while(*pChVariable != 0)
     b58:	d8 01       	movw	r26, r16
     b5a:	8c 91       	ld	r24, X
     b5c:	81 11       	cpse	r24, r1
     b5e:	f8 cf       	rjmp	.-16     	; 0xb50 <vLcdHandler+0x22a>
     b60:	0c c0       	rjmp	.+24     	; 0xb7a <vLcdHandler+0x254>
					{
						lcd_putc(*pChVariable); // merkki näkyviin
						pChVariable++; // seuraava kirjain
					}
				}
				else if(*pChDisplay == '\n')
     b62:	f8 01       	movw	r30, r16
     b64:	80 81       	ld	r24, Z
     b66:	8a 30       	cpi	r24, 0x0A	; 10
				{
					lcd_gotoxy(0,1);
     b68:	29 f4       	brne	.+10     	; 0xb74 <vLcdHandler+0x24e>
     b6a:	61 e0       	ldi	r22, 0x01	; 1
     b6c:	80 e0       	ldi	r24, 0x00	; 0
     b6e:	b9 d1       	rcall	.+882    	; 0xee2 <lcd_gotoxy>
     b70:	58 01       	movw	r10, r16
				}
				else
				// näytön pohjateksti
				lcd_putc(*pChDisplay); // merkki näkyviin
     b72:	03 c0       	rjmp	.+6      	; 0xb7a <vLcdHandler+0x254>
     b74:	80 81       	ld	r24, Z
     b76:	d2 d1       	rcall	.+932    	; 0xf1c <lcd_putc>
     b78:	58 01       	movw	r10, r16

				pChDisplay++; // seuraava kirjain
     b7a:	85 01       	movw	r16, r10
     b7c:	0f 5f       	subi	r16, 0xFF	; 255
     b7e:	1f 4f       	sbci	r17, 0xFF	; 255
			*pDisplay = "Display=%i03 C  \nHistory=%i02";
			
			// ja vain tämä taski käyttää lcd:tä
			lcd_gotoxy(0,0); // lcd-näytön alkuun
			// tulostetaan näyttö tässä silmukassa
			while(*pChDisplay != 0)
     b80:	f5 01       	movw	r30, r10
     b82:	81 81       	ldd	r24, Z+1	; 0x01
     b84:	81 11       	cpse	r24, r1
     b86:	a6 cf       	rjmp	.-180    	; 0xad4 <vLcdHandler+0x1ae>
				// näytön pohjateksti
				lcd_putc(*pChDisplay); // merkki näkyviin

				pChDisplay++; // seuraava kirjain
			}
			xSemaphoreGive( xDisplaySemaphore); // Vapautetaan semaphori
     b88:	60 e0       	ldi	r22, 0x00	; 0
     b8a:	70 e0       	ldi	r23, 0x00	; 0
     b8c:	80 91 87 03 	lds	r24, 0x0387	; 0x800387 <xDisplaySemaphore>
     b90:	90 91 88 03 	lds	r25, 0x0388	; 0x800388 <xDisplaySemaphore+0x1>
     b94:	0e 94 ec 0e 	call	0x1dd8	; 0x1dd8 <xQueueGive>
			
			case IDM_DISPLAY_HISTORY:
			xSemaphoreTake( xDisplaySemaphore, portMAX_DELAY ); // ei tarpeen, koska portissa B ei muita laitteita
			if( message.data == 0 )
			pChDisplay = pDisplay[0];
			*pDisplay = "Display=%i03 C  \nHistory=%i02";
     b98:	57 01       	movw	r10, r14
				lcd_putc(*pChDisplay); // merkki näkyviin

				pChDisplay++; // seuraava kirjain
			}
			xSemaphoreGive( xDisplaySemaphore); // Vapautetaan semaphori
			break;
     b9a:	ed ce       	rjmp	.-550    	; 0x976 <vLcdHandler+0x50>
			
			case IDM_DISPLAY_MINMAX:
			xSemaphoreTake( xDisplaySemaphore, portMAX_DELAY ); 
     b9c:	20 e0       	ldi	r18, 0x00	; 0
     b9e:	4f ef       	ldi	r20, 0xFF	; 255
     ba0:	5f ef       	ldi	r21, 0xFF	; 255
     ba2:	60 e0       	ldi	r22, 0x00	; 0
     ba4:	70 e0       	ldi	r23, 0x00	; 0
     ba6:	80 91 87 03 	lds	r24, 0x0387	; 0x800387 <xDisplaySemaphore>
     baa:	90 91 88 03 	lds	r25, 0x0388	; 0x800388 <xDisplaySemaphore+0x1>
     bae:	0e 94 84 10 	call	0x2108	; 0x2108 <xQueueGenericReceive>
			if( message.data == 0 )
     bb2:	80 91 72 03 	lds	r24, 0x0372	; 0x800372 <message.3035+0x1>
     bb6:	81 11       	cpse	r24, r1
			pChDisplay = pDisplay[0];
     bb8:	01 c0       	rjmp	.+2      	; 0xbbc <vLcdHandler+0x296>
			*pDisplay = "Display=%i03 C  \nMinMax=%i02";
						
			// ja vain tämä taski käyttää lcd:tä
			lcd_gotoxy(0,0); // lcd-näytön alkuun
     bba:	85 01       	movw	r16, r10
     bbc:	60 e0       	ldi	r22, 0x00	; 0
     bbe:	80 e0       	ldi	r24, 0x00	; 0
     bc0:	90 d1       	rcall	.+800    	; 0xee2 <lcd_gotoxy>
			// tulostetaan näyttö tässä silmukassa
			while(*pChDisplay != 0)
     bc2:	d8 01       	movw	r26, r16
     bc4:	8c 91       	ld	r24, X
     bc6:	88 23       	and	r24, r24
     bc8:	09 f4       	brne	.+2      	; 0xbcc <vLcdHandler+0x2a6>
     bca:	5a c0       	rjmp	.+180    	; 0xc80 <vLcdHandler+0x35a>
			{
				// onko muuttujan tulostuspaikka?
				if( *pChDisplay == '%')
     bcc:	f8 01       	movw	r30, r16
     bce:	80 81       	ld	r24, Z
     bd0:	85 32       	cpi	r24, 0x25	; 37
     bd2:	09 f0       	breq	.+2      	; 0xbd6 <vLcdHandler+0x2b0>
     bd4:	42 c0       	rjmp	.+132    	; 0xc5a <vLcdHandler+0x334>
				{
					pChDisplay++; //ohitetaan %-merkki
					// minkä tyypin dataa?
					switch(*pChDisplay)
     bd6:	81 81       	ldd	r24, Z+1	; 0x01
     bd8:	89 36       	cpi	r24, 0x69	; 105
     bda:	29 f0       	breq	.+10     	; 0xbe6 <vLcdHandler+0x2c0>
			while(*pChDisplay != 0)
			{
				// onko muuttujan tulostuspaikka?
				if( *pChDisplay == '%')
				{
					pChDisplay++; //ohitetaan %-merkki
     bdc:	58 01       	movw	r10, r16
     bde:	ff ef       	ldi	r31, 0xFF	; 255
     be0:	af 1a       	sub	r10, r31
     be2:	bf 0a       	sbc	r11, r31
     be4:	2b c0       	rjmp	.+86     	; 0xc3c <vLcdHandler+0x316>
					{
						// int-tyypin kokonaislukuja
						// muuttujan arvo poimitaan ints-taulukosta indeksin määräämästä paikasta
						case 'i': pChDisplay++;
						// indeksi annettu muodossa 09, 10,11,..
						i = (*pChDisplay - '0')*10;
     be6:	82 81       	ldd	r24, Z+2	; 0x02
     be8:	90 e0       	ldi	r25, 0x00	; 0
     bea:	c0 97       	sbiw	r24, 0x30	; 48
     bec:	fc 01       	movw	r30, r24
     bee:	ee 0f       	add	r30, r30
     bf0:	ff 1f       	adc	r31, r31
     bf2:	88 0f       	add	r24, r24
     bf4:	99 1f       	adc	r25, r25
     bf6:	88 0f       	add	r24, r24
     bf8:	99 1f       	adc	r25, r25
     bfa:	88 0f       	add	r24, r24
     bfc:	99 1f       	adc	r25, r25
     bfe:	e8 0f       	add	r30, r24
     c00:	f9 1f       	adc	r31, r25
						pChDisplay++;
     c02:	58 01       	movw	r10, r16
     c04:	b3 e0       	ldi	r27, 0x03	; 3
     c06:	ab 0e       	add	r10, r27
     c08:	b1 1c       	adc	r11, r1
						i +=  (*pChDisplay- '0'); // indeksi ints-taulukkoon
     c0a:	d8 01       	movw	r26, r16
     c0c:	13 96       	adiw	r26, 0x03	; 3
     c0e:	8c 91       	ld	r24, X
						taskENTER_CRITICAL(); //////////////////////////////////
     c10:	0f b6       	in	r0, 0x3f	; 63
     c12:	f8 94       	cli
     c14:	0f 92       	push	r0
						itoa(ints[i],szVariable,10);                        ////
     c16:	e8 0f       	add	r30, r24
     c18:	f1 1d       	adc	r31, r1
     c1a:	ee 0f       	add	r30, r30
     c1c:	ff 1f       	adc	r31, r31
     c1e:	e3 5d       	subi	r30, 0xD3	; 211
     c20:	fc 4f       	sbci	r31, 0xFC	; 252
     c22:	4a e0       	ldi	r20, 0x0A	; 10
     c24:	be 01       	movw	r22, r28
     c26:	6f 5f       	subi	r22, 0xFF	; 255
     c28:	7f 4f       	sbci	r23, 0xFF	; 255
     c2a:	80 81       	ld	r24, Z
     c2c:	91 81       	ldd	r25, Z+1	; 0x01
     c2e:	0e 94 35 20 	call	0x406a	; 0x406a <__itoa_ncheck>
						taskEXIT_CRITICAL();  //////////////////////////////////
     c32:	0f 90       	pop	r0
     c34:	0f be       	out	0x3f, r0	; 63
						szVariable[3] = szVariable[2];
     c36:	8b 81       	ldd	r24, Y+3	; 0x03
     c38:	8c 83       	std	Y+4, r24	; 0x04
						szVariable[2] = ',';
     c3a:	9b 82       	std	Y+3, r9	; 0x03
						break;
					}
					// tulostetaan muuttuja
					pChVariable = szVariable;
					while(*pChVariable != 0)
     c3c:	89 81       	ldd	r24, Y+1	; 0x01
     c3e:	88 23       	and	r24, r24
     c40:	c1 f0       	breq	.+48     	; 0xc72 <vLcdHandler+0x34c>
     c42:	8e 01       	movw	r16, r28
     c44:	0f 5f       	subi	r16, 0xFF	; 255
					{
						lcd_putc(*pChVariable); // merkki näkyviin
     c46:	1f 4f       	sbci	r17, 0xFF	; 255
     c48:	f8 01       	movw	r30, r16
     c4a:	81 91       	ld	r24, Z+
     c4c:	8f 01       	movw	r16, r30
     c4e:	66 d1       	rcall	.+716    	; 0xf1c <lcd_putc>
						szVariable[2] = ',';
						break;
					}
					// tulostetaan muuttuja
					pChVariable = szVariable;
					while(*pChVariable != 0)
     c50:	d8 01       	movw	r26, r16
     c52:	8c 91       	ld	r24, X
     c54:	81 11       	cpse	r24, r1
     c56:	f8 cf       	rjmp	.-16     	; 0xc48 <vLcdHandler+0x322>
					{
						lcd_putc(*pChVariable); // merkki näkyviin
						pChVariable++; // seuraava kirjain
					}
				}
				else if(*pChDisplay == '\n')
     c58:	0c c0       	rjmp	.+24     	; 0xc72 <vLcdHandler+0x34c>
     c5a:	f8 01       	movw	r30, r16
     c5c:	80 81       	ld	r24, Z
				{
					lcd_gotoxy(0,1);
     c5e:	8a 30       	cpi	r24, 0x0A	; 10
     c60:	29 f4       	brne	.+10     	; 0xc6c <vLcdHandler+0x346>
     c62:	61 e0       	ldi	r22, 0x01	; 1
     c64:	80 e0       	ldi	r24, 0x00	; 0
     c66:	3d d1       	rcall	.+634    	; 0xee2 <lcd_gotoxy>
     c68:	58 01       	movw	r10, r16
				}
				else
				// näytön pohjateksti
				lcd_putc(*pChDisplay); // merkki näkyviin
     c6a:	03 c0       	rjmp	.+6      	; 0xc72 <vLcdHandler+0x34c>
     c6c:	80 81       	ld	r24, Z
     c6e:	56 d1       	rcall	.+684    	; 0xf1c <lcd_putc>
     c70:	58 01       	movw	r10, r16

				pChDisplay++; // seuraava kirjain
     c72:	85 01       	movw	r16, r10
     c74:	0f 5f       	subi	r16, 0xFF	; 255
     c76:	1f 4f       	sbci	r17, 0xFF	; 255
			*pDisplay = "Display=%i03 C  \nMinMax=%i02";
						
			// ja vain tämä taski käyttää lcd:tä
			lcd_gotoxy(0,0); // lcd-näytön alkuun
			// tulostetaan näyttö tässä silmukassa
			while(*pChDisplay != 0)
     c78:	f5 01       	movw	r30, r10
     c7a:	81 81       	ldd	r24, Z+1	; 0x01
     c7c:	81 11       	cpse	r24, r1
     c7e:	a6 cf       	rjmp	.-180    	; 0xbcc <vLcdHandler+0x2a6>
				// näytön pohjateksti
				lcd_putc(*pChDisplay); // merkki näkyviin

				pChDisplay++; // seuraava kirjain
			}
			xSemaphoreGive( xDisplaySemaphore); // Vapautetaan semaphori
     c80:	60 e0       	ldi	r22, 0x00	; 0
     c82:	70 e0       	ldi	r23, 0x00	; 0
     c84:	80 91 87 03 	lds	r24, 0x0387	; 0x800387 <xDisplaySemaphore>
     c88:	90 91 88 03 	lds	r25, 0x0388	; 0x800388 <xDisplaySemaphore+0x1>
     c8c:	0e 94 ec 0e 	call	0x1dd8	; 0x1dd8 <xQueueGive>
			
			case IDM_DISPLAY_MINMAX:
			xSemaphoreTake( xDisplaySemaphore, portMAX_DELAY ); 
			if( message.data == 0 )
			pChDisplay = pDisplay[0];
			*pDisplay = "Display=%i03 C  \nMinMax=%i02";
     c90:	56 01       	movw	r10, r12
			}
			xSemaphoreGive( xDisplaySemaphore); // Vapautetaan semaphori
			break;
			
			case IDM_DISPLAY_TIME:
			xSemaphoreTake( xDisplaySemaphore, portMAX_DELAY ); 
     c92:	71 ce       	rjmp	.-798    	; 0x976 <vLcdHandler+0x50>
     c94:	20 e0       	ldi	r18, 0x00	; 0
     c96:	4f ef       	ldi	r20, 0xFF	; 255
     c98:	5f ef       	ldi	r21, 0xFF	; 255
     c9a:	60 e0       	ldi	r22, 0x00	; 0
     c9c:	70 e0       	ldi	r23, 0x00	; 0
     c9e:	80 91 87 03 	lds	r24, 0x0387	; 0x800387 <xDisplaySemaphore>
     ca2:	90 91 88 03 	lds	r25, 0x0388	; 0x800388 <xDisplaySemaphore+0x1>
			//lcd_clrscr();
			ShowTime();
     ca6:	0e 94 84 10 	call	0x2108	; 0x2108 <xQueueGenericReceive>
			xSemaphoreGive( xDisplaySemaphore); // Vapautetaan semaphori
     caa:	e0 dd       	rcall	.-1088   	; 0x86c <ShowTime>
     cac:	60 e0       	ldi	r22, 0x00	; 0
     cae:	70 e0       	ldi	r23, 0x00	; 0
     cb0:	80 91 87 03 	lds	r24, 0x0387	; 0x800387 <xDisplaySemaphore>
     cb4:	90 91 88 03 	lds	r25, 0x0388	; 0x800388 <xDisplaySemaphore+0x1>
     cb8:	0e 94 ec 0e 	call	0x1dd8	; 0x1dd8 <xQueueGive>
			break;
			
			default:
				lcd_putc('E');
     cbc:	5c ce       	rjmp	.-840    	; 0x976 <vLcdHandler+0x50>
     cbe:	85 e4       	ldi	r24, 0x45	; 69
     cc0:	2d d1       	rcall	.+602    	; 0xf1c <lcd_putc>
				break; // virheviestit
     cc2:	59 ce       	rjmp	.-846    	; 0x976 <vLcdHandler+0x50>

00000cc4 <ReadADC>:
#include <avr\io.h>              // Most basic include files
#include "adc.h"
// oletus kellotaajuus 16 Mhz Atmega328P
int ReadADC(void)
{
     cc4:	cf 93       	push	r28
     cc6:	df 93       	push	r29
  char i;
  int  lukema;

  int  tulos = 0;

  ADCSRA |= 1 << ADEN; // laite plle
     cc8:	ea e7       	ldi	r30, 0x7A	; 122
     cca:	f0 e0       	ldi	r31, 0x00	; 0
     ccc:	80 81       	ld	r24, Z
     cce:	80 68       	ori	r24, 0x80	; 128
     cd0:	80 83       	st	Z, r24

  //pitkkestoinen lukema pois
  ADCSRA |= (1<<ADSC); //
     cd2:	80 81       	ld	r24, Z
     cd4:	80 64       	ori	r24, 0x40	; 64
     cd6:	80 83       	st	Z, r24
  while(!(ADCSRA & (1 << ADIF))); // ADIF tulee plle lopuksi
     cd8:	80 81       	ld	r24, Z
     cda:	84 ff       	sbrs	r24, 4
     cdc:	fd cf       	rjmp	.-6      	; 0xcd8 <ReadADC+0x14>
     cde:	48 e0       	ldi	r20, 0x08	; 8
     ce0:	60 e0       	ldi	r22, 0x00	; 0
     ce2:	70 e0       	ldi	r23, 0x00	; 0

  // do the ADC conversion 8 times for better accuracy
  for(i=0;i<8;i++)
  {
    ADCSRA |= (1<<ADSC); // aloita muunnos
     ce4:	ea e7       	ldi	r30, 0x7A	; 122
     ce6:	f0 e0       	ldi	r31, 0x00	; 0
    while(!(ADCSRA & (1 << ADIF))); // ADIF tulee plle lopuksi

    lukema = ADCL;         // alaosa luetaan ensiksi
     ce8:	c8 e7       	ldi	r28, 0x78	; 120
     cea:	d0 e0       	ldi	r29, 0x00	; 0
    lukema += (ADCH << 8); // ylosan luenta
     cec:	a9 e7       	ldi	r26, 0x79	; 121
     cee:	b0 e0       	ldi	r27, 0x00	; 0
  while(!(ADCSRA & (1 << ADIF))); // ADIF tulee plle lopuksi

  // do the ADC conversion 8 times for better accuracy
  for(i=0;i<8;i++)
  {
    ADCSRA |= (1<<ADSC); // aloita muunnos
     cf0:	90 81       	ld	r25, Z
     cf2:	90 64       	ori	r25, 0x40	; 64
     cf4:	90 83       	st	Z, r25
    while(!(ADCSRA & (1 << ADIF))); // ADIF tulee plle lopuksi
     cf6:	90 81       	ld	r25, Z
     cf8:	94 ff       	sbrs	r25, 4
     cfa:	fd cf       	rjmp	.-6      	; 0xcf6 <ReadADC+0x32>

    lukema = ADCL;         // alaosa luetaan ensiksi
     cfc:	88 81       	ld	r24, Y
    lukema += (ADCH << 8); // ylosan luenta
     cfe:	2c 91       	ld	r18, X

    // otetaan 8 lukemaa summaksi
    tulos += lukema;
     d00:	30 e0       	ldi	r19, 0x00	; 0
     d02:	32 2f       	mov	r19, r18
     d04:	22 27       	eor	r18, r18
     d06:	28 0f       	add	r18, r24
     d08:	31 1d       	adc	r19, r1
     d0a:	62 0f       	add	r22, r18
     d0c:	73 1f       	adc	r23, r19
     d0e:	41 50       	subi	r20, 0x01	; 1
  //pitkkestoinen lukema pois
  ADCSRA |= (1<<ADSC); //
  while(!(ADCSRA & (1 << ADIF))); // ADIF tulee plle lopuksi

  // do the ADC conversion 8 times for better accuracy
  for(i=0;i<8;i++)
     d10:	79 f7       	brne	.-34     	; 0xcf0 <ReadADC+0x2c>
    tulos += lukema;
  }

  tulos = tulos >> 3; // lukemien keskiarvo

  ADCSRA &= ~(1<<ADEN); // AD-muunnin pois plt
     d12:	ea e7       	ldi	r30, 0x7A	; 122
     d14:	f0 e0       	ldi	r31, 0x00	; 0
     d16:	80 81       	ld	r24, Z
     d18:	8f 77       	andi	r24, 0x7F	; 127
     d1a:	80 83       	st	Z, r24
  return tulos;
}
     d1c:	cb 01       	movw	r24, r22
     d1e:	95 95       	asr	r25
     d20:	87 95       	ror	r24
     d22:	95 95       	asr	r25
     d24:	87 95       	ror	r24
     d26:	95 95       	asr	r25
     d28:	87 95       	ror	r24
     d2a:	df 91       	pop	r29
     d2c:	cf 91       	pop	r28
     d2e:	08 95       	ret

00000d30 <InitADC>:

void InitADC(char portti)
{
  // sisinen referenssijnnite + kanavan valinta
  //ADMUX = (1 << REFS1) | (1 << REFS0) | portti;
  ADMUX =  (1 << REFS0) | portti;
     d30:	80 64       	ori	r24, 0x40	; 64
     d32:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x70007c>

  // laite plle + kellotaajuudeksi 16MHz / 128 = 125kHz
  ADCSRA = (1<<ADEN) | (1<<ADPS0) | (1<<ADPS1) | (1<<ADPS2);
     d36:	87 e8       	ldi	r24, 0x87	; 135
     d38:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>

  ReadADC(); // nollataan muunnin lukemalla kertaalleen
     d3c:	c3 cf       	rjmp	.-122    	; 0xcc4 <ReadADC>
     d3e:	08 95       	ret

00000d40 <GetKey>:
#include "device.h"

unsigned char GetKey(void)
{
     d40:	0f 93       	push	r16
     d42:	1f 93       	push	r17
     d44:	cf 93       	push	r28
     d46:	df 93       	push	r29

  int nValue;

  InitADC(0);
     d48:	80 e0       	ldi	r24, 0x00	; 0
     d4a:	f2 df       	rcall	.-28     	; 0xd30 <InitADC>

  nValue = ReadADC();
     d4c:	bb df       	rcall	.-138    	; 0xcc4 <ReadADC>
     d4e:	85 38       	cpi	r24, 0x85	; 133
  
  // jos mikn nppin ei ole alhaalla
  // saadaan 1023, mutta siirtymvaiheessa
  // saattaa tulla hieman pienempi arvoja
  // tulkitaan nekin ei nppiksi
  if (nValue > 900)
     d50:	93 40       	sbci	r25, 0x03	; 3
     d52:	0c f5       	brge	.+66     	; 0xd96 <GetKey+0x56>
     d54:	ca e0       	ldi	r28, 0x0A	; 10
     d56:	d0 e0       	ldi	r29, 0x00	; 0
     d58:	00 e0       	ldi	r16, 0x00	; 0
     d5a:	10 e0       	ldi	r17, 0x00	; 0
  
  // luetaan 10 kertaa ja kytetn keskiarvoa
  // transienttilukemien eliminoimiseksi
  nValue = 0;
  for(int i=0; i < 10; i++)
   nValue += ReadADC();
     d5c:	b3 df       	rcall	.-154    	; 0xcc4 <ReadADC>
     d5e:	08 0f       	add	r16, r24
     d60:	19 1f       	adc	r17, r25
     d62:	21 97       	sbiw	r28, 0x01	; 1
     d64:	d9 f7       	brne	.-10     	; 0xd5c <GetKey+0x1c>
     return NO_KEY;  
  
  // luetaan 10 kertaa ja kytetn keskiarvoa
  // transienttilukemien eliminoimiseksi
  nValue = 0;
  for(int i=0; i < 10; i++)
     d66:	c8 01       	movw	r24, r16
   nValue += ReadADC();
  nValue /= 10; // keskiarvo
     d68:	6a e0       	ldi	r22, 0x0A	; 10
     d6a:	70 e0       	ldi	r23, 0x00	; 0
     d6c:	0e 94 bd 1f 	call	0x3f7a	; 0x3f7a <__divmodhi4>
     d70:	62 33       	cpi	r22, 0x32	; 50

  // tunnistetaan
  if (nValue < 50)
     d72:	71 05       	cpc	r23, r1
     d74:	94 f0       	brlt	.+36     	; 0xd9a <GetKey+0x5a>
     d76:	66 3e       	cpi	r22, 0xE6	; 230
	  return IDK_RIGHT;
  else if (nValue < 230)
     d78:	71 05       	cpc	r23, r1
     d7a:	8c f0       	brlt	.+34     	; 0xd9e <GetKey+0x5e>
     d7c:	62 3c       	cpi	r22, 0xC2	; 194
	  return IDK_UP;
  else if (nValue < 450)
     d7e:	81 e0       	ldi	r24, 0x01	; 1
     d80:	78 07       	cpc	r23, r24
     d82:	7c f0       	brlt	.+30     	; 0xda2 <GetKey+0x62>
     d84:	6a 38       	cpi	r22, 0x8A	; 138
	  return IDK_DOWN;
  else if (nValue < 650)
     d86:	22 e0       	ldi	r18, 0x02	; 2
     d88:	72 07       	cpc	r23, r18
     d8a:	6c f0       	brlt	.+26     	; 0xda6 <GetKey+0x66>
     d8c:	64 38       	cpi	r22, 0x84	; 132
	  return IDK_LEFT;
  else if (nValue < 900)
     d8e:	73 40       	sbci	r23, 0x03	; 3
     d90:	64 f0       	brlt	.+24     	; 0xdaa <GetKey+0x6a>
     d92:	83 e6       	ldi	r24, 0x63	; 99
	  return IDK_SELECT;
  else return NO_KEY; // ei yhtn alhaalla
     d94:	0b c0       	rjmp	.+22     	; 0xdac <GetKey+0x6c>
     d96:	83 e6       	ldi	r24, 0x63	; 99
  // jos mikn nppin ei ole alhaalla
  // saadaan 1023, mutta siirtymvaiheessa
  // saattaa tulla hieman pienempi arvoja
  // tulkitaan nekin ei nppiksi
  if (nValue > 900)
     return NO_KEY;  
     d98:	09 c0       	rjmp	.+18     	; 0xdac <GetKey+0x6c>
     d9a:	81 e0       	ldi	r24, 0x01	; 1
   nValue += ReadADC();
  nValue /= 10; // keskiarvo

  // tunnistetaan
  if (nValue < 50)
	  return IDK_RIGHT;
     d9c:	07 c0       	rjmp	.+14     	; 0xdac <GetKey+0x6c>
     d9e:	82 e0       	ldi	r24, 0x02	; 2
  else if (nValue < 230)
	  return IDK_UP;
     da0:	05 c0       	rjmp	.+10     	; 0xdac <GetKey+0x6c>
     da2:	83 e0       	ldi	r24, 0x03	; 3
  else if (nValue < 450)
	  return IDK_DOWN;
     da4:	03 c0       	rjmp	.+6      	; 0xdac <GetKey+0x6c>
     da6:	84 e0       	ldi	r24, 0x04	; 4
  else if (nValue < 650)
	  return IDK_LEFT;
     da8:	01 c0       	rjmp	.+2      	; 0xdac <GetKey+0x6c>
     daa:	85 e0       	ldi	r24, 0x05	; 5
  else if (nValue < 900)
	  return IDK_SELECT;
     dac:	df 91       	pop	r29
  else return NO_KEY; // ei yhtn alhaalla
}
     dae:	cf 91       	pop	r28
     db0:	1f 91       	pop	r17
     db2:	0f 91       	pop	r16
     db4:	08 95       	ret

00000db6 <lcd_write>:
     db6:	66 23       	and	r22, r22
    register char c;

    while ( (c = pgm_read_byte(progmem_s++)) )
        lcd_putc(c);

}
     db8:	31 f0       	breq	.+12     	; 0xdc6 <lcd_write+0x10>
     dba:	e2 e0       	ldi	r30, 0x02	; 2
     dbc:	f1 e0       	ldi	r31, 0x01	; 1
     dbe:	90 81       	ld	r25, Z
     dc0:	90 62       	ori	r25, 0x20	; 32
     dc2:	90 83       	st	Z, r25
     dc4:	05 c0       	rjmp	.+10     	; 0xdd0 <lcd_write+0x1a>
     dc6:	e2 e0       	ldi	r30, 0x02	; 2
     dc8:	f1 e0       	ldi	r31, 0x01	; 1
     dca:	90 81       	ld	r25, Z
     dcc:	9f 7d       	andi	r25, 0xDF	; 223
     dce:	90 83       	st	Z, r25
     dd0:	41 11       	cpse	r20, r1
     dd2:	3d c0       	rjmp	.+122    	; 0xe4e <lcd_write+0x98>
     dd4:	88 23       	and	r24, r24
     dd6:	34 f4       	brge	.+12     	; 0xde4 <lcd_write+0x2e>
     dd8:	e2 e0       	ldi	r30, 0x02	; 2
     dda:	f1 e0       	ldi	r31, 0x01	; 1
     ddc:	90 81       	ld	r25, Z
     dde:	90 61       	ori	r25, 0x10	; 16
     de0:	90 83       	st	Z, r25
     de2:	05 c0       	rjmp	.+10     	; 0xdee <lcd_write+0x38>
     de4:	e2 e0       	ldi	r30, 0x02	; 2
     de6:	f1 e0       	ldi	r31, 0x01	; 1
     de8:	90 81       	ld	r25, Z
     dea:	9f 7e       	andi	r25, 0xEF	; 239
     dec:	90 83       	st	Z, r25
     dee:	86 ff       	sbrs	r24, 6
     df0:	06 c0       	rjmp	.+12     	; 0xdfe <lcd_write+0x48>
     df2:	e2 e0       	ldi	r30, 0x02	; 2
     df4:	f1 e0       	ldi	r31, 0x01	; 1
     df6:	90 81       	ld	r25, Z
     df8:	98 60       	ori	r25, 0x08	; 8
     dfa:	90 83       	st	Z, r25
     dfc:	05 c0       	rjmp	.+10     	; 0xe08 <lcd_write+0x52>
     dfe:	e2 e0       	ldi	r30, 0x02	; 2
     e00:	f1 e0       	ldi	r31, 0x01	; 1
     e02:	90 81       	ld	r25, Z
     e04:	97 7f       	andi	r25, 0xF7	; 247
     e06:	90 83       	st	Z, r25
     e08:	85 ff       	sbrs	r24, 5
     e0a:	02 c0       	rjmp	.+4      	; 0xe10 <lcd_write+0x5a>
     e0c:	73 9a       	sbi	0x0e, 3	; 14
     e0e:	01 c0       	rjmp	.+2      	; 0xe12 <lcd_write+0x5c>
     e10:	73 98       	cbi	0x0e, 3	; 14
     e12:	84 ff       	sbrs	r24, 4
     e14:	02 c0       	rjmp	.+4      	; 0xe1a <lcd_write+0x64>
     e16:	a5 9a       	sbi	0x14, 5	; 20
     e18:	01 c0       	rjmp	.+2      	; 0xe1c <lcd_write+0x66>
     e1a:	a5 98       	cbi	0x14, 5	; 20
     e1c:	e2 e0       	ldi	r30, 0x02	; 2
     e1e:	f1 e0       	ldi	r31, 0x01	; 1
     e20:	90 81       	ld	r25, Z
     e22:	9f 7b       	andi	r25, 0xBF	; 191
     e24:	90 83       	st	Z, r25
     e26:	95 e0       	ldi	r25, 0x05	; 5
     e28:	9a 95       	dec	r25
     e2a:	f1 f7       	brne	.-4      	; 0xe28 <lcd_write+0x72>
     e2c:	00 00       	nop
     e2e:	90 81       	ld	r25, Z
     e30:	90 64       	ori	r25, 0x40	; 64
     e32:	90 83       	st	Z, r25
     e34:	95 e0       	ldi	r25, 0x05	; 5
     e36:	9a 95       	dec	r25
     e38:	f1 f7       	brne	.-4      	; 0xe36 <lcd_write+0x80>
     e3a:	00 00       	nop
     e3c:	90 81       	ld	r25, Z
     e3e:	9f 7b       	andi	r25, 0xBF	; 191
     e40:	90 83       	st	Z, r25
     e42:	ef e9       	ldi	r30, 0x9F	; 159
     e44:	ff e0       	ldi	r31, 0x0F	; 15
     e46:	31 97       	sbiw	r30, 0x01	; 1
     e48:	f1 f7       	brne	.-4      	; 0xe46 <lcd_write+0x90>
     e4a:	00 c0       	rjmp	.+0      	; 0xe4c <lcd_write+0x96>
     e4c:	00 00       	nop
     e4e:	83 ff       	sbrs	r24, 3
     e50:	06 c0       	rjmp	.+12     	; 0xe5e <lcd_write+0xa8>
     e52:	e2 e0       	ldi	r30, 0x02	; 2
     e54:	f1 e0       	ldi	r31, 0x01	; 1
     e56:	90 81       	ld	r25, Z
     e58:	90 61       	ori	r25, 0x10	; 16
     e5a:	90 83       	st	Z, r25
     e5c:	05 c0       	rjmp	.+10     	; 0xe68 <lcd_write+0xb2>
     e5e:	e2 e0       	ldi	r30, 0x02	; 2
     e60:	f1 e0       	ldi	r31, 0x01	; 1
     e62:	90 81       	ld	r25, Z
     e64:	9f 7e       	andi	r25, 0xEF	; 239
     e66:	90 83       	st	Z, r25
     e68:	82 ff       	sbrs	r24, 2
     e6a:	06 c0       	rjmp	.+12     	; 0xe78 <lcd_write+0xc2>
     e6c:	e2 e0       	ldi	r30, 0x02	; 2
     e6e:	f1 e0       	ldi	r31, 0x01	; 1
     e70:	90 81       	ld	r25, Z
     e72:	98 60       	ori	r25, 0x08	; 8
     e74:	90 83       	st	Z, r25
     e76:	05 c0       	rjmp	.+10     	; 0xe82 <lcd_write+0xcc>
     e78:	e2 e0       	ldi	r30, 0x02	; 2
     e7a:	f1 e0       	ldi	r31, 0x01	; 1
     e7c:	90 81       	ld	r25, Z
     e7e:	97 7f       	andi	r25, 0xF7	; 247
     e80:	90 83       	st	Z, r25
     e82:	81 ff       	sbrs	r24, 1
     e84:	02 c0       	rjmp	.+4      	; 0xe8a <lcd_write+0xd4>
     e86:	73 9a       	sbi	0x0e, 3	; 14
     e88:	01 c0       	rjmp	.+2      	; 0xe8c <lcd_write+0xd6>
     e8a:	73 98       	cbi	0x0e, 3	; 14
     e8c:	80 ff       	sbrs	r24, 0
     e8e:	02 c0       	rjmp	.+4      	; 0xe94 <lcd_write+0xde>
     e90:	a5 9a       	sbi	0x14, 5	; 20
     e92:	01 c0       	rjmp	.+2      	; 0xe96 <lcd_write+0xe0>
     e94:	a5 98       	cbi	0x14, 5	; 20
     e96:	e2 e0       	ldi	r30, 0x02	; 2
     e98:	f1 e0       	ldi	r31, 0x01	; 1
     e9a:	80 81       	ld	r24, Z
     e9c:	8f 7b       	andi	r24, 0xBF	; 191
     e9e:	80 83       	st	Z, r24
     ea0:	85 e0       	ldi	r24, 0x05	; 5
     ea2:	8a 95       	dec	r24
     ea4:	f1 f7       	brne	.-4      	; 0xea2 <lcd_write+0xec>
     ea6:	00 00       	nop
     ea8:	80 81       	ld	r24, Z
     eaa:	80 64       	ori	r24, 0x40	; 64
     eac:	80 83       	st	Z, r24
     eae:	95 e0       	ldi	r25, 0x05	; 5
     eb0:	9a 95       	dec	r25
     eb2:	f1 f7       	brne	.-4      	; 0xeb0 <lcd_write+0xfa>
     eb4:	00 00       	nop
     eb6:	80 81       	ld	r24, Z
     eb8:	8f 7b       	andi	r24, 0xBF	; 191
     eba:	80 83       	st	Z, r24
     ebc:	8f e9       	ldi	r24, 0x9F	; 159
     ebe:	9f e0       	ldi	r25, 0x0F	; 15
     ec0:	01 97       	sbiw	r24, 0x01	; 1
     ec2:	f1 f7       	brne	.-4      	; 0xec0 <lcd_write+0x10a>
     ec4:	00 c0       	rjmp	.+0      	; 0xec6 <lcd_write+0x110>
     ec6:	00 00       	nop
     ec8:	a5 9a       	sbi	0x14, 5	; 20
     eca:	73 9a       	sbi	0x0e, 3	; 14
     ecc:	80 81       	ld	r24, Z
     ece:	88 60       	ori	r24, 0x08	; 8
     ed0:	80 83       	st	Z, r24
     ed2:	80 81       	ld	r24, Z
     ed4:	80 61       	ori	r24, 0x10	; 16
     ed6:	80 83       	st	Z, r24
     ed8:	08 95       	ret

00000eda <lcd_command>:
     eda:	40 e0       	ldi	r20, 0x00	; 0
     edc:	60 e0       	ldi	r22, 0x00	; 0
     ede:	6b cf       	rjmp	.-298    	; 0xdb6 <lcd_write>
     ee0:	08 95       	ret

00000ee2 <lcd_gotoxy>:
     ee2:	cf 93       	push	r28
     ee4:	df 93       	push	r29
     ee6:	d8 2f       	mov	r29, r24
     ee8:	c6 2f       	mov	r28, r22
     eea:	82 e0       	ldi	r24, 0x02	; 2
     eec:	f6 df       	rcall	.-20     	; 0xeda <lcd_command>
     eee:	c1 30       	cpi	r28, 0x01	; 1
     ef0:	09 f4       	brne	.+2      	; 0xef4 <lcd_gotoxy+0x12>
     ef2:	d8 5d       	subi	r29, 0xD8	; 216
     ef4:	dd 23       	and	r29, r29
     ef6:	31 f0       	breq	.+12     	; 0xf04 <lcd_gotoxy+0x22>
     ef8:	c0 e0       	ldi	r28, 0x00	; 0
     efa:	84 e1       	ldi	r24, 0x14	; 20
     efc:	ee df       	rcall	.-36     	; 0xeda <lcd_command>
     efe:	cf 5f       	subi	r28, 0xFF	; 255
     f00:	dc 13       	cpse	r29, r28
     f02:	fb cf       	rjmp	.-10     	; 0xefa <lcd_gotoxy+0x18>
     f04:	df 91       	pop	r29
     f06:	cf 91       	pop	r28
     f08:	08 95       	ret

00000f0a <lcd_clrscr>:
     f0a:	81 e0       	ldi	r24, 0x01	; 1
     f0c:	e6 df       	rcall	.-52     	; 0xeda <lcd_command>
     f0e:	8f ed       	ldi	r24, 0xDF	; 223
     f10:	9e e2       	ldi	r25, 0x2E	; 46
     f12:	01 97       	sbiw	r24, 0x01	; 1
     f14:	f1 f7       	brne	.-4      	; 0xf12 <lcd_clrscr+0x8>
     f16:	00 c0       	rjmp	.+0      	; 0xf18 <lcd_clrscr+0xe>
     f18:	00 00       	nop
     f1a:	08 95       	ret

00000f1c <lcd_putc>:
     f1c:	40 e0       	ldi	r20, 0x00	; 0
     f1e:	61 e0       	ldi	r22, 0x01	; 1
     f20:	4a cf       	rjmp	.-364    	; 0xdb6 <lcd_write>
     f22:	08 95       	ret

00000f24 <lcd_puts>:
     f24:	cf 93       	push	r28
     f26:	df 93       	push	r29
     f28:	ec 01       	movw	r28, r24
     f2a:	21 96       	adiw	r28, 0x01	; 1
     f2c:	fc 01       	movw	r30, r24
     f2e:	80 81       	ld	r24, Z
     f30:	88 23       	and	r24, r24
     f32:	21 f0       	breq	.+8      	; 0xf3c <lcd_puts+0x18>
     f34:	f3 df       	rcall	.-26     	; 0xf1c <lcd_putc>
     f36:	89 91       	ld	r24, Y+
     f38:	81 11       	cpse	r24, r1
     f3a:	fc cf       	rjmp	.-8      	; 0xf34 <lcd_puts+0x10>
     f3c:	df 91       	pop	r29
     f3e:	cf 91       	pop	r28
     f40:	08 95       	ret

00000f42 <lcd_init>:
                   LCD_DISP_ON_CURSOR      display on, cursor on
                   LCD_DISP_CURSOR_BLINK   display on, cursor on flashing
Returns:  none
*************************************************************************/
void lcd_init(uint8_t dispAttr)
{
     f42:	cf 93       	push	r28
     f44:	c8 2f       	mov	r28, r24
   //
   //  Initialize LCD to 4 bit I/O mode
   //

    // configure all port bits as output
   DDR(LCD_RS_PORT)    |= _BV(LCD_RS_PIN);
     f46:	e1 e0       	ldi	r30, 0x01	; 1
     f48:	f1 e0       	ldi	r31, 0x01	; 1
     f4a:	80 81       	ld	r24, Z
     f4c:	80 62       	ori	r24, 0x20	; 32
     f4e:	80 83       	st	Z, r24
   //DDR(LCD_RW_PORT)    |= _BV(LCD_RW_PIN);
   DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
     f50:	80 81       	ld	r24, Z
     f52:	80 64       	ori	r24, 0x40	; 64
     f54:	80 83       	st	Z, r24
   DDR(LCD_DATA0_PORT) |= _BV(LCD_DATA0_PIN);
     f56:	9d 9a       	sbi	0x13, 5	; 19
   DDR(LCD_DATA1_PORT) |= _BV(LCD_DATA1_PIN);
     f58:	6b 9a       	sbi	0x0d, 3	; 13
   DDR(LCD_DATA2_PORT) |= _BV(LCD_DATA2_PIN);
     f5a:	80 81       	ld	r24, Z
     f5c:	88 60       	ori	r24, 0x08	; 8
     f5e:	80 83       	st	Z, r24
   DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
     f60:	80 81       	ld	r24, Z
     f62:	80 61       	ori	r24, 0x10	; 16
     f64:	80 83       	st	Z, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     f66:	2f ef       	ldi	r18, 0xFF	; 255
     f68:	8d ee       	ldi	r24, 0xED	; 237
     f6a:	92 e0       	ldi	r25, 0x02	; 2
     f6c:	21 50       	subi	r18, 0x01	; 1
     f6e:	80 40       	sbci	r24, 0x00	; 0
     f70:	90 40       	sbci	r25, 0x00	; 0
     f72:	e1 f7       	brne	.-8      	; 0xf6c <lcd_init+0x2a>
     f74:	00 c0       	rjmp	.+0      	; 0xf76 <lcd_init+0x34>
     f76:	00 00       	nop
   _delay_ms(60);     //  wait 50ms or more after power-on

   // reset the lcd circuit
 //  lcd_write(0x33, 0,0);
 //  _delay_ms(5);      // wait 5 ms
    lcd_rs_low();
     f78:	e2 e0       	ldi	r30, 0x02	; 2
     f7a:	f1 e0       	ldi	r31, 0x01	; 1
     f7c:	80 81       	ld	r24, Z
     f7e:	8f 7d       	andi	r24, 0xDF	; 223
     f80:	80 83       	st	Z, r24
    lcd_e_low();
     f82:	80 81       	ld	r24, Z
     f84:	8f 7b       	andi	r24, 0xBF	; 191
     f86:	80 83       	st	Z, r24


   // set the device to the 4-bit mode
   lcd_write(0x3, 0,1);
     f88:	41 e0       	ldi	r20, 0x01	; 1
     f8a:	60 e0       	ldi	r22, 0x00	; 0
     f8c:	83 e0       	ldi	r24, 0x03	; 3
     f8e:	13 df       	rcall	.-474    	; 0xdb6 <lcd_write>
     f90:	8f e1       	ldi	r24, 0x1F	; 31
     f92:	9e e4       	ldi	r25, 0x4E	; 78
     f94:	01 97       	sbiw	r24, 0x01	; 1
     f96:	f1 f7       	brne	.-4      	; 0xf94 <lcd_init+0x52>
     f98:	00 c0       	rjmp	.+0      	; 0xf9a <lcd_init+0x58>
     f9a:	00 00       	nop
   _delay_ms(5);      // wait 5 ms
   // set the device to the 4-bit mode
   lcd_write(0x3, 0,1);
     f9c:	41 e0       	ldi	r20, 0x01	; 1
     f9e:	60 e0       	ldi	r22, 0x00	; 0
     fa0:	83 e0       	ldi	r24, 0x03	; 3
     fa2:	09 df       	rcall	.-494    	; 0xdb6 <lcd_write>
     fa4:	8f e9       	ldi	r24, 0x9F	; 159
     fa6:	9f e0       	ldi	r25, 0x0F	; 15
     fa8:	01 97       	sbiw	r24, 0x01	; 1
     faa:	f1 f7       	brne	.-4      	; 0xfa8 <lcd_init+0x66>
     fac:	00 c0       	rjmp	.+0      	; 0xfae <lcd_init+0x6c>
     fae:	00 00       	nop
   _delay_ms(1);      // wait 1 ms
   // set the device to the 4-bit mode
   lcd_write(0x3, 0,1);
     fb0:	41 e0       	ldi	r20, 0x01	; 1
     fb2:	60 e0       	ldi	r22, 0x00	; 0
     fb4:	83 e0       	ldi	r24, 0x03	; 3
     fb6:	ff de       	rcall	.-514    	; 0xdb6 <lcd_write>
     fb8:	8f e9       	ldi	r24, 0x9F	; 159
     fba:	9f e0       	ldi	r25, 0x0F	; 15
     fbc:	01 97       	sbiw	r24, 0x01	; 1
     fbe:	f1 f7       	brne	.-4      	; 0xfbc <lcd_init+0x7a>
     fc0:	00 c0       	rjmp	.+0      	; 0xfc2 <lcd_init+0x80>
     fc2:	00 00       	nop
   _delay_ms(1);      // wait 5 ms
   // finally, set to 4-bit interface
   lcd_write(0x02,0,1);
     fc4:	41 e0       	ldi	r20, 0x01	; 1
     fc6:	60 e0       	ldi	r22, 0x00	; 0
     fc8:	82 e0       	ldi	r24, 0x02	; 2
     fca:	f5 de       	rcall	.-534    	; 0xdb6 <lcd_write>

   // set 2 lines and 5x7 dots /character mode
   // NFXX
   //   N = 1 2 lines  F = 1 5x10   F = 0 5x7
   lcd_write(0x28,0,0);
     fcc:	40 e0       	ldi	r20, 0x00	; 0
     fce:	60 e0       	ldi	r22, 0x00	; 0
     fd0:	88 e2       	ldi	r24, 0x28	; 40

   // from now the LCD only accepts 4 bit I/O, we can use lcd_command()
    lcd_clrscr();                     // display clear
     fd2:	f1 de       	rcall	.-542    	; 0xdb6 <lcd_write>
     fd4:	9a df       	rcall	.-204    	; 0xf0a <lcd_clrscr>
    lcd_command(LCD_MODE_DEFAULT);    // set entry mode
     fd6:	86 e0       	ldi	r24, 0x06	; 6
     fd8:	80 df       	rcall	.-256    	; 0xeda <lcd_command>
     fda:	8c 2f       	mov	r24, r28
	lcd_command(dispAttr);
     fdc:	7e df       	rcall	.-260    	; 0xeda <lcd_command>
     fde:	cf 91       	pop	r28
     fe0:	08 95       	ret

00000fe2 <crc8>:
	uint8_t  b;
	uint8_t  feedback_bit;
	
	crc = CRC8INIT;

	for (loop_count = 0; loop_count != number_of_bytes_in_data; loop_count++)
     fe2:	61 15       	cp	r22, r1
     fe4:	71 05       	cpc	r23, r1
     fe6:	a9 f0       	breq	.+42     	; 0x1012 <crc8+0x30>
     fe8:	fc 01       	movw	r30, r24
     fea:	68 0f       	add	r22, r24
     fec:	79 1f       	adc	r23, r25
     fee:	80 e0       	ldi	r24, 0x00	; 0
		bit_counter = 8;
		do {
			feedback_bit = (crc ^ b) & 0x01;
	
			if ( feedback_bit == 0x01 ) {
				crc = crc ^ CRC8POLY;
     ff0:	48 e1       	ldi	r20, 0x18	; 24
	
	crc = CRC8INIT;

	for (loop_count = 0; loop_count != number_of_bytes_in_data; loop_count++)
	{
		b = data[loop_count];
     ff2:	21 91       	ld	r18, Z+
     ff4:	98 e0       	ldi	r25, 0x08	; 8
		
		bit_counter = 8;
		do {
			feedback_bit = (crc ^ b) & 0x01;
	
			if ( feedback_bit == 0x01 ) {
     ff6:	38 2f       	mov	r19, r24
     ff8:	32 27       	eor	r19, r18
     ffa:	30 ff       	sbrs	r19, 0
     ffc:	0c c0       	rjmp	.+24     	; 0x1016 <crc8+0x34>
				crc = crc ^ CRC8POLY;
     ffe:	84 27       	eor	r24, r20
			}
			crc = (crc >> 1) & 0x7F;
    1000:	86 95       	lsr	r24
			if ( feedback_bit == 0x01 ) {
				crc = crc | 0x80;
    1002:	80 68       	ori	r24, 0x80	; 128
			}
		
			b = b >> 1;
    1004:	26 95       	lsr	r18
    1006:	91 50       	subi	r25, 0x01	; 1
			bit_counter--;
		
		} while (bit_counter > 0);
    1008:	b1 f7       	brne	.-20     	; 0xff6 <crc8+0x14>
	uint8_t  b;
	uint8_t  feedback_bit;
	
	crc = CRC8INIT;

	for (loop_count = 0; loop_count != number_of_bytes_in_data; loop_count++)
    100a:	e6 17       	cp	r30, r22
    100c:	f7 07       	cpc	r31, r23
    100e:	89 f7       	brne	.-30     	; 0xff2 <crc8+0x10>
    1010:	08 95       	ret
	uint16_t loop_count;
	uint8_t  bit_counter;
	uint8_t  b;
	uint8_t  feedback_bit;
	
	crc = CRC8INIT;
    1012:	80 e0       	ldi	r24, 0x00	; 0
			bit_counter--;
		
		} while (bit_counter > 0);
	}
	
	return crc;
    1014:	08 95       	ret
			feedback_bit = (crc ^ b) & 0x01;
	
			if ( feedback_bit == 0x01 ) {
				crc = crc ^ CRC8POLY;
			}
			crc = (crc >> 1) & 0x7F;
    1016:	86 95       	lsr	r24
    1018:	f5 cf       	rjmp	.-22     	; 0x1004 <crc8+0x22>

0000101a <read_scratchpad>:
//********************************************************//

uint8_t DS18X20_conversion_in_progress(void)
{
	return ow_bit_io( 1 ) ? DS18X20_CONVERSION_DONE : DS18X20_CONVERTING;
}
    101a:	ef 92       	push	r14
    101c:	ff 92       	push	r15
    101e:	0f 93       	push	r16
    1020:	1f 93       	push	r17
    1022:	cf 93       	push	r28
    1024:	df 93       	push	r29
    1026:	7b 01       	movw	r14, r22
    1028:	04 2f       	mov	r16, r20
    102a:	bc 01       	movw	r22, r24
    102c:	8e eb       	ldi	r24, 0xBE	; 190
    102e:	dd d1       	rcall	.+954    	; 0x13ea <ow_command>
    1030:	00 23       	and	r16, r16
    1032:	61 f0       	breq	.+24     	; 0x104c <read_scratchpad+0x32>
    1034:	e7 01       	movw	r28, r14
    1036:	01 50       	subi	r16, 0x01	; 1
    1038:	10 e0       	ldi	r17, 0x00	; 0
    103a:	0f 5f       	subi	r16, 0xFF	; 255
    103c:	1f 4f       	sbci	r17, 0xFF	; 255
    103e:	0e 0d       	add	r16, r14
    1040:	1f 1d       	adc	r17, r15
    1042:	7c d1       	rcall	.+760    	; 0x133c <ow_byte_rd>
    1044:	89 93       	st	Y+, r24
    1046:	c0 17       	cp	r28, r16
    1048:	d1 07       	cpc	r29, r17
    104a:	d9 f7       	brne	.-10     	; 0x1042 <read_scratchpad+0x28>
    104c:	69 e0       	ldi	r22, 0x09	; 9
    104e:	70 e0       	ldi	r23, 0x00	; 0
    1050:	c7 01       	movw	r24, r14
    1052:	c7 df       	rcall	.-114    	; 0xfe2 <crc8>
    1054:	81 11       	cpse	r24, r1
    1056:	83 e0       	ldi	r24, 0x03	; 3
    1058:	df 91       	pop	r29
    105a:	cf 91       	pop	r28
    105c:	1f 91       	pop	r17
    105e:	0f 91       	pop	r16
    1060:	ff 90       	pop	r15
    1062:	ef 90       	pop	r14
    1064:	08 95       	ret

00001066 <DS18X20_find_sensor>:
    1066:	0f 93       	push	r16
    1068:	1f 93       	push	r17
    106a:	cf 93       	push	r28
    106c:	df 93       	push	r29
    106e:	ec 01       	movw	r28, r24
    1070:	8b 01       	movw	r16, r22
    1072:	b8 01       	movw	r22, r16
    1074:	88 81       	ld	r24, Y
    1076:	65 d1       	rcall	.+714    	; 0x1342 <ow_rom_search>
    1078:	88 83       	st	Y, r24
    107a:	81 50       	subi	r24, 0x01	; 1
    107c:	8d 3f       	cpi	r24, 0xFD	; 253
    107e:	50 f4       	brcc	.+20     	; 0x1094 <DS18X20_find_sensor+0x2e>
    1080:	f8 01       	movw	r30, r16
    1082:	80 81       	ld	r24, Z
    1084:	88 32       	cpi	r24, 0x28	; 40
    1086:	41 f0       	breq	.+16     	; 0x1098 <DS18X20_find_sensor+0x32>
    1088:	80 31       	cpi	r24, 0x10	; 16
    108a:	41 f0       	breq	.+16     	; 0x109c <DS18X20_find_sensor+0x36>
    108c:	82 32       	cpi	r24, 0x22	; 34
    108e:	89 f7       	brne	.-30     	; 0x1072 <DS18X20_find_sensor+0xc>
    1090:	80 e0       	ldi	r24, 0x00	; 0
    1092:	05 c0       	rjmp	.+10     	; 0x109e <DS18X20_find_sensor+0x38>
    1094:	81 e0       	ldi	r24, 0x01	; 1
    1096:	03 c0       	rjmp	.+6      	; 0x109e <DS18X20_find_sensor+0x38>
    1098:	80 e0       	ldi	r24, 0x00	; 0
    109a:	01 c0       	rjmp	.+2      	; 0x109e <DS18X20_find_sensor+0x38>
    109c:	80 e0       	ldi	r24, 0x00	; 0
    109e:	df 91       	pop	r29
    10a0:	cf 91       	pop	r28
    10a2:	1f 91       	pop	r17
    10a4:	0f 91       	pop	r16
    10a6:	08 95       	ret

000010a8 <DS18X20_start_meas>:
    10a8:	1f 93       	push	r17
    10aa:	cf 93       	push	r28
    10ac:	df 93       	push	r29
    10ae:	18 2f       	mov	r17, r24
    10b0:	eb 01       	movw	r28, r22
    10b2:	cf d0       	rcall	.+414    	; 0x1252 <ow_reset>
    10b4:	a7 d0       	rcall	.+334    	; 0x1204 <ow_input_pin_state>
    10b6:	88 23       	and	r24, r24
    10b8:	61 f0       	breq	.+24     	; 0x10d2 <DS18X20_start_meas+0x2a>
    10ba:	11 30       	cpi	r17, 0x01	; 1
    10bc:	29 f0       	breq	.+10     	; 0x10c8 <DS18X20_start_meas+0x20>
    10be:	be 01       	movw	r22, r28
    10c0:	84 e4       	ldi	r24, 0x44	; 68
    10c2:	96 d1       	rcall	.+812    	; 0x13f0 <ow_command_with_parasite_enable>
    10c4:	80 e0       	ldi	r24, 0x00	; 0
    10c6:	0e c0       	rjmp	.+28     	; 0x10e4 <DS18X20_start_meas+0x3c>
    10c8:	be 01       	movw	r22, r28
    10ca:	84 e4       	ldi	r24, 0x44	; 68
    10cc:	8e d1       	rcall	.+796    	; 0x13ea <ow_command>
    10ce:	80 e0       	ldi	r24, 0x00	; 0
    10d0:	09 c0       	rjmp	.+18     	; 0x10e4 <DS18X20_start_meas+0x3c>
    10d2:	88 e8       	ldi	r24, 0x88	; 136
    10d4:	92 e0       	ldi	r25, 0x02	; 2
    10d6:	9f 93       	push	r25
    10d8:	8f 93       	push	r24
    10da:	0e 94 58 20 	call	0x40b0	; 0x40b0 <printf>
    10de:	0f 90       	pop	r0
    10e0:	0f 90       	pop	r0
    10e2:	82 e0       	ldi	r24, 0x02	; 2
    10e4:	df 91       	pop	r29
    10e6:	cf 91       	pop	r28
    10e8:	1f 91       	pop	r17
    10ea:	08 95       	ret

000010ec <DS18X20_read_maxres>:

	return temperaturevalue;
}

uint8_t DS18X20_read_maxres( uint8_t id[], long *temperaturevalue )
{
    10ec:	ef 92       	push	r14
    10ee:	ff 92       	push	r15
    10f0:	0f 93       	push	r16
    10f2:	1f 93       	push	r17
    10f4:	cf 93       	push	r28
    10f6:	df 93       	push	r29
    10f8:	cd b7       	in	r28, 0x3d	; 61
    10fa:	de b7       	in	r29, 0x3e	; 62
    10fc:	29 97       	sbiw	r28, 0x09	; 9
    10fe:	0f b6       	in	r0, 0x3f	; 63
    1100:	f8 94       	cli
    1102:	de bf       	out	0x3e, r29	; 62
    1104:	0f be       	out	0x3f, r0	; 63
    1106:	cd bf       	out	0x3d, r28	; 61
    1108:	7c 01       	movw	r14, r24
    110a:	8b 01       	movw	r16, r22
	uint8_t sp[DS18X20_SP_SIZE];
	uint8_t ret;
	
	ow_reset();
    110c:	a2 d0       	rcall	.+324    	; 0x1252 <ow_reset>
	ret = read_scratchpad( id, sp, DS18X20_SP_SIZE );
    110e:	49 e0       	ldi	r20, 0x09	; 9
    1110:	be 01       	movw	r22, r28
    1112:	6f 5f       	subi	r22, 0xFF	; 255
    1114:	7f 4f       	sbci	r23, 0xFF	; 255
    1116:	c7 01       	movw	r24, r14
    1118:	80 df       	rcall	.-256    	; 0x101a <read_scratchpad>
    111a:	e8 2f       	mov	r30, r24
	if ( ret == DS18X20_OK ) {
    111c:	81 11       	cpse	r24, r1
    111e:	64 c0       	rjmp	.+200    	; 0x11e8 <DS18X20_read_maxres+0xfc>
{
	uint16_t measure;
	uint8_t  negative;
	int32_t  temperaturevalue;

	measure = sp[0] | (sp[1] << 8);
    1120:	4a 81       	ldd	r20, Y+2	; 0x02
    1122:	50 e0       	ldi	r21, 0x00	; 0
    1124:	54 2f       	mov	r21, r20
    1126:	44 27       	eor	r20, r20
    1128:	89 81       	ldd	r24, Y+1	; 0x01
    112a:	48 2b       	or	r20, r24
	//measure = 0xFF5E; // test -10.125
	//measure = 0xFE6F; // test -25.0625

	if( familycode == DS18S20_FAMILY_CODE ) {   // 9 -> 12 bit if 18S20
    112c:	d7 01       	movw	r26, r14
    112e:	8c 91       	ld	r24, X
    1130:	80 31       	cpi	r24, 0x10	; 16
    1132:	71 f4       	brne	.+28     	; 0x1150 <DS18X20_read_maxres+0x64>
		/* Extended measurements for DS18S20 contributed by Carsten Foss */
		measure &= (uint16_t)0xfffe;   // Discard LSB, needed for later extended precicion calc
    1134:	4e 7f       	andi	r20, 0xFE	; 254
		measure <<= 3;                 // Convert to 12-bit, now degrees are in 1/16 degrees units
    1136:	44 0f       	add	r20, r20
    1138:	55 1f       	adc	r21, r21
    113a:	44 0f       	add	r20, r20
    113c:	55 1f       	adc	r21, r21
    113e:	44 0f       	add	r20, r20
    1140:	55 1f       	adc	r21, r21
		measure += ( 16 - sp[6] ) - 4; // Add the compensation and remember to subtract 0.25 degree (4/16)
    1142:	2f 81       	ldd	r18, Y+7	; 0x07
    1144:	8c e0       	ldi	r24, 0x0C	; 12
    1146:	90 e0       	ldi	r25, 0x00	; 0
    1148:	82 1b       	sub	r24, r18
    114a:	91 09       	sbc	r25, r1
    114c:	48 0f       	add	r20, r24
    114e:	59 1f       	adc	r21, r25
	}

	// Tarkastetaan onko negatiivinen 
	if ( measure & 0x8000 )  {
    1150:	55 23       	and	r21, r21
    1152:	6c f5       	brge	.+90     	; 0x11ae <DS18X20_read_maxres+0xc2>
		negative = 1;       // merkataan negatiivinen
		measure ^= 0xffff;  // muunna positiiviseksi => (kahden kmplementti)++
		measure++;
    1154:	51 95       	neg	r21
    1156:	41 95       	neg	r20
    1158:	51 09       	sbc	r21, r1
	}
	else {
		negative = 0;
	}	

	temperaturevalue  = (measure >> 4);
    115a:	9a 01       	movw	r18, r20
    115c:	32 95       	swap	r19
    115e:	22 95       	swap	r18
    1160:	2f 70       	andi	r18, 0x0F	; 15
    1162:	23 27       	eor	r18, r19
    1164:	3f 70       	andi	r19, 0x0F	; 15
    1166:	23 27       	eor	r18, r19
	temperaturevalue *= 10000;
    1168:	a0 e1       	ldi	r26, 0x10	; 16
    116a:	b7 e2       	ldi	r27, 0x27	; 39
    116c:	0e 94 16 20 	call	0x402c	; 0x402c <__umulhisi3>
	temperaturevalue +=( measure & 0x000F ) * DS18X20_FRACCONV;
    1170:	4f 70       	andi	r20, 0x0F	; 15
    1172:	55 27       	eor	r21, r21
    1174:	a1 e7       	ldi	r26, 0x71	; 113
    1176:	b2 e0       	ldi	r27, 0x02	; 2
    1178:	4a 9f       	mul	r20, r26
    117a:	90 01       	movw	r18, r0
    117c:	4b 9f       	mul	r20, r27
    117e:	30 0d       	add	r19, r0
    1180:	5a 9f       	mul	r21, r26
    1182:	30 0d       	add	r19, r0
    1184:	11 24       	eor	r1, r1
    1186:	dc 01       	movw	r26, r24
    1188:	cb 01       	movw	r24, r22
    118a:	82 0f       	add	r24, r18
    118c:	93 1f       	adc	r25, r19
    118e:	a1 1d       	adc	r26, r1
    1190:	b1 1d       	adc	r27, r1

	if ( negative ) {
		temperaturevalue = -temperaturevalue;
    1192:	44 27       	eor	r20, r20
    1194:	55 27       	eor	r21, r21
    1196:	ba 01       	movw	r22, r20
    1198:	48 1b       	sub	r20, r24
    119a:	59 0b       	sbc	r21, r25
    119c:	6a 0b       	sbc	r22, r26
    119e:	7b 0b       	sbc	r23, r27
	uint8_t ret;
	
	ow_reset();
	ret = read_scratchpad( id, sp, DS18X20_SP_SIZE );
	if ( ret == DS18X20_OK ) {
		*temperaturevalue = DS18X20_raw_to_maxres( id[0], sp );
    11a0:	d8 01       	movw	r26, r16
    11a2:	4d 93       	st	X+, r20
    11a4:	5d 93       	st	X+, r21
    11a6:	6d 93       	st	X+, r22
    11a8:	7c 93       	st	X, r23
    11aa:	13 97       	sbiw	r26, 0x03	; 3
	}
	return ret;
    11ac:	1d c0       	rjmp	.+58     	; 0x11e8 <DS18X20_read_maxres+0xfc>
	}
	else {
		negative = 0;
	}	

	temperaturevalue  = (measure >> 4);
    11ae:	9a 01       	movw	r18, r20
    11b0:	32 95       	swap	r19
    11b2:	22 95       	swap	r18
    11b4:	2f 70       	andi	r18, 0x0F	; 15
    11b6:	23 27       	eor	r18, r19
    11b8:	3f 70       	andi	r19, 0x0F	; 15
    11ba:	23 27       	eor	r18, r19
	temperaturevalue *= 10000;
    11bc:	a0 e1       	ldi	r26, 0x10	; 16
    11be:	b7 e2       	ldi	r27, 0x27	; 39
    11c0:	0e 94 16 20 	call	0x402c	; 0x402c <__umulhisi3>
	temperaturevalue +=( measure & 0x000F ) * DS18X20_FRACCONV;
    11c4:	4f 70       	andi	r20, 0x0F	; 15
    11c6:	55 27       	eor	r21, r21
    11c8:	a1 e7       	ldi	r26, 0x71	; 113
    11ca:	b2 e0       	ldi	r27, 0x02	; 2
    11cc:	4a 9f       	mul	r20, r26
    11ce:	90 01       	movw	r18, r0
    11d0:	4b 9f       	mul	r20, r27
    11d2:	30 0d       	add	r19, r0
    11d4:	5a 9f       	mul	r21, r26
    11d6:	30 0d       	add	r19, r0
    11d8:	11 24       	eor	r1, r1
    11da:	ab 01       	movw	r20, r22
    11dc:	bc 01       	movw	r22, r24
    11de:	42 0f       	add	r20, r18
    11e0:	53 1f       	adc	r21, r19
    11e2:	61 1d       	adc	r22, r1
    11e4:	71 1d       	adc	r23, r1
    11e6:	dc cf       	rjmp	.-72     	; 0x11a0 <DS18X20_read_maxres+0xb4>
	ret = read_scratchpad( id, sp, DS18X20_SP_SIZE );
	if ( ret == DS18X20_OK ) {
		*temperaturevalue = DS18X20_raw_to_maxres( id[0], sp );
	}
	return ret;
}
    11e8:	8e 2f       	mov	r24, r30
    11ea:	29 96       	adiw	r28, 0x09	; 9
    11ec:	0f b6       	in	r0, 0x3f	; 63
    11ee:	f8 94       	cli
    11f0:	de bf       	out	0x3e, r29	; 62
    11f2:	0f be       	out	0x3f, r0	; 63
    11f4:	cd bf       	out	0x3d, r28	; 61
    11f6:	df 91       	pop	r29
    11f8:	cf 91       	pop	r28
    11fa:	1f 91       	pop	r17
    11fc:	0f 91       	pop	r16
    11fe:	ff 90       	pop	r15
    1200:	ef 90       	pop	r14
    1202:	08 95       	ret

00001204 <ow_input_pin_state>:
	OW_DIR_OUT();
}

void ow_parasite_disable(void)
{
	OW_DIR_IN();
    1204:	8f b1       	in	r24, 0x0f	; 15
    1206:	80 78       	andi	r24, 0x80	; 128
    1208:	08 95       	ret

0000120a <ow_parasite_enable>:
    120a:	8f 9a       	sbi	0x11, 7	; 17
    120c:	87 9a       	sbi	0x10, 7	; 16
    120e:	08 95       	ret

00001210 <ow_bit_io_intern>:
    1210:	cf 93       	push	r28
    1212:	c8 2f       	mov	r28, r24
    1214:	f8 94       	cli
    1216:	87 9a       	sbi	0x10, 7	; 16
    1218:	8a e0       	ldi	r24, 0x0A	; 10
    121a:	8a 95       	dec	r24
    121c:	f1 f7       	brne	.-4      	; 0x121a <ow_bit_io_intern+0xa>
    121e:	00 c0       	rjmp	.+0      	; 0x1220 <ow_bit_io_intern+0x10>
    1220:	c1 11       	cpse	r28, r1
    1222:	87 98       	cbi	0x10, 7	; 16
    1224:	85 e4       	ldi	r24, 0x45	; 69
    1226:	8a 95       	dec	r24
    1228:	f1 f7       	brne	.-4      	; 0x1226 <ow_bit_io_intern+0x16>
    122a:	00 00       	nop
    122c:	8f b1       	in	r24, 0x0f	; 15
    122e:	88 0f       	add	r24, r24
    1230:	88 0b       	sbc	r24, r24
    1232:	c8 23       	and	r28, r24
    1234:	85 ee       	ldi	r24, 0xE5	; 229
    1236:	8a 95       	dec	r24
    1238:	f1 f7       	brne	.-4      	; 0x1236 <ow_bit_io_intern+0x26>
    123a:	00 00       	nop
    123c:	87 98       	cbi	0x10, 7	; 16
    123e:	61 11       	cpse	r22, r1
    1240:	e4 df       	rcall	.-56     	; 0x120a <ow_parasite_enable>
    1242:	85 e3       	ldi	r24, 0x35	; 53
    1244:	8a 95       	dec	r24
    1246:	f1 f7       	brne	.-4      	; 0x1244 <ow_bit_io_intern+0x34>
    1248:	00 00       	nop
    124a:	78 94       	sei
    124c:	8c 2f       	mov	r24, r28
    124e:	cf 91       	pop	r28
    1250:	08 95       	ret

00001252 <ow_reset>:

uint8_t ow_reset(void)
{
	uint8_t err;
	
	OW_OUT_LOW();
    1252:	8f 98       	cbi	0x11, 7	; 17
	OW_DIR_OUT();            // Vedetn OW-Pinni alas: 480us
    1254:	87 9a       	sbi	0x10, 7	; 16
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1256:	8f e7       	ldi	r24, 0x7F	; 127
    1258:	97 e0       	ldi	r25, 0x07	; 7
    125a:	01 97       	sbiw	r24, 0x01	; 1
    125c:	f1 f7       	brne	.-4      	; 0x125a <ow_reset+0x8>
    125e:	00 c0       	rjmp	.+0      	; 0x1260 <ow_reset+0xe>
    1260:	00 00       	nop
	_delay_us(480);

    cli();
    1262:	f8 94       	cli
	// Asetetaan pinni sisntuloksi - odotetaan, ett orjat vetvt alas
	OW_DIR_IN(); // sisntulo
    1264:	87 98       	cbi	0x10, 7	; 16
    1266:	ef ef       	ldi	r30, 0xFF	; 255
    1268:	f0 e0       	ldi	r31, 0x00	; 0
    126a:	31 97       	sbiw	r30, 0x01	; 1
    126c:	f1 f7       	brne	.-4      	; 0x126a <ow_reset+0x18>
    126e:	00 c0       	rjmp	.+0      	; 0x1270 <ow_reset+0x1e>
    1270:	00 00       	nop
	
	_delay_us(64);       // was 66
	err = OW_GET_IN();   // ei laitteita havaittu
    1272:	8f b1       	in	r24, 0x0f	; 15
    1274:	ef e7       	ldi	r30, 0x7F	; 127
    1276:	f6 e0       	ldi	r31, 0x06	; 6
    1278:	31 97       	sbiw	r30, 0x01	; 1
    127a:	f1 f7       	brne	.-4      	; 0x1278 <ow_reset+0x26>
    127c:	00 c0       	rjmp	.+0      	; 0x127e <ow_reset+0x2c>
    127e:	00 00       	nop
	
	// Viiveen jlkeen orjien tulisi vapauttaa linja
	// ja sisntulo-pinni palaa takaisin yltilaan ylsvetovastuksen toimesta
	
	_delay_us(480 - 64);       // was 480-66
	if( OW_GET_IN() == 0 ) {
    1280:	7f 9b       	sbis	0x0f, 7	; 15
    1282:	02 c0       	rjmp	.+4      	; 0x1288 <ow_reset+0x36>
    cli();
	// Asetetaan pinni sisntuloksi - odotetaan, ett orjat vetvt alas
	OW_DIR_IN(); // sisntulo
	
	_delay_us(64);       // was 66
	err = OW_GET_IN();   // ei laitteita havaittu
    1284:	80 78       	andi	r24, 0x80	; 128
    1286:	01 c0       	rjmp	.+2      	; 0x128a <ow_reset+0x38>
	// Viiveen jlkeen orjien tulisi vapauttaa linja
	// ja sisntulo-pinni palaa takaisin yltilaan ylsvetovastuksen toimesta
	
	_delay_us(480 - 64);       // was 480-66
	if( OW_GET_IN() == 0 ) {
		err = 1;             // short circuit, expected low but got high
    1288:	81 e0       	ldi	r24, 0x01	; 1
	}
	
	sei();
    128a:	78 94       	sei
	return err;
}
    128c:	08 95       	ret

0000128e <ow_bit_io>:
	return b;
}

uint8_t ow_bit_io( uint8_t b )
{
	return ow_bit_io_intern( b & 1, 0 );
    128e:	60 e0       	ldi	r22, 0x00	; 0
    1290:	81 70       	andi	r24, 0x01	; 1
    1292:	be cf       	rjmp	.-132    	; 0x1210 <ow_bit_io_intern>
}
    1294:	08 95       	ret

00001296 <ow_byte_wr>:

uint8_t ow_byte_wr( uint8_t b )
{
    1296:	cf 93       	push	r28
    1298:	df 93       	push	r29
    129a:	c8 2f       	mov	r28, r24
    129c:	d8 e0       	ldi	r29, 0x08	; 8
	uint8_t i = 8, j;
	
	do {
		j = ow_bit_io( b & 1 );
    129e:	8c 2f       	mov	r24, r28
    12a0:	81 70       	andi	r24, 0x01	; 1
    12a2:	f5 df       	rcall	.-22     	; 0x128e <ow_bit_io>
		b >>= 1;
    12a4:	c6 95       	lsr	r28
		if( j ) {
    12a6:	81 11       	cpse	r24, r1
			b |= 0x80;
    12a8:	c0 68       	ori	r28, 0x80	; 128
    12aa:	d1 50       	subi	r29, 0x01	; 1
		}
	} while( --i );
    12ac:	c1 f7       	brne	.-16     	; 0x129e <ow_byte_wr+0x8>
	
	return b;
}
    12ae:	8c 2f       	mov	r24, r28
    12b0:	df 91       	pop	r29
    12b2:	cf 91       	pop	r28
    12b4:	08 95       	ret

000012b6 <ow_byte_wr_with_parasite_enable>:

uint8_t ow_byte_wr_with_parasite_enable( uint8_t b )
{
    12b6:	cf 93       	push	r28
    12b8:	df 93       	push	r29
    12ba:	c8 2f       	mov	r28, r24
	uint8_t i = 8, j;
    12bc:	d8 e0       	ldi	r29, 0x08	; 8
	
	do {
		if ( i != 1 ) {
    12be:	d1 30       	cpi	r29, 0x01	; 1
    12c0:	41 f0       	breq	.+16     	; 0x12d2 <ow_byte_wr_with_parasite_enable+0x1c>
			j = ow_bit_io_intern( b & 1, 0 );
    12c2:	60 e0       	ldi	r22, 0x00	; 0
    12c4:	8c 2f       	mov	r24, r28
    12c6:	81 70       	andi	r24, 0x01	; 1
    12c8:	a3 df       	rcall	.-186    	; 0x1210 <ow_bit_io_intern>
		} else {
			j = ow_bit_io_intern( b & 1, 1 );
		}
		b >>= 1;
    12ca:	c6 95       	lsr	r28
		if( j ) {
    12cc:	81 11       	cpse	r24, r1
    12ce:	08 c0       	rjmp	.+16     	; 0x12e0 <ow_byte_wr_with_parasite_enable+0x2a>
    12d0:	08 c0       	rjmp	.+16     	; 0x12e2 <ow_byte_wr_with_parasite_enable+0x2c>
	
	do {
		if ( i != 1 ) {
			j = ow_bit_io_intern( b & 1, 0 );
		} else {
			j = ow_bit_io_intern( b & 1, 1 );
    12d2:	61 e0       	ldi	r22, 0x01	; 1
    12d4:	8c 2f       	mov	r24, r28
    12d6:	81 70       	andi	r24, 0x01	; 1
    12d8:	9b df       	rcall	.-202    	; 0x1210 <ow_bit_io_intern>
		}
		b >>= 1;
    12da:	c6 95       	lsr	r28
		if( j ) {
    12dc:	88 23       	and	r24, r24
    12de:	19 f0       	breq	.+6      	; 0x12e6 <ow_byte_wr_with_parasite_enable+0x30>
			b |= 0x80;
    12e0:	c0 68       	ori	r28, 0x80	; 128
		}
	} while( --i );
    12e2:	d1 50       	subi	r29, 0x01	; 1
    12e4:	61 f7       	brne	.-40     	; 0x12be <ow_byte_wr_with_parasite_enable+0x8>
	
	return b;
}
    12e6:	8c 2f       	mov	r24, r28
    12e8:	df 91       	pop	r29
    12ea:	cf 91       	pop	r28
    12ec:	08 95       	ret

000012ee <ow_command_intern>:
	return next_diff;                   // jatketaan etsint
}


static void ow_command_intern( uint8_t command, uint8_t *id, uint8_t with_parasite_enable )
{
    12ee:	ef 92       	push	r14
    12f0:	ff 92       	push	r15
    12f2:	0f 93       	push	r16
    12f4:	1f 93       	push	r17
    12f6:	cf 93       	push	r28
    12f8:	df 93       	push	r29
    12fa:	e8 2e       	mov	r14, r24
    12fc:	eb 01       	movw	r28, r22
    12fe:	f4 2e       	mov	r15, r20
	uint8_t i;

	ow_reset();
    1300:	a8 df       	rcall	.-176    	; 0x1252 <ow_reset>

	if( id ) {
    1302:	20 97       	sbiw	r28, 0x00	; 0
    1304:	59 f0       	breq	.+22     	; 0x131c <ow_command_intern+0x2e>
		ow_byte_wr( OW_MATCH_ROM );     // yksittiselle laitteelle, osoitetaan tietty anturia
    1306:	85 e5       	ldi	r24, 0x55	; 85
    1308:	c6 df       	rcall	.-116    	; 0x1296 <ow_byte_wr>
    130a:	8e 01       	movw	r16, r28
    130c:	08 5f       	subi	r16, 0xF8	; 248
    130e:	1f 4f       	sbci	r17, 0xFF	; 255
		i = OW_ROMCODE_SIZE;			
		do {
			ow_byte_wr( *id );
    1310:	89 91       	ld	r24, Y+
    1312:	c1 df       	rcall	.-126    	; 0x1296 <ow_byte_wr>
    1314:	c0 17       	cp	r28, r16
			id++;
		} while( --i );
    1316:	d1 07       	cpc	r29, r17
    1318:	d9 f7       	brne	.-10     	; 0x1310 <ow_command_intern+0x22>
    131a:	02 c0       	rjmp	.+4      	; 0x1320 <ow_command_intern+0x32>
	} 
	else {
		ow_byte_wr( OW_SKIP_ROM );      // kaikille laitteille, sstetn aikaa vylll, 
    131c:	8c ec       	ldi	r24, 0xCC	; 204
    131e:	bb df       	rcall	.-138    	; 0x1296 <ow_byte_wr>
										// jossa vain yksi anturi
	}									 
	
	if ( with_parasite_enable  ) {
    1320:	ff 20       	and	r15, r15
    1322:	19 f0       	breq	.+6      	; 0x132a <ow_command_intern+0x3c>
		ow_byte_wr_with_parasite_enable( command );
    1324:	8e 2d       	mov	r24, r14
    1326:	c7 df       	rcall	.-114    	; 0x12b6 <ow_byte_wr_with_parasite_enable>
    1328:	02 c0       	rjmp	.+4      	; 0x132e <ow_command_intern+0x40>
	} else {
		ow_byte_wr( command );
    132a:	8e 2d       	mov	r24, r14
    132c:	b4 df       	rcall	.-152    	; 0x1296 <ow_byte_wr>
    132e:	df 91       	pop	r29
	}
}
    1330:	cf 91       	pop	r28
    1332:	1f 91       	pop	r17
    1334:	0f 91       	pop	r16
    1336:	ff 90       	pop	r15
    1338:	ef 90       	pop	r14
    133a:	08 95       	ret

0000133c <ow_byte_rd>:
    133c:	8f ef       	ldi	r24, 0xFF	; 255

uint8_t ow_byte_rd( void )
{
	// read by sending only "1"s, so bus gets released
	// after the init low-pulse in every slot
	return ow_byte_wr( 0xFF ); 
    133e:	ab cf       	rjmp	.-170    	; 0x1296 <ow_byte_wr>
}
    1340:	08 95       	ret

00001342 <ow_rom_search>:


uint8_t ow_rom_search( uint8_t diff, uint8_t *id )
{
    1342:	df 92       	push	r13
    1344:	ef 92       	push	r14
    1346:	ff 92       	push	r15
    1348:	0f 93       	push	r16
    134a:	1f 93       	push	r17
    134c:	cf 93       	push	r28
    134e:	df 93       	push	r29
    1350:	d8 2e       	mov	r13, r24
    1352:	8b 01       	movw	r16, r22
	uint8_t i, j, next_diff;
	uint8_t b;
	
	if( ow_reset() ) {
    1354:	7e df       	rcall	.-260    	; 0x1252 <ow_reset>
    1356:	81 11       	cpse	r24, r1
    1358:	28 c0       	rjmp	.+80     	; 0x13aa <ow_rom_search+0x68>
		return OW_PRESENCE_ERR;         // error, no device found <--- early exit!
	}
	
	ow_byte_wr( OW_SEARCH_ROM );        // ROM search komento
    135a:	80 ef       	ldi	r24, 0xF0	; 240
    135c:	9c df       	rcall	.-200    	; 0x1296 <ow_byte_wr>
	next_diff = OW_LAST_DEVICE;         // unchanged on last device
    135e:	e1 2c       	mov	r14, r1
	
	i = OW_ROMCODE_SIZE * 8;            // 8 tavua
    1360:	c0 e4       	ldi	r28, 0x40	; 64
    1362:	0f 2e       	mov	r0, r31
    1364:	f8 ef       	ldi	r31, 0xF8	; 248
    1366:	ff 2e       	mov	r15, r31
    1368:	f0 2d       	mov	r31, r0
	
	do {
		j = 8;                          // 8 bitti
		do {
			b = ow_bit_io( 1 );         // lue bitti
    136a:	fc 0e       	add	r15, r28
    136c:	81 e0       	ldi	r24, 0x01	; 1
    136e:	8f df       	rcall	.-226    	; 0x128e <ow_bit_io>
			if( ow_bit_io( 1 ) ) {      // lue komplementti bitti
    1370:	d8 2f       	mov	r29, r24
    1372:	81 e0       	ldi	r24, 0x01	; 1
    1374:	8c df       	rcall	.-232    	; 0x128e <ow_bit_io>
    1376:	88 23       	and	r24, r24
    1378:	19 f0       	breq	.+6      	; 0x1380 <ow_rom_search+0x3e>
				if( b ) {               // 0b11
    137a:	dd 23       	and	r29, r29
    137c:	d1 f0       	breq	.+52     	; 0x13b2 <ow_rom_search+0x70>
    137e:	17 c0       	rjmp	.+46     	; 0x13ae <ow_rom_search+0x6c>
					return OW_DATA_ERR; // data error <--- early exit!
				}
			}
			else {
				if( !b ) {              // 0b00 = 2 devices
    1380:	d1 11       	cpse	r29, r1
    1382:	23 c0       	rjmp	.+70     	; 0x13ca <ow_rom_search+0x88>
					if( diff > i || ((*id & 1) && diff != i) ) {
    1384:	cd 15       	cp	r28, r13
    1386:	e0 f0       	brcs	.+56     	; 0x13c0 <ow_rom_search+0x7e>
    1388:	f8 01       	movw	r30, r16
    138a:	80 81       	ld	r24, Z
    138c:	80 ff       	sbrs	r24, 0
    138e:	11 c0       	rjmp	.+34     	; 0x13b2 <ow_rom_search+0x70>
    1390:	cd 11       	cpse	r28, r13
    1392:	19 c0       	rjmp	.+50     	; 0x13c6 <ow_rom_search+0x84>
    1394:	0e c0       	rjmp	.+28     	; 0x13b2 <ow_rom_search+0x70>
			*id >>= 1;
			if( b ) {
				*id |= 0x80;            // talleta bitti
			}
			
			i--;
    1396:	c1 50       	subi	r28, 0x01	; 1
			
		} while( --j );
    1398:	fc 12       	cpse	r15, r28
    139a:	e8 cf       	rjmp	.-48     	; 0x136c <ow_rom_search+0x2a>
		
		id++;                           // seuraava tavu
    139c:	0f 5f       	subi	r16, 0xFF	; 255
    139e:	1f 4f       	sbci	r17, 0xFF	; 255
			*id >>= 1;
			if( b ) {
				*id |= 0x80;            // talleta bitti
			}
			
			i--;
    13a0:	cf 2d       	mov	r28, r15
			
		} while( --j );
		
		id++;                           // seuraava tavu
	
	} while( i );
    13a2:	f1 10       	cpse	r15, r1
    13a4:	de cf       	rjmp	.-68     	; 0x1362 <ow_rom_search+0x20>
    13a6:	8e 2d       	mov	r24, r14
    13a8:	18 c0       	rjmp	.+48     	; 0x13da <ow_rom_search+0x98>
{
	uint8_t i, j, next_diff;
	uint8_t b;
	
	if( ow_reset() ) {
		return OW_PRESENCE_ERR;         // error, no device found <--- early exit!
    13aa:	8f ef       	ldi	r24, 0xFF	; 255
		j = 8;                          // 8 bitti
		do {
			b = ow_bit_io( 1 );         // lue bitti
			if( ow_bit_io( 1 ) ) {      // lue komplementti bitti
				if( b ) {               // 0b11
					return OW_DATA_ERR; // data error <--- early exit!
    13ac:	16 c0       	rjmp	.+44     	; 0x13da <ow_rom_search+0x98>
    13ae:	8e ef       	ldi	r24, 0xFE	; 254
						b = 1;          // nyt 1
						next_diff = i;  // next pass 0
					}
				}
			}
			ow_bit_io( b );             // kirjoita bitti
    13b0:	14 c0       	rjmp	.+40     	; 0x13da <ow_rom_search+0x98>
    13b2:	80 e0       	ldi	r24, 0x00	; 0
    13b4:	6c df       	rcall	.-296    	; 0x128e <ow_bit_io>
			*id >>= 1;
    13b6:	f8 01       	movw	r30, r16
    13b8:	90 81       	ld	r25, Z
    13ba:	96 95       	lsr	r25
    13bc:	90 83       	st	Z, r25
    13be:	eb cf       	rjmp	.-42     	; 0x1396 <ow_rom_search+0x54>
			}
			else {
				if( !b ) {              // 0b00 = 2 devices
					if( diff > i || ((*id & 1) && diff != i) ) {
						b = 1;          // nyt 1
						next_diff = i;  // next pass 0
    13c0:	ec 2e       	mov	r14, r28
				}
			}
			else {
				if( !b ) {              // 0b00 = 2 devices
					if( diff > i || ((*id & 1) && diff != i) ) {
						b = 1;          // nyt 1
    13c2:	d1 e0       	ldi	r29, 0x01	; 1
						next_diff = i;  // next pass 0
    13c4:	02 c0       	rjmp	.+4      	; 0x13ca <ow_rom_search+0x88>
				}
			}
			else {
				if( !b ) {              // 0b00 = 2 devices
					if( diff > i || ((*id & 1) && diff != i) ) {
						b = 1;          // nyt 1
    13c6:	ec 2e       	mov	r14, r28
						next_diff = i;  // next pass 0
					}
				}
			}
			ow_bit_io( b );             // kirjoita bitti
    13c8:	d1 e0       	ldi	r29, 0x01	; 1
    13ca:	8d 2f       	mov	r24, r29
    13cc:	60 df       	rcall	.-320    	; 0x128e <ow_bit_io>
			*id >>= 1;
			if( b ) {
				*id |= 0x80;            // talleta bitti
    13ce:	f8 01       	movw	r30, r16
    13d0:	90 81       	ld	r25, Z
    13d2:	96 95       	lsr	r25
    13d4:	90 68       	ori	r25, 0x80	; 128
    13d6:	90 83       	st	Z, r25
    13d8:	de cf       	rjmp	.-68     	; 0x1396 <ow_rom_search+0x54>
		id++;                           // seuraava tavu
	
	} while( i );
	
	return next_diff;                   // jatketaan etsint
}
    13da:	df 91       	pop	r29
    13dc:	cf 91       	pop	r28
    13de:	1f 91       	pop	r17
    13e0:	0f 91       	pop	r16
    13e2:	ff 90       	pop	r15
    13e4:	ef 90       	pop	r14
    13e6:	df 90       	pop	r13
    13e8:	08 95       	ret

000013ea <ow_command>:
	}
}

void ow_command( uint8_t command, uint8_t *id )
{
	ow_command_intern( command, id, 0);
    13ea:	40 e0       	ldi	r20, 0x00	; 0
    13ec:	80 cf       	rjmp	.-256    	; 0x12ee <ow_command_intern>
    13ee:	08 95       	ret

000013f0 <ow_command_with_parasite_enable>:
}

void ow_command_with_parasite_enable( uint8_t command, uint8_t *id )
{
	ow_command_intern( command, id, 1 );
    13f0:	41 e0       	ldi	r20, 0x01	; 1
    13f2:	7d cf       	rjmp	.-262    	; 0x12ee <ow_command_intern>
    13f4:	08 95       	ret

000013f6 <search_sensors>:
}

uint8_t search_sensors(void)
{
    13f6:	cf 92       	push	r12
    13f8:	df 92       	push	r13
    13fa:	ff 92       	push	r15
    13fc:	0f 93       	push	r16
    13fe:	1f 93       	push	r17
    1400:	cf 93       	push	r28
    1402:	df 93       	push	r29
    1404:	cd b7       	in	r28, 0x3d	; 61
    1406:	de b7       	in	r29, 0x3e	; 62
    1408:	29 97       	sbiw	r28, 0x09	; 9
    140a:	0f b6       	in	r0, 0x3f	; 63
    140c:	f8 94       	cli
    140e:	de bf       	out	0x3e, r29	; 62
    1410:	0f be       	out	0x3f, r0	; 63
    1412:	cd bf       	out	0x3d, r28	; 61
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1414:	2f ef       	ldi	r18, 0xFF	; 255
    1416:	89 eb       	ldi	r24, 0xB9	; 185
    1418:	9b ed       	ldi	r25, 0xDB	; 219
    141a:	21 50       	subi	r18, 0x01	; 1
    141c:	80 40       	sbci	r24, 0x00	; 0
    141e:	90 40       	sbci	r25, 0x00	; 0
    1420:	e1 f7       	brne	.-8      	; 0x141a <search_sensors+0x24>
    1422:	00 c0       	rjmp	.+0      	; 0x1424 <search_sensors+0x2e>
    1424:	00 00       	nop
	uint8_t id[OW_ROMCODE_SIZE];
	uint8_t diff, numberOfSensors;
	
	_delay_ms(1500*3);

	ow_reset();
    1426:	15 df       	rcall	.-470    	; 0x1252 <ow_reset>

	numberOfSensors = 0;
	
	diff = OW_SEARCH_FIRST;
    1428:	8f ef       	ldi	r24, 0xFF	; 255
    142a:	89 87       	std	Y+9, r24	; 0x09
    142c:	0f 2e       	mov	r0, r31
    142e:	f1 e2       	ldi	r31, 0x21	; 33
    1430:	cf 2e       	mov	r12, r31
    1432:	f6 e1       	ldi	r31, 0x16	; 22
    1434:	df 2e       	mov	r13, r31
    1436:	f0 2d       	mov	r31, r0
    1438:	f1 2c       	mov	r15, r1
	while ( diff != OW_LAST_DEVICE && numberOfSensors < MAXSENSORS ) {
		DS18X20_find_sensor( &diff, &id[0] );
    143a:	8e 01       	movw	r16, r28
    143c:	07 5f       	subi	r16, 0xF7	; 247
    143e:	1f 4f       	sbci	r17, 0xFF	; 255
    1440:	be 01       	movw	r22, r28
    1442:	6f 5f       	subi	r22, 0xFF	; 255
    1444:	7f 4f       	sbci	r23, 0xFF	; 255
    1446:	c8 01       	movw	r24, r16
    1448:	0e de       	rcall	.-996    	; 0x1066 <DS18X20_find_sensor>
	
		if (diff != OW_PRESENCE_ERR)
    144a:	99 85       	ldd	r25, Y+9	; 0x09
    144c:	9f 3f       	cpi	r25, 0xFF	; 255
    144e:	89 f0       	breq	.+34     	; 0x1472 <search_sensors+0x7c>
    1450:	fe 01       	movw	r30, r28
    1452:	31 96       	adiw	r30, 0x01	; 1
    1454:	d6 01       	movw	r26, r12
		{
		  for ( i=0; i < OW_ROMCODE_SIZE; i++ )
		    	getSensorIDs[numberOfSensors][i] = id[i];
    1456:	81 91       	ld	r24, Z+
    1458:	8d 93       	st	X+, r24
	while ( diff != OW_LAST_DEVICE && numberOfSensors < MAXSENSORS ) {
		DS18X20_find_sensor( &diff, &id[0] );
	
		if (diff != OW_PRESENCE_ERR)
		{
		  for ( i=0; i < OW_ROMCODE_SIZE; i++ )
    145a:	e0 17       	cp	r30, r16
    145c:	f1 07       	cpc	r31, r17
    145e:	d9 f7       	brne	.-10     	; 0x1456 <search_sensors+0x60>
		    	getSensorIDs[numberOfSensors][i] = id[i];
	  	
		  numberOfSensors++;
    1460:	f3 94       	inc	r15
	ow_reset();

	numberOfSensors = 0;
	
	diff = OW_SEARCH_FIRST;
	while ( diff != OW_LAST_DEVICE && numberOfSensors < MAXSENSORS ) {
    1462:	99 23       	and	r25, r25
    1464:	31 f0       	breq	.+12     	; 0x1472 <search_sensors+0x7c>
    1466:	28 e0       	ldi	r18, 0x08	; 8
    1468:	c2 0e       	add	r12, r18
    146a:	d1 1c       	adc	r13, r1
    146c:	88 e0       	ldi	r24, 0x08	; 8
    146e:	f8 12       	cpse	r15, r24
    1470:	e7 cf       	rjmp	.-50     	; 0x1440 <search_sensors+0x4a>
		else
		  break;
	}
	
	return numberOfSensors;
}
    1472:	8f 2d       	mov	r24, r15
    1474:	29 96       	adiw	r28, 0x09	; 9
    1476:	0f b6       	in	r0, 0x3f	; 63
    1478:	f8 94       	cli
    147a:	de bf       	out	0x3e, r29	; 62
    147c:	0f be       	out	0x3f, r0	; 63
    147e:	cd bf       	out	0x3d, r28	; 61
    1480:	df 91       	pop	r29
    1482:	cf 91       	pop	r28
    1484:	1f 91       	pop	r17
    1486:	0f 91       	pop	r16
    1488:	ff 90       	pop	r15
    148a:	df 90       	pop	r13
    148c:	cf 90       	pop	r12
    148e:	08 95       	ret

00001490 <GetSensorCount>:

unsigned char GetSensorCount(void)
{
  return search_sensors();
    1490:	b2 cf       	rjmp	.-156    	; 0x13f6 <search_sensors>
}
    1492:	08 95       	ret

00001494 <GetTemperature>:

long    GetTemperature( unsigned nSensor)
{ long temperature;
    1494:	0f 93       	push	r16
    1496:	1f 93       	push	r17
    1498:	cf 93       	push	r28
    149a:	df 93       	push	r29
    149c:	00 d0       	rcall	.+0      	; 0x149e <GetTemperature+0xa>
    149e:	1f 92       	push	r1
    14a0:	cd b7       	in	r28, 0x3d	; 61
    14a2:	de b7       	in	r29, 0x3e	; 62
    14a4:	8c 01       	movw	r16, r24
	// ROM mik sai Arduino IDEll
	// hex: 10 AD BE A5 3 8 0 BA
	//uint8_t id = (16, 173, 190, 165, 56, 11, 160);
   
   DS18X20_start_meas( DS18X20_POWER_EXTERN, NULL);
    14a6:	60 e0       	ldi	r22, 0x00	; 0
    14a8:	70 e0       	ldi	r23, 0x00	; 0
    14aa:	81 e0       	ldi	r24, 0x01	; 1
    14ac:	fd dd       	rcall	.-1030   	; 0x10a8 <DS18X20_start_meas>
    14ae:	2f ef       	ldi	r18, 0xFF	; 255
    14b0:	8e e9       	ldi	r24, 0x9E	; 158
    14b2:	94 e2       	ldi	r25, 0x24	; 36
    14b4:	21 50       	subi	r18, 0x01	; 1
    14b6:	80 40       	sbci	r24, 0x00	; 0
    14b8:	90 40       	sbci	r25, 0x00	; 0
    14ba:	e1 f7       	brne	.-8      	; 0x14b4 <GetTemperature+0x20>
    14bc:	00 c0       	rjmp	.+0      	; 0x14be <GetTemperature+0x2a>
    14be:	00 00       	nop
	  
   _delay_ms( DS18B20_TCONV_12BIT );

   DS18X20_read_maxres( &getSensorIDs[nSensor][0], &temperature );
    14c0:	c8 01       	movw	r24, r16
    14c2:	88 0f       	add	r24, r24
    14c4:	99 1f       	adc	r25, r25
    14c6:	88 0f       	add	r24, r24
    14c8:	99 1f       	adc	r25, r25
    14ca:	88 0f       	add	r24, r24
    14cc:	99 1f       	adc	r25, r25
    14ce:	be 01       	movw	r22, r28
    14d0:	6f 5f       	subi	r22, 0xFF	; 255
    14d2:	7f 4f       	sbci	r23, 0xFF	; 255
    14d4:	8f 5d       	subi	r24, 0xDF	; 223
    14d6:	99 4e       	sbci	r25, 0xE9	; 233
    14d8:	09 de       	rcall	.-1006   	; 0x10ec <DS18X20_read_maxres>
   return temperature;
    14da:	69 81       	ldd	r22, Y+1	; 0x01
    14dc:	7a 81       	ldd	r23, Y+2	; 0x02
    14de:	8b 81       	ldd	r24, Y+3	; 0x03
    14e0:	9c 81       	ldd	r25, Y+4	; 0x04
}
    14e2:	0f 90       	pop	r0
    14e4:	0f 90       	pop	r0
    14e6:	0f 90       	pop	r0
    14e8:	0f 90       	pop	r0
    14ea:	df 91       	pop	r29
    14ec:	cf 91       	pop	r28
    14ee:	1f 91       	pop	r17
    14f0:	0f 91       	pop	r16
    14f2:	08 95       	ret

000014f4 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    14f4:	cf 93       	push	r28
    14f6:	df 93       	push	r29
    14f8:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    14fa:	0e 94 ac 15 	call	0x2b58	; 0x2b58 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    14fe:	80 91 97 03 	lds	r24, 0x0397	; 0x800397 <pucAlignedHeap.2023>
    1502:	90 91 98 03 	lds	r25, 0x0398	; 0x800398 <pucAlignedHeap.2023+0x1>
    1506:	89 2b       	or	r24, r25
    1508:	31 f4       	brne	.+12     	; 0x1516 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    150a:	8c e9       	ldi	r24, 0x9C	; 156
    150c:	93 e0       	ldi	r25, 0x03	; 3
    150e:	90 93 98 03 	sts	0x0398, r25	; 0x800398 <pucAlignedHeap.2023+0x1>
    1512:	80 93 97 03 	sts	0x0397, r24	; 0x800397 <pucAlignedHeap.2023>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1516:	20 91 99 03 	lds	r18, 0x0399	; 0x800399 <xNextFreeByte>
    151a:	30 91 9a 03 	lds	r19, 0x039A	; 0x80039a <xNextFreeByte+0x1>
    151e:	c9 01       	movw	r24, r18
    1520:	8c 0f       	add	r24, r28
    1522:	9d 1f       	adc	r25, r29
    1524:	8f 3f       	cpi	r24, 0xFF	; 255
    1526:	41 e1       	ldi	r20, 0x11	; 17
    1528:	94 07       	cpc	r25, r20
    152a:	70 f4       	brcc	.+28     	; 0x1548 <pvPortMalloc+0x54>
    152c:	28 17       	cp	r18, r24
    152e:	39 07       	cpc	r19, r25
    1530:	70 f4       	brcc	.+28     	; 0x154e <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1532:	c0 91 97 03 	lds	r28, 0x0397	; 0x800397 <pucAlignedHeap.2023>
    1536:	d0 91 98 03 	lds	r29, 0x0398	; 0x800398 <pucAlignedHeap.2023+0x1>
    153a:	c2 0f       	add	r28, r18
    153c:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    153e:	90 93 9a 03 	sts	0x039A, r25	; 0x80039a <xNextFreeByte+0x1>
    1542:	80 93 99 03 	sts	0x0399, r24	; 0x800399 <xNextFreeByte>
    1546:	05 c0       	rjmp	.+10     	; 0x1552 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1548:	c0 e0       	ldi	r28, 0x00	; 0
    154a:	d0 e0       	ldi	r29, 0x00	; 0
    154c:	02 c0       	rjmp	.+4      	; 0x1552 <pvPortMalloc+0x5e>
    154e:	c0 e0       	ldi	r28, 0x00	; 0
    1550:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1552:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1556:	ce 01       	movw	r24, r28
    1558:	df 91       	pop	r29
    155a:	cf 91       	pop	r28
    155c:	08 95       	ret

0000155e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    155e:	08 95       	ret

00001560 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1560:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1562:	03 96       	adiw	r24, 0x03	; 3
    1564:	92 83       	std	Z+2, r25	; 0x02
    1566:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1568:	2f ef       	ldi	r18, 0xFF	; 255
    156a:	3f ef       	ldi	r19, 0xFF	; 255
    156c:	34 83       	std	Z+4, r19	; 0x04
    156e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1570:	96 83       	std	Z+6, r25	; 0x06
    1572:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1574:	90 87       	std	Z+8, r25	; 0x08
    1576:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1578:	10 82       	st	Z, r1
    157a:	08 95       	ret

0000157c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    157c:	fc 01       	movw	r30, r24
    157e:	11 86       	std	Z+9, r1	; 0x09
    1580:	10 86       	std	Z+8, r1	; 0x08
    1582:	08 95       	ret

00001584 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1584:	cf 93       	push	r28
    1586:	df 93       	push	r29
    1588:	9c 01       	movw	r18, r24
    158a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    158c:	dc 01       	movw	r26, r24
    158e:	11 96       	adiw	r26, 0x01	; 1
    1590:	cd 91       	ld	r28, X+
    1592:	dc 91       	ld	r29, X
    1594:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1596:	d3 83       	std	Z+3, r29	; 0x03
    1598:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    159a:	8c 81       	ldd	r24, Y+4	; 0x04
    159c:	9d 81       	ldd	r25, Y+5	; 0x05
    159e:	95 83       	std	Z+5, r25	; 0x05
    15a0:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    15a2:	8c 81       	ldd	r24, Y+4	; 0x04
    15a4:	9d 81       	ldd	r25, Y+5	; 0x05
    15a6:	dc 01       	movw	r26, r24
    15a8:	13 96       	adiw	r26, 0x03	; 3
    15aa:	7c 93       	st	X, r23
    15ac:	6e 93       	st	-X, r22
    15ae:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    15b0:	7d 83       	std	Y+5, r23	; 0x05
    15b2:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    15b4:	31 87       	std	Z+9, r19	; 0x09
    15b6:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    15b8:	f9 01       	movw	r30, r18
    15ba:	80 81       	ld	r24, Z
    15bc:	8f 5f       	subi	r24, 0xFF	; 255
    15be:	80 83       	st	Z, r24
}
    15c0:	df 91       	pop	r29
    15c2:	cf 91       	pop	r28
    15c4:	08 95       	ret

000015c6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    15c6:	cf 93       	push	r28
    15c8:	df 93       	push	r29
    15ca:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    15cc:	48 81       	ld	r20, Y
    15ce:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    15d0:	4f 3f       	cpi	r20, 0xFF	; 255
    15d2:	2f ef       	ldi	r18, 0xFF	; 255
    15d4:	52 07       	cpc	r21, r18
    15d6:	21 f4       	brne	.+8      	; 0x15e0 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    15d8:	fc 01       	movw	r30, r24
    15da:	a7 81       	ldd	r26, Z+7	; 0x07
    15dc:	b0 85       	ldd	r27, Z+8	; 0x08
    15de:	0d c0       	rjmp	.+26     	; 0x15fa <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    15e0:	dc 01       	movw	r26, r24
    15e2:	13 96       	adiw	r26, 0x03	; 3
    15e4:	01 c0       	rjmp	.+2      	; 0x15e8 <vListInsert+0x22>
    15e6:	df 01       	movw	r26, r30
    15e8:	12 96       	adiw	r26, 0x02	; 2
    15ea:	ed 91       	ld	r30, X+
    15ec:	fc 91       	ld	r31, X
    15ee:	13 97       	sbiw	r26, 0x03	; 3
    15f0:	20 81       	ld	r18, Z
    15f2:	31 81       	ldd	r19, Z+1	; 0x01
    15f4:	42 17       	cp	r20, r18
    15f6:	53 07       	cpc	r21, r19
    15f8:	b0 f7       	brcc	.-20     	; 0x15e6 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    15fa:	12 96       	adiw	r26, 0x02	; 2
    15fc:	ed 91       	ld	r30, X+
    15fe:	fc 91       	ld	r31, X
    1600:	13 97       	sbiw	r26, 0x03	; 3
    1602:	fb 83       	std	Y+3, r31	; 0x03
    1604:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1606:	d5 83       	std	Z+5, r29	; 0x05
    1608:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    160a:	bd 83       	std	Y+5, r27	; 0x05
    160c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    160e:	13 96       	adiw	r26, 0x03	; 3
    1610:	dc 93       	st	X, r29
    1612:	ce 93       	st	-X, r28
    1614:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1616:	99 87       	std	Y+9, r25	; 0x09
    1618:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    161a:	fc 01       	movw	r30, r24
    161c:	20 81       	ld	r18, Z
    161e:	2f 5f       	subi	r18, 0xFF	; 255
    1620:	20 83       	st	Z, r18
}
    1622:	df 91       	pop	r29
    1624:	cf 91       	pop	r28
    1626:	08 95       	ret

00001628 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1628:	cf 93       	push	r28
    162a:	df 93       	push	r29
    162c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    162e:	a0 85       	ldd	r26, Z+8	; 0x08
    1630:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1632:	c2 81       	ldd	r28, Z+2	; 0x02
    1634:	d3 81       	ldd	r29, Z+3	; 0x03
    1636:	84 81       	ldd	r24, Z+4	; 0x04
    1638:	95 81       	ldd	r25, Z+5	; 0x05
    163a:	9d 83       	std	Y+5, r25	; 0x05
    163c:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    163e:	c4 81       	ldd	r28, Z+4	; 0x04
    1640:	d5 81       	ldd	r29, Z+5	; 0x05
    1642:	82 81       	ldd	r24, Z+2	; 0x02
    1644:	93 81       	ldd	r25, Z+3	; 0x03
    1646:	9b 83       	std	Y+3, r25	; 0x03
    1648:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    164a:	11 96       	adiw	r26, 0x01	; 1
    164c:	8d 91       	ld	r24, X+
    164e:	9c 91       	ld	r25, X
    1650:	12 97       	sbiw	r26, 0x02	; 2
    1652:	e8 17       	cp	r30, r24
    1654:	f9 07       	cpc	r31, r25
    1656:	31 f4       	brne	.+12     	; 0x1664 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1658:	84 81       	ldd	r24, Z+4	; 0x04
    165a:	95 81       	ldd	r25, Z+5	; 0x05
    165c:	12 96       	adiw	r26, 0x02	; 2
    165e:	9c 93       	st	X, r25
    1660:	8e 93       	st	-X, r24
    1662:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1664:	11 86       	std	Z+9, r1	; 0x09
    1666:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1668:	8c 91       	ld	r24, X
    166a:	81 50       	subi	r24, 0x01	; 1
    166c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    166e:	df 91       	pop	r29
    1670:	cf 91       	pop	r28
    1672:	08 95       	ret

00001674 <pxPortInitialiseStack>:

#elif defined( portUSE_TIMER0 )
	portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts

#elif defined( portUSE_TIMER1 )
	portTIMSK &= ~( _BV(OCIE1B)|_BV(OCIE1A)|_BV(TOIE1) );	// disable all Timer1 interrupts
    1674:	31 e1       	ldi	r19, 0x11	; 17
    1676:	fc 01       	movw	r30, r24
    1678:	30 83       	st	Z, r19
    167a:	31 97       	sbiw	r30, 0x01	; 1
    167c:	22 e2       	ldi	r18, 0x22	; 34
    167e:	20 83       	st	Z, r18
    1680:	31 97       	sbiw	r30, 0x01	; 1
    1682:	a3 e3       	ldi	r26, 0x33	; 51
    1684:	a0 83       	st	Z, r26
    1686:	31 97       	sbiw	r30, 0x01	; 1
    1688:	60 83       	st	Z, r22
    168a:	31 97       	sbiw	r30, 0x01	; 1
    168c:	70 83       	st	Z, r23
    168e:	31 97       	sbiw	r30, 0x01	; 1
    1690:	10 82       	st	Z, r1
    1692:	31 97       	sbiw	r30, 0x01	; 1
    1694:	10 82       	st	Z, r1
    1696:	31 97       	sbiw	r30, 0x01	; 1
    1698:	60 e8       	ldi	r22, 0x80	; 128
    169a:	60 83       	st	Z, r22
    169c:	31 97       	sbiw	r30, 0x01	; 1
    169e:	10 82       	st	Z, r1
    16a0:	31 97       	sbiw	r30, 0x01	; 1
    16a2:	10 82       	st	Z, r1
    16a4:	31 97       	sbiw	r30, 0x01	; 1
    16a6:	10 82       	st	Z, r1
    16a8:	31 97       	sbiw	r30, 0x01	; 1
    16aa:	62 e0       	ldi	r22, 0x02	; 2
    16ac:	60 83       	st	Z, r22
    16ae:	31 97       	sbiw	r30, 0x01	; 1
    16b0:	63 e0       	ldi	r22, 0x03	; 3
    16b2:	60 83       	st	Z, r22
    16b4:	31 97       	sbiw	r30, 0x01	; 1
    16b6:	64 e0       	ldi	r22, 0x04	; 4
    16b8:	60 83       	st	Z, r22
    16ba:	31 97       	sbiw	r30, 0x01	; 1
    16bc:	65 e0       	ldi	r22, 0x05	; 5
    16be:	60 83       	st	Z, r22
    16c0:	31 97       	sbiw	r30, 0x01	; 1
    16c2:	66 e0       	ldi	r22, 0x06	; 6
    16c4:	60 83       	st	Z, r22
    16c6:	31 97       	sbiw	r30, 0x01	; 1
    16c8:	67 e0       	ldi	r22, 0x07	; 7
    16ca:	60 83       	st	Z, r22
    16cc:	31 97       	sbiw	r30, 0x01	; 1
    16ce:	68 e0       	ldi	r22, 0x08	; 8
    16d0:	60 83       	st	Z, r22
    16d2:	31 97       	sbiw	r30, 0x01	; 1
    16d4:	69 e0       	ldi	r22, 0x09	; 9
    16d6:	60 83       	st	Z, r22
    16d8:	31 97       	sbiw	r30, 0x01	; 1
    16da:	60 e1       	ldi	r22, 0x10	; 16
    16dc:	60 83       	st	Z, r22
    16de:	31 97       	sbiw	r30, 0x01	; 1
    16e0:	30 83       	st	Z, r19
    16e2:	31 97       	sbiw	r30, 0x01	; 1
    16e4:	32 e1       	ldi	r19, 0x12	; 18
    16e6:	30 83       	st	Z, r19
    16e8:	31 97       	sbiw	r30, 0x01	; 1
    16ea:	33 e1       	ldi	r19, 0x13	; 19
    16ec:	30 83       	st	Z, r19
    16ee:	31 97       	sbiw	r30, 0x01	; 1
    16f0:	34 e1       	ldi	r19, 0x14	; 20
    16f2:	30 83       	st	Z, r19
    16f4:	31 97       	sbiw	r30, 0x01	; 1
    16f6:	35 e1       	ldi	r19, 0x15	; 21
    16f8:	30 83       	st	Z, r19
    16fa:	31 97       	sbiw	r30, 0x01	; 1
    16fc:	36 e1       	ldi	r19, 0x16	; 22
    16fe:	30 83       	st	Z, r19
    1700:	31 97       	sbiw	r30, 0x01	; 1
    1702:	37 e1       	ldi	r19, 0x17	; 23
    1704:	30 83       	st	Z, r19
    1706:	31 97       	sbiw	r30, 0x01	; 1
    1708:	38 e1       	ldi	r19, 0x18	; 24
    170a:	30 83       	st	Z, r19
    170c:	31 97       	sbiw	r30, 0x01	; 1
    170e:	39 e1       	ldi	r19, 0x19	; 25
    1710:	30 83       	st	Z, r19
    1712:	31 97       	sbiw	r30, 0x01	; 1
    1714:	30 e2       	ldi	r19, 0x20	; 32
    1716:	30 83       	st	Z, r19
    1718:	31 97       	sbiw	r30, 0x01	; 1
    171a:	31 e2       	ldi	r19, 0x21	; 33
    171c:	30 83       	st	Z, r19
    171e:	31 97       	sbiw	r30, 0x01	; 1
    1720:	20 83       	st	Z, r18
    1722:	31 97       	sbiw	r30, 0x01	; 1
    1724:	23 e2       	ldi	r18, 0x23	; 35
    1726:	20 83       	st	Z, r18
    1728:	31 97       	sbiw	r30, 0x01	; 1
    172a:	40 83       	st	Z, r20
    172c:	31 97       	sbiw	r30, 0x01	; 1
    172e:	50 83       	st	Z, r21
    1730:	31 97       	sbiw	r30, 0x01	; 1
    1732:	26 e2       	ldi	r18, 0x26	; 38
    1734:	20 83       	st	Z, r18
    1736:	31 97       	sbiw	r30, 0x01	; 1
    1738:	27 e2       	ldi	r18, 0x27	; 39
    173a:	20 83       	st	Z, r18
    173c:	31 97       	sbiw	r30, 0x01	; 1
    173e:	28 e2       	ldi	r18, 0x28	; 40
    1740:	20 83       	st	Z, r18
    1742:	31 97       	sbiw	r30, 0x01	; 1
    1744:	29 e2       	ldi	r18, 0x29	; 41
    1746:	20 83       	st	Z, r18
    1748:	31 97       	sbiw	r30, 0x01	; 1
    174a:	20 e3       	ldi	r18, 0x30	; 48
    174c:	20 83       	st	Z, r18
    174e:	31 97       	sbiw	r30, 0x01	; 1
    1750:	21 e3       	ldi	r18, 0x31	; 49
    1752:	20 83       	st	Z, r18
    1754:	89 97       	sbiw	r24, 0x29	; 41
    1756:	08 95       	ret

00001758 <xPortStartScheduler>:
    1758:	88 ec       	ldi	r24, 0xC8	; 200
    175a:	90 e0       	ldi	r25, 0x00	; 0
    175c:	90 93 62 16 	sts	0x1662, r25	; 0x801662 <portTickRateHz+0x1>
    1760:	80 93 61 16 	sts	0x1661, r24	; 0x801661 <portTickRateHz>
    1764:	90 93 64 16 	sts	0x1664, r25	; 0x801664 <ticksRemainingInSec+0x1>
    1768:	80 93 63 16 	sts	0x1663, r24	; 0x801663 <ticksRemainingInSec>
    176c:	84 e0       	ldi	r24, 0x04	; 4
    176e:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    1772:	81 ee       	ldi	r24, 0xE1	; 225
    1774:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
    1778:	8b e0       	ldi	r24, 0x0B	; 11
    177a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
    177e:	ef e6       	ldi	r30, 0x6F	; 111
    1780:	f0 e0       	ldi	r31, 0x00	; 0
    1782:	80 81       	ld	r24, Z
    1784:	82 60       	ori	r24, 0x02	; 2
    1786:	80 83       	st	Z, r24
    1788:	a0 91 fd 15 	lds	r26, 0x15FD	; 0x8015fd <pxCurrentTCB>
    178c:	b0 91 fe 15 	lds	r27, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    1790:	cd 91       	ld	r28, X+
    1792:	cd bf       	out	0x3d, r28	; 61
    1794:	dd 91       	ld	r29, X+
    1796:	de bf       	out	0x3e, r29	; 62
    1798:	ff 91       	pop	r31
    179a:	ef 91       	pop	r30
    179c:	df 91       	pop	r29
    179e:	cf 91       	pop	r28
    17a0:	bf 91       	pop	r27
    17a2:	af 91       	pop	r26
    17a4:	9f 91       	pop	r25
    17a6:	8f 91       	pop	r24
    17a8:	7f 91       	pop	r23
    17aa:	6f 91       	pop	r22
    17ac:	5f 91       	pop	r21
    17ae:	4f 91       	pop	r20
    17b0:	3f 91       	pop	r19
    17b2:	2f 91       	pop	r18
    17b4:	1f 91       	pop	r17
    17b6:	0f 91       	pop	r16
    17b8:	ff 90       	pop	r15
    17ba:	ef 90       	pop	r14
    17bc:	df 90       	pop	r13
    17be:	cf 90       	pop	r12
    17c0:	bf 90       	pop	r11
    17c2:	af 90       	pop	r10
    17c4:	9f 90       	pop	r9
    17c6:	8f 90       	pop	r8
    17c8:	7f 90       	pop	r7
    17ca:	6f 90       	pop	r6
    17cc:	5f 90       	pop	r5
    17ce:	4f 90       	pop	r4
    17d0:	3f 90       	pop	r3
    17d2:	2f 90       	pop	r2
    17d4:	1f 90       	pop	r1
    17d6:	0f 90       	pop	r0
    17d8:	0c be       	out	0x3c, r0	; 60
    17da:	0f 90       	pop	r0
    17dc:	0b be       	out	0x3b, r0	; 59
    17de:	0f 90       	pop	r0
    17e0:	0f be       	out	0x3f, r0	; 63
    17e2:	0f 90       	pop	r0
    17e4:	08 95       	ret
    17e6:	81 e0       	ldi	r24, 0x01	; 1
    17e8:	08 95       	ret

000017ea <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    17ea:	0f 92       	push	r0
    17ec:	0f b6       	in	r0, 0x3f	; 63
    17ee:	f8 94       	cli
    17f0:	0f 92       	push	r0
    17f2:	0b b6       	in	r0, 0x3b	; 59
    17f4:	0f 92       	push	r0
    17f6:	0c b6       	in	r0, 0x3c	; 60
    17f8:	0f 92       	push	r0
    17fa:	1f 92       	push	r1
    17fc:	11 24       	eor	r1, r1
    17fe:	2f 92       	push	r2
    1800:	3f 92       	push	r3
    1802:	4f 92       	push	r4
    1804:	5f 92       	push	r5
    1806:	6f 92       	push	r6
    1808:	7f 92       	push	r7
    180a:	8f 92       	push	r8
    180c:	9f 92       	push	r9
    180e:	af 92       	push	r10
    1810:	bf 92       	push	r11
    1812:	cf 92       	push	r12
    1814:	df 92       	push	r13
    1816:	ef 92       	push	r14
    1818:	ff 92       	push	r15
    181a:	0f 93       	push	r16
    181c:	1f 93       	push	r17
    181e:	2f 93       	push	r18
    1820:	3f 93       	push	r19
    1822:	4f 93       	push	r20
    1824:	5f 93       	push	r21
    1826:	6f 93       	push	r22
    1828:	7f 93       	push	r23
    182a:	8f 93       	push	r24
    182c:	9f 93       	push	r25
    182e:	af 93       	push	r26
    1830:	bf 93       	push	r27
    1832:	cf 93       	push	r28
    1834:	df 93       	push	r29
    1836:	ef 93       	push	r30
    1838:	ff 93       	push	r31
    183a:	a0 91 fd 15 	lds	r26, 0x15FD	; 0x8015fd <pxCurrentTCB>
    183e:	b0 91 fe 15 	lds	r27, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    1842:	0d b6       	in	r0, 0x3d	; 61
    1844:	0d 92       	st	X+, r0
    1846:	0e b6       	in	r0, 0x3e	; 62
    1848:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    184a:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    184e:	a0 91 fd 15 	lds	r26, 0x15FD	; 0x8015fd <pxCurrentTCB>
    1852:	b0 91 fe 15 	lds	r27, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    1856:	cd 91       	ld	r28, X+
    1858:	cd bf       	out	0x3d, r28	; 61
    185a:	dd 91       	ld	r29, X+
    185c:	de bf       	out	0x3e, r29	; 62
    185e:	ff 91       	pop	r31
    1860:	ef 91       	pop	r30
    1862:	df 91       	pop	r29
    1864:	cf 91       	pop	r28
    1866:	bf 91       	pop	r27
    1868:	af 91       	pop	r26
    186a:	9f 91       	pop	r25
    186c:	8f 91       	pop	r24
    186e:	7f 91       	pop	r23
    1870:	6f 91       	pop	r22
    1872:	5f 91       	pop	r21
    1874:	4f 91       	pop	r20
    1876:	3f 91       	pop	r19
    1878:	2f 91       	pop	r18
    187a:	1f 91       	pop	r17
    187c:	0f 91       	pop	r16
    187e:	ff 90       	pop	r15
    1880:	ef 90       	pop	r14
    1882:	df 90       	pop	r13
    1884:	cf 90       	pop	r12
    1886:	bf 90       	pop	r11
    1888:	af 90       	pop	r10
    188a:	9f 90       	pop	r9
    188c:	8f 90       	pop	r8
    188e:	7f 90       	pop	r7
    1890:	6f 90       	pop	r6
    1892:	5f 90       	pop	r5
    1894:	4f 90       	pop	r4
    1896:	3f 90       	pop	r3
    1898:	2f 90       	pop	r2
    189a:	1f 90       	pop	r1
    189c:	0f 90       	pop	r0
    189e:	0c be       	out	0x3c, r0	; 60
    18a0:	0f 90       	pop	r0
    18a2:	0b be       	out	0x3b, r0	; 59
    18a4:	0f 90       	pop	r0
    18a6:	0f be       	out	0x3f, r0	; 63
    18a8:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    18aa:	08 95       	ret

000018ac <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    18ac:	0f 92       	push	r0
    18ae:	0f b6       	in	r0, 0x3f	; 63
    18b0:	f8 94       	cli
    18b2:	0f 92       	push	r0
    18b4:	0b b6       	in	r0, 0x3b	; 59
    18b6:	0f 92       	push	r0
    18b8:	0c b6       	in	r0, 0x3c	; 60
    18ba:	0f 92       	push	r0
    18bc:	1f 92       	push	r1
    18be:	11 24       	eor	r1, r1
    18c0:	2f 92       	push	r2
    18c2:	3f 92       	push	r3
    18c4:	4f 92       	push	r4
    18c6:	5f 92       	push	r5
    18c8:	6f 92       	push	r6
    18ca:	7f 92       	push	r7
    18cc:	8f 92       	push	r8
    18ce:	9f 92       	push	r9
    18d0:	af 92       	push	r10
    18d2:	bf 92       	push	r11
    18d4:	cf 92       	push	r12
    18d6:	df 92       	push	r13
    18d8:	ef 92       	push	r14
    18da:	ff 92       	push	r15
    18dc:	0f 93       	push	r16
    18de:	1f 93       	push	r17
    18e0:	2f 93       	push	r18
    18e2:	3f 93       	push	r19
    18e4:	4f 93       	push	r20
    18e6:	5f 93       	push	r21
    18e8:	6f 93       	push	r22
    18ea:	7f 93       	push	r23
    18ec:	8f 93       	push	r24
    18ee:	9f 93       	push	r25
    18f0:	af 93       	push	r26
    18f2:	bf 93       	push	r27
    18f4:	cf 93       	push	r28
    18f6:	df 93       	push	r29
    18f8:	ef 93       	push	r30
    18fa:	ff 93       	push	r31
    18fc:	a0 91 fd 15 	lds	r26, 0x15FD	; 0x8015fd <pxCurrentTCB>
    1900:	b0 91 fe 15 	lds	r27, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    1904:	0d b6       	in	r0, 0x3d	; 61
    1906:	0d 92       	st	X+, r0
    1908:	0e b6       	in	r0, 0x3e	; 62
    190a:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    190c:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    190e:	80 91 63 16 	lds	r24, 0x1663	; 0x801663 <ticksRemainingInSec>
    1912:	90 91 64 16 	lds	r25, 0x1664	; 0x801664 <ticksRemainingInSec+0x1>
    1916:	01 97       	sbiw	r24, 0x01	; 1
    1918:	90 93 64 16 	sts	0x1664, r25	; 0x801664 <ticksRemainingInSec+0x1>
    191c:	80 93 63 16 	sts	0x1663, r24	; 0x801663 <ticksRemainingInSec>
    1920:	89 2b       	or	r24, r25
    1922:	51 f4       	brne	.+20     	; 0x1938 <vPortYieldFromTick+0x8c>
	{
		system_tick();
    1924:	0e 94 15 02 	call	0x42a	; 0x42a <system_tick>
		ticksRemainingInSec = portTickRateHz;
    1928:	80 91 61 16 	lds	r24, 0x1661	; 0x801661 <portTickRateHz>
    192c:	90 91 62 16 	lds	r25, 0x1662	; 0x801662 <portTickRateHz+0x1>
    1930:	90 93 64 16 	sts	0x1664, r25	; 0x801664 <ticksRemainingInSec+0x1>
    1934:	80 93 63 16 	sts	0x1663, r24	; 0x801663 <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    1938:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <xTaskIncrementTick>
    193c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    193e:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    1942:	a0 91 fd 15 	lds	r26, 0x15FD	; 0x8015fd <pxCurrentTCB>
    1946:	b0 91 fe 15 	lds	r27, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    194a:	cd 91       	ld	r28, X+
    194c:	cd bf       	out	0x3d, r28	; 61
    194e:	dd 91       	ld	r29, X+
    1950:	de bf       	out	0x3e, r29	; 62
    1952:	ff 91       	pop	r31
    1954:	ef 91       	pop	r30
    1956:	df 91       	pop	r29
    1958:	cf 91       	pop	r28
    195a:	bf 91       	pop	r27
    195c:	af 91       	pop	r26
    195e:	9f 91       	pop	r25
    1960:	8f 91       	pop	r24
    1962:	7f 91       	pop	r23
    1964:	6f 91       	pop	r22
    1966:	5f 91       	pop	r21
    1968:	4f 91       	pop	r20
    196a:	3f 91       	pop	r19
    196c:	2f 91       	pop	r18
    196e:	1f 91       	pop	r17
    1970:	0f 91       	pop	r16
    1972:	ff 90       	pop	r15
    1974:	ef 90       	pop	r14
    1976:	df 90       	pop	r13
    1978:	cf 90       	pop	r12
    197a:	bf 90       	pop	r11
    197c:	af 90       	pop	r10
    197e:	9f 90       	pop	r9
    1980:	8f 90       	pop	r8
    1982:	7f 90       	pop	r7
    1984:	6f 90       	pop	r6
    1986:	5f 90       	pop	r5
    1988:	4f 90       	pop	r4
    198a:	3f 90       	pop	r3
    198c:	2f 90       	pop	r2
    198e:	1f 90       	pop	r1
    1990:	0f 90       	pop	r0
    1992:	0c be       	out	0x3c, r0	; 60
    1994:	0f 90       	pop	r0
    1996:	0b be       	out	0x3b, r0	; 59
    1998:	0f 90       	pop	r0
    199a:	0f be       	out	0x3f, r0	; 63
    199c:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    199e:	08 95       	ret

000019a0 <__vector_17>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    19a0:	85 df       	rcall	.-246    	; 0x18ac <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    19a2:	18 95       	reti

000019a4 <xQueueGenericCreate>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19a4:	0f 93       	push	r16
    19a6:	1f 93       	push	r17
    19a8:	cf 93       	push	r28
    19aa:	df 93       	push	r29
    19ac:	08 2f       	mov	r16, r24
    19ae:	16 2f       	mov	r17, r22
    19b0:	66 23       	and	r22, r22
    19b2:	09 f4       	brne	.+2      	; 0x19b6 <xQueueGenericCreate+0x12>
    19b4:	38 c0       	rjmp	.+112    	; 0x1a26 <xQueueGenericCreate+0x82>
    19b6:	86 9f       	mul	r24, r22
    19b8:	c0 01       	movw	r24, r0
    19ba:	11 24       	eor	r1, r1
    19bc:	80 96       	adiw	r24, 0x20	; 32
    19be:	9a dd       	rcall	.-1228   	; 0x14f4 <pvPortMalloc>
    19c0:	ec 01       	movw	r28, r24
    19c2:	00 97       	sbiw	r24, 0x00	; 0
    19c4:	21 f4       	brne	.+8      	; 0x19ce <xQueueGenericCreate+0x2a>
    19c6:	36 c0       	rjmp	.+108    	; 0x1a34 <xQueueGenericCreate+0x90>
    19c8:	d9 83       	std	Y+1, r29	; 0x01
    19ca:	c8 83       	st	Y, r28
    19cc:	03 c0       	rjmp	.+6      	; 0x19d4 <xQueueGenericCreate+0x30>
    19ce:	4f 96       	adiw	r24, 0x1f	; 31
    19d0:	99 83       	std	Y+1, r25	; 0x01
    19d2:	88 83       	st	Y, r24
    19d4:	0b 8f       	std	Y+27, r16	; 0x1b
    19d6:	1c 8f       	std	Y+28, r17	; 0x1c
    19d8:	0f b6       	in	r0, 0x3f	; 63
    19da:	f8 94       	cli
    19dc:	0f 92       	push	r0
    19de:	48 81       	ld	r20, Y
    19e0:	59 81       	ldd	r21, Y+1	; 0x01
    19e2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    19e4:	30 e0       	ldi	r19, 0x00	; 0
    19e6:	6b 8d       	ldd	r22, Y+27	; 0x1b
    19e8:	62 9f       	mul	r22, r18
    19ea:	c0 01       	movw	r24, r0
    19ec:	63 9f       	mul	r22, r19
    19ee:	90 0d       	add	r25, r0
    19f0:	11 24       	eor	r1, r1
    19f2:	ba 01       	movw	r22, r20
    19f4:	68 0f       	add	r22, r24
    19f6:	79 1f       	adc	r23, r25
    19f8:	7b 83       	std	Y+3, r23	; 0x03
    19fa:	6a 83       	std	Y+2, r22	; 0x02
    19fc:	1a 8e       	std	Y+26, r1	; 0x1a
    19fe:	5d 83       	std	Y+5, r21	; 0x05
    1a00:	4c 83       	std	Y+4, r20	; 0x04
    1a02:	82 1b       	sub	r24, r18
    1a04:	93 0b       	sbc	r25, r19
    1a06:	84 0f       	add	r24, r20
    1a08:	95 1f       	adc	r25, r21
    1a0a:	9f 83       	std	Y+7, r25	; 0x07
    1a0c:	8e 83       	std	Y+6, r24	; 0x06
    1a0e:	8f ef       	ldi	r24, 0xFF	; 255
    1a10:	8d 8f       	std	Y+29, r24	; 0x1d
    1a12:	8e 8f       	std	Y+30, r24	; 0x1e
    1a14:	ce 01       	movw	r24, r28
    1a16:	08 96       	adiw	r24, 0x08	; 8
    1a18:	a3 dd       	rcall	.-1210   	; 0x1560 <vListInitialise>
    1a1a:	ce 01       	movw	r24, r28
    1a1c:	41 96       	adiw	r24, 0x11	; 17
    1a1e:	a0 dd       	rcall	.-1216   	; 0x1560 <vListInitialise>
    1a20:	0f 90       	pop	r0
    1a22:	0f be       	out	0x3f, r0	; 63
    1a24:	07 c0       	rjmp	.+14     	; 0x1a34 <xQueueGenericCreate+0x90>
    1a26:	8f e1       	ldi	r24, 0x1F	; 31
    1a28:	90 e0       	ldi	r25, 0x00	; 0
    1a2a:	64 dd       	rcall	.-1336   	; 0x14f4 <pvPortMalloc>
    1a2c:	ec 01       	movw	r28, r24
    1a2e:	89 2b       	or	r24, r25
    1a30:	09 f0       	breq	.+2      	; 0x1a34 <xQueueGenericCreate+0x90>
    1a32:	ca cf       	rjmp	.-108    	; 0x19c8 <xQueueGenericCreate+0x24>
    1a34:	ce 01       	movw	r24, r28
    1a36:	df 91       	pop	r29
    1a38:	cf 91       	pop	r28
    1a3a:	1f 91       	pop	r17
    1a3c:	0f 91       	pop	r16
    1a3e:	08 95       	ret

00001a40 <xQueueGenericSend>:
    1a40:	6f 92       	push	r6
    1a42:	7f 92       	push	r7
    1a44:	8f 92       	push	r8
    1a46:	9f 92       	push	r9
    1a48:	af 92       	push	r10
    1a4a:	bf 92       	push	r11
    1a4c:	cf 92       	push	r12
    1a4e:	df 92       	push	r13
    1a50:	ef 92       	push	r14
    1a52:	ff 92       	push	r15
    1a54:	0f 93       	push	r16
    1a56:	1f 93       	push	r17
    1a58:	cf 93       	push	r28
    1a5a:	df 93       	push	r29
    1a5c:	00 d0       	rcall	.+0      	; 0x1a5e <xQueueGenericSend+0x1e>
    1a5e:	1f 92       	push	r1
    1a60:	1f 92       	push	r1
    1a62:	cd b7       	in	r28, 0x3d	; 61
    1a64:	de b7       	in	r29, 0x3e	; 62
    1a66:	8c 01       	movw	r16, r24
    1a68:	5b 01       	movw	r10, r22
    1a6a:	5d 83       	std	Y+5, r21	; 0x05
    1a6c:	4c 83       	std	Y+4, r20	; 0x04
    1a6e:	72 2e       	mov	r7, r18
    1a70:	81 2c       	mov	r8, r1
    1a72:	66 24       	eor	r6, r6
    1a74:	63 94       	inc	r6
    1a76:	99 24       	eor	r9, r9
    1a78:	9a 94       	dec	r9
    1a7a:	7c 01       	movw	r14, r24
    1a7c:	88 e0       	ldi	r24, 0x08	; 8
    1a7e:	e8 0e       	add	r14, r24
    1a80:	f1 1c       	adc	r15, r1
    1a82:	68 01       	movw	r12, r16
    1a84:	e1 e1       	ldi	r30, 0x11	; 17
    1a86:	ce 0e       	add	r12, r30
    1a88:	d1 1c       	adc	r13, r1
    1a8a:	0f b6       	in	r0, 0x3f	; 63
    1a8c:	f8 94       	cli
    1a8e:	0f 92       	push	r0
    1a90:	f8 01       	movw	r30, r16
    1a92:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a94:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a96:	98 17       	cp	r25, r24
    1a98:	20 f0       	brcs	.+8      	; 0x1aa2 <xQueueGenericSend+0x62>
    1a9a:	f2 e0       	ldi	r31, 0x02	; 2
    1a9c:	7f 12       	cpse	r7, r31
    1a9e:	6e c0       	rjmp	.+220    	; 0x1b7c <xQueueGenericSend+0x13c>
    1aa0:	79 c1       	rjmp	.+754    	; 0x1d94 <xQueueGenericSend+0x354>
    1aa2:	f8 01       	movw	r30, r16
    1aa4:	44 8d       	ldd	r20, Z+28	; 0x1c
    1aa6:	41 11       	cpse	r20, r1
    1aa8:	15 c0       	rjmp	.+42     	; 0x1ad4 <xQueueGenericSend+0x94>
    1aaa:	f8 01       	movw	r30, r16
    1aac:	80 81       	ld	r24, Z
    1aae:	91 81       	ldd	r25, Z+1	; 0x01
    1ab0:	89 2b       	or	r24, r25
    1ab2:	09 f0       	breq	.+2      	; 0x1ab6 <xQueueGenericSend+0x76>
    1ab4:	75 c1       	rjmp	.+746    	; 0x1da0 <xQueueGenericSend+0x360>
    1ab6:	82 81       	ldd	r24, Z+2	; 0x02
    1ab8:	93 81       	ldd	r25, Z+3	; 0x03
    1aba:	0e 94 9b 19 	call	0x3336	; 0x3336 <xTaskPriorityDisinherit>
    1abe:	f8 01       	movw	r30, r16
    1ac0:	13 82       	std	Z+3, r1	; 0x03
    1ac2:	12 82       	std	Z+2, r1	; 0x02
    1ac4:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ac6:	9f 5f       	subi	r25, 0xFF	; 255
    1ac8:	92 8f       	std	Z+26, r25	; 0x1a
    1aca:	91 89       	ldd	r25, Z+17	; 0x11
    1acc:	99 23       	and	r25, r25
    1ace:	09 f4       	brne	.+2      	; 0x1ad2 <xQueueGenericSend+0x92>
    1ad0:	4f c0       	rjmp	.+158    	; 0x1b70 <xQueueGenericSend+0x130>
    1ad2:	46 c0       	rjmp	.+140    	; 0x1b60 <xQueueGenericSend+0x120>
    1ad4:	71 10       	cpse	r7, r1
    1ad6:	1a c0       	rjmp	.+52     	; 0x1b0c <xQueueGenericSend+0xcc>
    1ad8:	50 e0       	ldi	r21, 0x00	; 0
    1ada:	b5 01       	movw	r22, r10
    1adc:	f8 01       	movw	r30, r16
    1ade:	84 81       	ldd	r24, Z+4	; 0x04
    1ae0:	95 81       	ldd	r25, Z+5	; 0x05
    1ae2:	0e 94 25 20 	call	0x404a	; 0x404a <memcpy>
    1ae6:	f8 01       	movw	r30, r16
    1ae8:	24 8d       	ldd	r18, Z+28	; 0x1c
    1aea:	84 81       	ldd	r24, Z+4	; 0x04
    1aec:	95 81       	ldd	r25, Z+5	; 0x05
    1aee:	82 0f       	add	r24, r18
    1af0:	91 1d       	adc	r25, r1
    1af2:	95 83       	std	Z+5, r25	; 0x05
    1af4:	84 83       	std	Z+4, r24	; 0x04
    1af6:	22 81       	ldd	r18, Z+2	; 0x02
    1af8:	33 81       	ldd	r19, Z+3	; 0x03
    1afa:	82 17       	cp	r24, r18
    1afc:	93 07       	cpc	r25, r19
    1afe:	08 f4       	brcc	.+2      	; 0x1b02 <xQueueGenericSend+0xc2>
    1b00:	4f c1       	rjmp	.+670    	; 0x1da0 <xQueueGenericSend+0x360>
    1b02:	80 81       	ld	r24, Z
    1b04:	91 81       	ldd	r25, Z+1	; 0x01
    1b06:	95 83       	std	Z+5, r25	; 0x05
    1b08:	84 83       	std	Z+4, r24	; 0x04
    1b0a:	4a c1       	rjmp	.+660    	; 0x1da0 <xQueueGenericSend+0x360>
    1b0c:	50 e0       	ldi	r21, 0x00	; 0
    1b0e:	b5 01       	movw	r22, r10
    1b10:	f8 01       	movw	r30, r16
    1b12:	86 81       	ldd	r24, Z+6	; 0x06
    1b14:	97 81       	ldd	r25, Z+7	; 0x07
    1b16:	0e 94 25 20 	call	0x404a	; 0x404a <memcpy>
    1b1a:	f8 01       	movw	r30, r16
    1b1c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b1e:	90 e0       	ldi	r25, 0x00	; 0
    1b20:	91 95       	neg	r25
    1b22:	81 95       	neg	r24
    1b24:	91 09       	sbc	r25, r1
    1b26:	26 81       	ldd	r18, Z+6	; 0x06
    1b28:	37 81       	ldd	r19, Z+7	; 0x07
    1b2a:	28 0f       	add	r18, r24
    1b2c:	39 1f       	adc	r19, r25
    1b2e:	37 83       	std	Z+7, r19	; 0x07
    1b30:	26 83       	std	Z+6, r18	; 0x06
    1b32:	40 81       	ld	r20, Z
    1b34:	51 81       	ldd	r21, Z+1	; 0x01
    1b36:	24 17       	cp	r18, r20
    1b38:	35 07       	cpc	r19, r21
    1b3a:	30 f4       	brcc	.+12     	; 0x1b48 <xQueueGenericSend+0x108>
    1b3c:	22 81       	ldd	r18, Z+2	; 0x02
    1b3e:	33 81       	ldd	r19, Z+3	; 0x03
    1b40:	82 0f       	add	r24, r18
    1b42:	93 1f       	adc	r25, r19
    1b44:	97 83       	std	Z+7, r25	; 0x07
    1b46:	86 83       	std	Z+6, r24	; 0x06
    1b48:	f2 e0       	ldi	r31, 0x02	; 2
    1b4a:	7f 12       	cpse	r7, r31
    1b4c:	29 c1       	rjmp	.+594    	; 0x1da0 <xQueueGenericSend+0x360>
    1b4e:	f8 01       	movw	r30, r16
    1b50:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b52:	88 23       	and	r24, r24
    1b54:	09 f4       	brne	.+2      	; 0x1b58 <xQueueGenericSend+0x118>
    1b56:	24 c1       	rjmp	.+584    	; 0x1da0 <xQueueGenericSend+0x360>
    1b58:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b5a:	81 50       	subi	r24, 0x01	; 1
    1b5c:	82 8f       	std	Z+26, r24	; 0x1a
    1b5e:	20 c1       	rjmp	.+576    	; 0x1da0 <xQueueGenericSend+0x360>
    1b60:	c8 01       	movw	r24, r16
    1b62:	41 96       	adiw	r24, 0x11	; 17
    1b64:	0e 94 a7 18 	call	0x314e	; 0x314e <xTaskRemoveFromEventList>
    1b68:	81 30       	cpi	r24, 0x01	; 1
    1b6a:	21 f4       	brne	.+8      	; 0x1b74 <xQueueGenericSend+0x134>
    1b6c:	3e de       	rcall	.-900    	; 0x17ea <vPortYield>
    1b6e:	02 c0       	rjmp	.+4      	; 0x1b74 <xQueueGenericSend+0x134>
    1b70:	81 11       	cpse	r24, r1
    1b72:	3b de       	rcall	.-906    	; 0x17ea <vPortYield>
    1b74:	0f 90       	pop	r0
    1b76:	0f be       	out	0x3f, r0	; 63
    1b78:	81 e0       	ldi	r24, 0x01	; 1
    1b7a:	1a c1       	rjmp	.+564    	; 0x1db0 <xQueueGenericSend+0x370>
    1b7c:	8c 81       	ldd	r24, Y+4	; 0x04
    1b7e:	9d 81       	ldd	r25, Y+5	; 0x05
    1b80:	89 2b       	or	r24, r25
    1b82:	21 f4       	brne	.+8      	; 0x1b8c <xQueueGenericSend+0x14c>
    1b84:	0f 90       	pop	r0
    1b86:	0f be       	out	0x3f, r0	; 63
    1b88:	80 e0       	ldi	r24, 0x00	; 0
    1b8a:	12 c1       	rjmp	.+548    	; 0x1db0 <xQueueGenericSend+0x370>
    1b8c:	81 10       	cpse	r8, r1
    1b8e:	05 c0       	rjmp	.+10     	; 0x1b9a <xQueueGenericSend+0x15a>
    1b90:	ce 01       	movw	r24, r28
    1b92:	01 96       	adiw	r24, 0x01	; 1
    1b94:	0e 94 ef 18 	call	0x31de	; 0x31de <vTaskSetTimeOutState>
    1b98:	86 2c       	mov	r8, r6
    1b9a:	0f 90       	pop	r0
    1b9c:	0f be       	out	0x3f, r0	; 63
    1b9e:	dc d7       	rcall	.+4024   	; 0x2b58 <vTaskSuspendAll>
    1ba0:	0f b6       	in	r0, 0x3f	; 63
    1ba2:	f8 94       	cli
    1ba4:	0f 92       	push	r0
    1ba6:	f8 01       	movw	r30, r16
    1ba8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1baa:	8f 3f       	cpi	r24, 0xFF	; 255
    1bac:	09 f4       	brne	.+2      	; 0x1bb0 <xQueueGenericSend+0x170>
    1bae:	15 8e       	std	Z+29, r1	; 0x1d
    1bb0:	f8 01       	movw	r30, r16
    1bb2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bb4:	8f 3f       	cpi	r24, 0xFF	; 255
    1bb6:	09 f4       	brne	.+2      	; 0x1bba <xQueueGenericSend+0x17a>
    1bb8:	16 8e       	std	Z+30, r1	; 0x1e
    1bba:	0f 90       	pop	r0
    1bbc:	0f be       	out	0x3f, r0	; 63
    1bbe:	be 01       	movw	r22, r28
    1bc0:	6c 5f       	subi	r22, 0xFC	; 252
    1bc2:	7f 4f       	sbci	r23, 0xFF	; 255
    1bc4:	ce 01       	movw	r24, r28
    1bc6:	01 96       	adiw	r24, 0x01	; 1
    1bc8:	0e 94 fa 18 	call	0x31f4	; 0x31f4 <xTaskCheckForTimeOut>
    1bcc:	81 11       	cpse	r24, r1
    1bce:	94 c0       	rjmp	.+296    	; 0x1cf8 <xQueueGenericSend+0x2b8>
    1bd0:	0f b6       	in	r0, 0x3f	; 63
    1bd2:	f8 94       	cli
    1bd4:	0f 92       	push	r0
    1bd6:	f8 01       	movw	r30, r16
    1bd8:	92 8d       	ldd	r25, Z+26	; 0x1a
    1bda:	83 8d       	ldd	r24, Z+27	; 0x1b
    1bdc:	0f 90       	pop	r0
    1bde:	0f be       	out	0x3f, r0	; 63
    1be0:	98 13       	cpse	r25, r24
    1be2:	49 c0       	rjmp	.+146    	; 0x1c76 <xQueueGenericSend+0x236>
    1be4:	6c 81       	ldd	r22, Y+4	; 0x04
    1be6:	7d 81       	ldd	r23, Y+5	; 0x05
    1be8:	c7 01       	movw	r24, r14
    1bea:	0e 94 4c 18 	call	0x3098	; 0x3098 <vTaskPlaceOnEventList>
    1bee:	0f b6       	in	r0, 0x3f	; 63
    1bf0:	f8 94       	cli
    1bf2:	0f 92       	push	r0
    1bf4:	f8 01       	movw	r30, r16
    1bf6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bf8:	18 16       	cp	r1, r24
    1bfa:	ac f4       	brge	.+42     	; 0x1c26 <xQueueGenericSend+0x1e6>
    1bfc:	81 89       	ldd	r24, Z+17	; 0x11
    1bfe:	81 11       	cpse	r24, r1
    1c00:	05 c0       	rjmp	.+10     	; 0x1c0c <xQueueGenericSend+0x1cc>
    1c02:	11 c0       	rjmp	.+34     	; 0x1c26 <xQueueGenericSend+0x1e6>
    1c04:	f8 01       	movw	r30, r16
    1c06:	81 89       	ldd	r24, Z+17	; 0x11
    1c08:	88 23       	and	r24, r24
    1c0a:	69 f0       	breq	.+26     	; 0x1c26 <xQueueGenericSend+0x1e6>
    1c0c:	c6 01       	movw	r24, r12
    1c0e:	0e 94 a7 18 	call	0x314e	; 0x314e <xTaskRemoveFromEventList>
    1c12:	81 11       	cpse	r24, r1
    1c14:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskMissedYield>
    1c18:	f8 01       	movw	r30, r16
    1c1a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c1c:	81 50       	subi	r24, 0x01	; 1
    1c1e:	86 8f       	std	Z+30, r24	; 0x1e
    1c20:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c22:	18 16       	cp	r1, r24
    1c24:	7c f3       	brlt	.-34     	; 0x1c04 <xQueueGenericSend+0x1c4>
    1c26:	f8 01       	movw	r30, r16
    1c28:	96 8e       	std	Z+30, r9	; 0x1e
    1c2a:	0f 90       	pop	r0
    1c2c:	0f be       	out	0x3f, r0	; 63
    1c2e:	0f b6       	in	r0, 0x3f	; 63
    1c30:	f8 94       	cli
    1c32:	0f 92       	push	r0
    1c34:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c36:	18 16       	cp	r1, r24
    1c38:	ac f4       	brge	.+42     	; 0x1c64 <xQueueGenericSend+0x224>
    1c3a:	80 85       	ldd	r24, Z+8	; 0x08
    1c3c:	81 11       	cpse	r24, r1
    1c3e:	05 c0       	rjmp	.+10     	; 0x1c4a <xQueueGenericSend+0x20a>
    1c40:	11 c0       	rjmp	.+34     	; 0x1c64 <xQueueGenericSend+0x224>
    1c42:	f8 01       	movw	r30, r16
    1c44:	80 85       	ldd	r24, Z+8	; 0x08
    1c46:	88 23       	and	r24, r24
    1c48:	69 f0       	breq	.+26     	; 0x1c64 <xQueueGenericSend+0x224>
    1c4a:	c7 01       	movw	r24, r14
    1c4c:	0e 94 a7 18 	call	0x314e	; 0x314e <xTaskRemoveFromEventList>
    1c50:	81 11       	cpse	r24, r1
    1c52:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskMissedYield>
    1c56:	f8 01       	movw	r30, r16
    1c58:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c5a:	81 50       	subi	r24, 0x01	; 1
    1c5c:	85 8f       	std	Z+29, r24	; 0x1d
    1c5e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c60:	18 16       	cp	r1, r24
    1c62:	7c f3       	brlt	.-34     	; 0x1c42 <xQueueGenericSend+0x202>
    1c64:	f8 01       	movw	r30, r16
    1c66:	95 8e       	std	Z+29, r9	; 0x1d
    1c68:	0f 90       	pop	r0
    1c6a:	0f be       	out	0x3f, r0	; 63
    1c6c:	7b d7       	rcall	.+3830   	; 0x2b64 <xTaskResumeAll>
    1c6e:	81 11       	cpse	r24, r1
    1c70:	0c cf       	rjmp	.-488    	; 0x1a8a <xQueueGenericSend+0x4a>
    1c72:	bb dd       	rcall	.-1162   	; 0x17ea <vPortYield>
    1c74:	0a cf       	rjmp	.-492    	; 0x1a8a <xQueueGenericSend+0x4a>
    1c76:	0f b6       	in	r0, 0x3f	; 63
    1c78:	f8 94       	cli
    1c7a:	0f 92       	push	r0
    1c7c:	f8 01       	movw	r30, r16
    1c7e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c80:	18 16       	cp	r1, r24
    1c82:	ac f4       	brge	.+42     	; 0x1cae <xQueueGenericSend+0x26e>
    1c84:	81 89       	ldd	r24, Z+17	; 0x11
    1c86:	81 11       	cpse	r24, r1
    1c88:	05 c0       	rjmp	.+10     	; 0x1c94 <xQueueGenericSend+0x254>
    1c8a:	11 c0       	rjmp	.+34     	; 0x1cae <xQueueGenericSend+0x26e>
    1c8c:	f8 01       	movw	r30, r16
    1c8e:	81 89       	ldd	r24, Z+17	; 0x11
    1c90:	88 23       	and	r24, r24
    1c92:	69 f0       	breq	.+26     	; 0x1cae <xQueueGenericSend+0x26e>
    1c94:	c6 01       	movw	r24, r12
    1c96:	0e 94 a7 18 	call	0x314e	; 0x314e <xTaskRemoveFromEventList>
    1c9a:	81 11       	cpse	r24, r1
    1c9c:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskMissedYield>
    1ca0:	f8 01       	movw	r30, r16
    1ca2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ca4:	81 50       	subi	r24, 0x01	; 1
    1ca6:	86 8f       	std	Z+30, r24	; 0x1e
    1ca8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1caa:	18 16       	cp	r1, r24
    1cac:	7c f3       	brlt	.-34     	; 0x1c8c <xQueueGenericSend+0x24c>
    1cae:	f8 01       	movw	r30, r16
    1cb0:	96 8e       	std	Z+30, r9	; 0x1e
    1cb2:	0f 90       	pop	r0
    1cb4:	0f be       	out	0x3f, r0	; 63
    1cb6:	0f b6       	in	r0, 0x3f	; 63
    1cb8:	f8 94       	cli
    1cba:	0f 92       	push	r0
    1cbc:	85 8d       	ldd	r24, Z+29	; 0x1d
    1cbe:	18 16       	cp	r1, r24
    1cc0:	ac f4       	brge	.+42     	; 0x1cec <xQueueGenericSend+0x2ac>
    1cc2:	80 85       	ldd	r24, Z+8	; 0x08
    1cc4:	81 11       	cpse	r24, r1
    1cc6:	05 c0       	rjmp	.+10     	; 0x1cd2 <xQueueGenericSend+0x292>
    1cc8:	11 c0       	rjmp	.+34     	; 0x1cec <xQueueGenericSend+0x2ac>
    1cca:	f8 01       	movw	r30, r16
    1ccc:	80 85       	ldd	r24, Z+8	; 0x08
    1cce:	88 23       	and	r24, r24
    1cd0:	69 f0       	breq	.+26     	; 0x1cec <xQueueGenericSend+0x2ac>
    1cd2:	c7 01       	movw	r24, r14
    1cd4:	0e 94 a7 18 	call	0x314e	; 0x314e <xTaskRemoveFromEventList>
    1cd8:	81 11       	cpse	r24, r1
    1cda:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskMissedYield>
    1cde:	f8 01       	movw	r30, r16
    1ce0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ce2:	81 50       	subi	r24, 0x01	; 1
    1ce4:	85 8f       	std	Z+29, r24	; 0x1d
    1ce6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ce8:	18 16       	cp	r1, r24
    1cea:	7c f3       	brlt	.-34     	; 0x1cca <xQueueGenericSend+0x28a>
    1cec:	f8 01       	movw	r30, r16
    1cee:	95 8e       	std	Z+29, r9	; 0x1d
    1cf0:	0f 90       	pop	r0
    1cf2:	0f be       	out	0x3f, r0	; 63
    1cf4:	37 d7       	rcall	.+3694   	; 0x2b64 <xTaskResumeAll>
    1cf6:	c9 ce       	rjmp	.-622    	; 0x1a8a <xQueueGenericSend+0x4a>
    1cf8:	0f b6       	in	r0, 0x3f	; 63
    1cfa:	f8 94       	cli
    1cfc:	0f 92       	push	r0
    1cfe:	f8 01       	movw	r30, r16
    1d00:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d02:	18 16       	cp	r1, r24
    1d04:	d4 f4       	brge	.+52     	; 0x1d3a <xQueueGenericSend+0x2fa>
    1d06:	81 89       	ldd	r24, Z+17	; 0x11
    1d08:	81 11       	cpse	r24, r1
    1d0a:	06 c0       	rjmp	.+12     	; 0x1d18 <xQueueGenericSend+0x2d8>
    1d0c:	16 c0       	rjmp	.+44     	; 0x1d3a <xQueueGenericSend+0x2fa>
    1d0e:	f8 01       	movw	r30, r16
    1d10:	81 89       	ldd	r24, Z+17	; 0x11
    1d12:	81 11       	cpse	r24, r1
    1d14:	05 c0       	rjmp	.+10     	; 0x1d20 <xQueueGenericSend+0x2e0>
    1d16:	11 c0       	rjmp	.+34     	; 0x1d3a <xQueueGenericSend+0x2fa>
    1d18:	78 01       	movw	r14, r16
    1d1a:	f1 e1       	ldi	r31, 0x11	; 17
    1d1c:	ef 0e       	add	r14, r31
    1d1e:	f1 1c       	adc	r15, r1
    1d20:	c7 01       	movw	r24, r14
    1d22:	0e 94 a7 18 	call	0x314e	; 0x314e <xTaskRemoveFromEventList>
    1d26:	81 11       	cpse	r24, r1
    1d28:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskMissedYield>
    1d2c:	f8 01       	movw	r30, r16
    1d2e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d30:	81 50       	subi	r24, 0x01	; 1
    1d32:	86 8f       	std	Z+30, r24	; 0x1e
    1d34:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d36:	18 16       	cp	r1, r24
    1d38:	54 f3       	brlt	.-44     	; 0x1d0e <xQueueGenericSend+0x2ce>
    1d3a:	8f ef       	ldi	r24, 0xFF	; 255
    1d3c:	f8 01       	movw	r30, r16
    1d3e:	86 8f       	std	Z+30, r24	; 0x1e
    1d40:	0f 90       	pop	r0
    1d42:	0f be       	out	0x3f, r0	; 63
    1d44:	0f b6       	in	r0, 0x3f	; 63
    1d46:	f8 94       	cli
    1d48:	0f 92       	push	r0
    1d4a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d4c:	18 16       	cp	r1, r24
    1d4e:	d4 f4       	brge	.+52     	; 0x1d84 <xQueueGenericSend+0x344>
    1d50:	80 85       	ldd	r24, Z+8	; 0x08
    1d52:	81 11       	cpse	r24, r1
    1d54:	06 c0       	rjmp	.+12     	; 0x1d62 <xQueueGenericSend+0x322>
    1d56:	16 c0       	rjmp	.+44     	; 0x1d84 <xQueueGenericSend+0x344>
    1d58:	f8 01       	movw	r30, r16
    1d5a:	80 85       	ldd	r24, Z+8	; 0x08
    1d5c:	81 11       	cpse	r24, r1
    1d5e:	05 c0       	rjmp	.+10     	; 0x1d6a <xQueueGenericSend+0x32a>
    1d60:	11 c0       	rjmp	.+34     	; 0x1d84 <xQueueGenericSend+0x344>
    1d62:	78 01       	movw	r14, r16
    1d64:	f8 e0       	ldi	r31, 0x08	; 8
    1d66:	ef 0e       	add	r14, r31
    1d68:	f1 1c       	adc	r15, r1
    1d6a:	c7 01       	movw	r24, r14
    1d6c:	0e 94 a7 18 	call	0x314e	; 0x314e <xTaskRemoveFromEventList>
    1d70:	81 11       	cpse	r24, r1
    1d72:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskMissedYield>
    1d76:	f8 01       	movw	r30, r16
    1d78:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d7a:	81 50       	subi	r24, 0x01	; 1
    1d7c:	85 8f       	std	Z+29, r24	; 0x1d
    1d7e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d80:	18 16       	cp	r1, r24
    1d82:	54 f3       	brlt	.-44     	; 0x1d58 <xQueueGenericSend+0x318>
    1d84:	8f ef       	ldi	r24, 0xFF	; 255
    1d86:	f8 01       	movw	r30, r16
    1d88:	85 8f       	std	Z+29, r24	; 0x1d
    1d8a:	0f 90       	pop	r0
    1d8c:	0f be       	out	0x3f, r0	; 63
    1d8e:	ea d6       	rcall	.+3540   	; 0x2b64 <xTaskResumeAll>
    1d90:	80 e0       	ldi	r24, 0x00	; 0
    1d92:	0e c0       	rjmp	.+28     	; 0x1db0 <xQueueGenericSend+0x370>
    1d94:	f8 01       	movw	r30, r16
    1d96:	44 8d       	ldd	r20, Z+28	; 0x1c
    1d98:	44 23       	and	r20, r20
    1d9a:	09 f4       	brne	.+2      	; 0x1d9e <xQueueGenericSend+0x35e>
    1d9c:	86 ce       	rjmp	.-756    	; 0x1aaa <xQueueGenericSend+0x6a>
    1d9e:	b6 ce       	rjmp	.-660    	; 0x1b0c <xQueueGenericSend+0xcc>
    1da0:	f8 01       	movw	r30, r16
    1da2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1da4:	8f 5f       	subi	r24, 0xFF	; 255
    1da6:	82 8f       	std	Z+26, r24	; 0x1a
    1da8:	81 89       	ldd	r24, Z+17	; 0x11
    1daa:	81 11       	cpse	r24, r1
    1dac:	d9 ce       	rjmp	.-590    	; 0x1b60 <xQueueGenericSend+0x120>
    1dae:	e2 ce       	rjmp	.-572    	; 0x1b74 <xQueueGenericSend+0x134>
    1db0:	0f 90       	pop	r0
    1db2:	0f 90       	pop	r0
    1db4:	0f 90       	pop	r0
    1db6:	0f 90       	pop	r0
    1db8:	0f 90       	pop	r0
    1dba:	df 91       	pop	r29
    1dbc:	cf 91       	pop	r28
    1dbe:	1f 91       	pop	r17
    1dc0:	0f 91       	pop	r16
    1dc2:	ff 90       	pop	r15
    1dc4:	ef 90       	pop	r14
    1dc6:	df 90       	pop	r13
    1dc8:	cf 90       	pop	r12
    1dca:	bf 90       	pop	r11
    1dcc:	af 90       	pop	r10
    1dce:	9f 90       	pop	r9
    1dd0:	8f 90       	pop	r8
    1dd2:	7f 90       	pop	r7
    1dd4:	6f 90       	pop	r6
    1dd6:	08 95       	ret

00001dd8 <xQueueGive>:
    1dd8:	9f 92       	push	r9
    1dda:	af 92       	push	r10
    1ddc:	bf 92       	push	r11
    1dde:	cf 92       	push	r12
    1de0:	df 92       	push	r13
    1de2:	ef 92       	push	r14
    1de4:	ff 92       	push	r15
    1de6:	0f 93       	push	r16
    1de8:	1f 93       	push	r17
    1dea:	cf 93       	push	r28
    1dec:	df 93       	push	r29
    1dee:	00 d0       	rcall	.+0      	; 0x1df0 <xQueueGive+0x18>
    1df0:	1f 92       	push	r1
    1df2:	1f 92       	push	r1
    1df4:	cd b7       	in	r28, 0x3d	; 61
    1df6:	de b7       	in	r29, 0x3e	; 62
    1df8:	8c 01       	movw	r16, r24
    1dfa:	7d 83       	std	Y+5, r23	; 0x05
    1dfc:	6c 83       	std	Y+4, r22	; 0x04
    1dfe:	a1 2c       	mov	r10, r1
    1e00:	99 24       	eor	r9, r9
    1e02:	93 94       	inc	r9
    1e04:	bb 24       	eor	r11, r11
    1e06:	ba 94       	dec	r11
    1e08:	7c 01       	movw	r14, r24
    1e0a:	88 e0       	ldi	r24, 0x08	; 8
    1e0c:	e8 0e       	add	r14, r24
    1e0e:	f1 1c       	adc	r15, r1
    1e10:	68 01       	movw	r12, r16
    1e12:	e1 e1       	ldi	r30, 0x11	; 17
    1e14:	ce 0e       	add	r12, r30
    1e16:	d1 1c       	adc	r13, r1
    1e18:	0f b6       	in	r0, 0x3f	; 63
    1e1a:	f8 94       	cli
    1e1c:	0f 92       	push	r0
    1e1e:	f8 01       	movw	r30, r16
    1e20:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e22:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e24:	98 17       	cp	r25, r24
    1e26:	00 f5       	brcc	.+64     	; 0x1e68 <xQueueGive+0x90>
    1e28:	80 81       	ld	r24, Z
    1e2a:	91 81       	ldd	r25, Z+1	; 0x01
    1e2c:	89 2b       	or	r24, r25
    1e2e:	09 f0       	breq	.+2      	; 0x1e32 <xQueueGive+0x5a>
    1e30:	27 c1       	rjmp	.+590    	; 0x2080 <xQueueGive+0x2a8>
    1e32:	82 81       	ldd	r24, Z+2	; 0x02
    1e34:	93 81       	ldd	r25, Z+3	; 0x03
    1e36:	0e 94 9b 19 	call	0x3336	; 0x3336 <xTaskPriorityDisinherit>
    1e3a:	f8 01       	movw	r30, r16
    1e3c:	13 82       	std	Z+3, r1	; 0x03
    1e3e:	12 82       	std	Z+2, r1	; 0x02
    1e40:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e42:	9f 5f       	subi	r25, 0xFF	; 255
    1e44:	92 8f       	std	Z+26, r25	; 0x1a
    1e46:	91 89       	ldd	r25, Z+17	; 0x11
    1e48:	99 23       	and	r25, r25
    1e4a:	41 f0       	breq	.+16     	; 0x1e5c <xQueueGive+0x84>
    1e4c:	c8 01       	movw	r24, r16
    1e4e:	41 96       	adiw	r24, 0x11	; 17
    1e50:	0e 94 a7 18 	call	0x314e	; 0x314e <xTaskRemoveFromEventList>
    1e54:	81 30       	cpi	r24, 0x01	; 1
    1e56:	21 f4       	brne	.+8      	; 0x1e60 <xQueueGive+0x88>
    1e58:	c8 dc       	rcall	.-1648   	; 0x17ea <vPortYield>
    1e5a:	02 c0       	rjmp	.+4      	; 0x1e60 <xQueueGive+0x88>
    1e5c:	81 11       	cpse	r24, r1
    1e5e:	c5 dc       	rcall	.-1654   	; 0x17ea <vPortYield>
    1e60:	0f 90       	pop	r0
    1e62:	0f be       	out	0x3f, r0	; 63
    1e64:	81 e0       	ldi	r24, 0x01	; 1
    1e66:	14 c1       	rjmp	.+552    	; 0x2090 <xQueueGive+0x2b8>
    1e68:	8c 81       	ldd	r24, Y+4	; 0x04
    1e6a:	9d 81       	ldd	r25, Y+5	; 0x05
    1e6c:	89 2b       	or	r24, r25
    1e6e:	21 f4       	brne	.+8      	; 0x1e78 <xQueueGive+0xa0>
    1e70:	0f 90       	pop	r0
    1e72:	0f be       	out	0x3f, r0	; 63
    1e74:	80 e0       	ldi	r24, 0x00	; 0
    1e76:	0c c1       	rjmp	.+536    	; 0x2090 <xQueueGive+0x2b8>
    1e78:	a1 10       	cpse	r10, r1
    1e7a:	05 c0       	rjmp	.+10     	; 0x1e86 <xQueueGive+0xae>
    1e7c:	ce 01       	movw	r24, r28
    1e7e:	01 96       	adiw	r24, 0x01	; 1
    1e80:	0e 94 ef 18 	call	0x31de	; 0x31de <vTaskSetTimeOutState>
    1e84:	a9 2c       	mov	r10, r9
    1e86:	0f 90       	pop	r0
    1e88:	0f be       	out	0x3f, r0	; 63
    1e8a:	66 d6       	rcall	.+3276   	; 0x2b58 <vTaskSuspendAll>
    1e8c:	0f b6       	in	r0, 0x3f	; 63
    1e8e:	f8 94       	cli
    1e90:	0f 92       	push	r0
    1e92:	f8 01       	movw	r30, r16
    1e94:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e96:	8f 3f       	cpi	r24, 0xFF	; 255
    1e98:	09 f4       	brne	.+2      	; 0x1e9c <xQueueGive+0xc4>
    1e9a:	15 8e       	std	Z+29, r1	; 0x1d
    1e9c:	f8 01       	movw	r30, r16
    1e9e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ea0:	8f 3f       	cpi	r24, 0xFF	; 255
    1ea2:	09 f4       	brne	.+2      	; 0x1ea6 <xQueueGive+0xce>
    1ea4:	16 8e       	std	Z+30, r1	; 0x1e
    1ea6:	0f 90       	pop	r0
    1ea8:	0f be       	out	0x3f, r0	; 63
    1eaa:	be 01       	movw	r22, r28
    1eac:	6c 5f       	subi	r22, 0xFC	; 252
    1eae:	7f 4f       	sbci	r23, 0xFF	; 255
    1eb0:	ce 01       	movw	r24, r28
    1eb2:	01 96       	adiw	r24, 0x01	; 1
    1eb4:	0e 94 fa 18 	call	0x31f4	; 0x31f4 <xTaskCheckForTimeOut>
    1eb8:	81 11       	cpse	r24, r1
    1eba:	94 c0       	rjmp	.+296    	; 0x1fe4 <xQueueGive+0x20c>
    1ebc:	0f b6       	in	r0, 0x3f	; 63
    1ebe:	f8 94       	cli
    1ec0:	0f 92       	push	r0
    1ec2:	f8 01       	movw	r30, r16
    1ec4:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ec6:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ec8:	0f 90       	pop	r0
    1eca:	0f be       	out	0x3f, r0	; 63
    1ecc:	98 13       	cpse	r25, r24
    1ece:	49 c0       	rjmp	.+146    	; 0x1f62 <xQueueGive+0x18a>
    1ed0:	6c 81       	ldd	r22, Y+4	; 0x04
    1ed2:	7d 81       	ldd	r23, Y+5	; 0x05
    1ed4:	c7 01       	movw	r24, r14
    1ed6:	0e 94 4c 18 	call	0x3098	; 0x3098 <vTaskPlaceOnEventList>
    1eda:	0f b6       	in	r0, 0x3f	; 63
    1edc:	f8 94       	cli
    1ede:	0f 92       	push	r0
    1ee0:	f8 01       	movw	r30, r16
    1ee2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ee4:	18 16       	cp	r1, r24
    1ee6:	ac f4       	brge	.+42     	; 0x1f12 <xQueueGive+0x13a>
    1ee8:	81 89       	ldd	r24, Z+17	; 0x11
    1eea:	81 11       	cpse	r24, r1
    1eec:	05 c0       	rjmp	.+10     	; 0x1ef8 <xQueueGive+0x120>
    1eee:	11 c0       	rjmp	.+34     	; 0x1f12 <xQueueGive+0x13a>
    1ef0:	f8 01       	movw	r30, r16
    1ef2:	81 89       	ldd	r24, Z+17	; 0x11
    1ef4:	88 23       	and	r24, r24
    1ef6:	69 f0       	breq	.+26     	; 0x1f12 <xQueueGive+0x13a>
    1ef8:	c6 01       	movw	r24, r12
    1efa:	0e 94 a7 18 	call	0x314e	; 0x314e <xTaskRemoveFromEventList>
    1efe:	81 11       	cpse	r24, r1
    1f00:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskMissedYield>
    1f04:	f8 01       	movw	r30, r16
    1f06:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f08:	81 50       	subi	r24, 0x01	; 1
    1f0a:	86 8f       	std	Z+30, r24	; 0x1e
    1f0c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f0e:	18 16       	cp	r1, r24
    1f10:	7c f3       	brlt	.-34     	; 0x1ef0 <xQueueGive+0x118>
    1f12:	f8 01       	movw	r30, r16
    1f14:	b6 8e       	std	Z+30, r11	; 0x1e
    1f16:	0f 90       	pop	r0
    1f18:	0f be       	out	0x3f, r0	; 63
    1f1a:	0f b6       	in	r0, 0x3f	; 63
    1f1c:	f8 94       	cli
    1f1e:	0f 92       	push	r0
    1f20:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f22:	18 16       	cp	r1, r24
    1f24:	ac f4       	brge	.+42     	; 0x1f50 <xQueueGive+0x178>
    1f26:	80 85       	ldd	r24, Z+8	; 0x08
    1f28:	81 11       	cpse	r24, r1
    1f2a:	05 c0       	rjmp	.+10     	; 0x1f36 <xQueueGive+0x15e>
    1f2c:	11 c0       	rjmp	.+34     	; 0x1f50 <xQueueGive+0x178>
    1f2e:	f8 01       	movw	r30, r16
    1f30:	80 85       	ldd	r24, Z+8	; 0x08
    1f32:	88 23       	and	r24, r24
    1f34:	69 f0       	breq	.+26     	; 0x1f50 <xQueueGive+0x178>
    1f36:	c7 01       	movw	r24, r14
    1f38:	0e 94 a7 18 	call	0x314e	; 0x314e <xTaskRemoveFromEventList>
    1f3c:	81 11       	cpse	r24, r1
    1f3e:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskMissedYield>
    1f42:	f8 01       	movw	r30, r16
    1f44:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f46:	81 50       	subi	r24, 0x01	; 1
    1f48:	85 8f       	std	Z+29, r24	; 0x1d
    1f4a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f4c:	18 16       	cp	r1, r24
    1f4e:	7c f3       	brlt	.-34     	; 0x1f2e <xQueueGive+0x156>
    1f50:	f8 01       	movw	r30, r16
    1f52:	b5 8e       	std	Z+29, r11	; 0x1d
    1f54:	0f 90       	pop	r0
    1f56:	0f be       	out	0x3f, r0	; 63
    1f58:	05 d6       	rcall	.+3082   	; 0x2b64 <xTaskResumeAll>
    1f5a:	81 11       	cpse	r24, r1
    1f5c:	5d cf       	rjmp	.-326    	; 0x1e18 <xQueueGive+0x40>
    1f5e:	45 dc       	rcall	.-1910   	; 0x17ea <vPortYield>
    1f60:	5b cf       	rjmp	.-330    	; 0x1e18 <xQueueGive+0x40>
    1f62:	0f b6       	in	r0, 0x3f	; 63
    1f64:	f8 94       	cli
    1f66:	0f 92       	push	r0
    1f68:	f8 01       	movw	r30, r16
    1f6a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f6c:	18 16       	cp	r1, r24
    1f6e:	ac f4       	brge	.+42     	; 0x1f9a <xQueueGive+0x1c2>
    1f70:	81 89       	ldd	r24, Z+17	; 0x11
    1f72:	81 11       	cpse	r24, r1
    1f74:	05 c0       	rjmp	.+10     	; 0x1f80 <xQueueGive+0x1a8>
    1f76:	11 c0       	rjmp	.+34     	; 0x1f9a <xQueueGive+0x1c2>
    1f78:	f8 01       	movw	r30, r16
    1f7a:	81 89       	ldd	r24, Z+17	; 0x11
    1f7c:	88 23       	and	r24, r24
    1f7e:	69 f0       	breq	.+26     	; 0x1f9a <xQueueGive+0x1c2>
    1f80:	c6 01       	movw	r24, r12
    1f82:	0e 94 a7 18 	call	0x314e	; 0x314e <xTaskRemoveFromEventList>
    1f86:	81 11       	cpse	r24, r1
    1f88:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskMissedYield>
    1f8c:	f8 01       	movw	r30, r16
    1f8e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f90:	81 50       	subi	r24, 0x01	; 1
    1f92:	86 8f       	std	Z+30, r24	; 0x1e
    1f94:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f96:	18 16       	cp	r1, r24
    1f98:	7c f3       	brlt	.-34     	; 0x1f78 <xQueueGive+0x1a0>
    1f9a:	f8 01       	movw	r30, r16
    1f9c:	b6 8e       	std	Z+30, r11	; 0x1e
    1f9e:	0f 90       	pop	r0
    1fa0:	0f be       	out	0x3f, r0	; 63
    1fa2:	0f b6       	in	r0, 0x3f	; 63
    1fa4:	f8 94       	cli
    1fa6:	0f 92       	push	r0
    1fa8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1faa:	18 16       	cp	r1, r24
    1fac:	ac f4       	brge	.+42     	; 0x1fd8 <xQueueGive+0x200>
    1fae:	80 85       	ldd	r24, Z+8	; 0x08
    1fb0:	81 11       	cpse	r24, r1
    1fb2:	05 c0       	rjmp	.+10     	; 0x1fbe <xQueueGive+0x1e6>
    1fb4:	11 c0       	rjmp	.+34     	; 0x1fd8 <xQueueGive+0x200>
    1fb6:	f8 01       	movw	r30, r16
    1fb8:	80 85       	ldd	r24, Z+8	; 0x08
    1fba:	88 23       	and	r24, r24
    1fbc:	69 f0       	breq	.+26     	; 0x1fd8 <xQueueGive+0x200>
    1fbe:	c7 01       	movw	r24, r14
    1fc0:	0e 94 a7 18 	call	0x314e	; 0x314e <xTaskRemoveFromEventList>
    1fc4:	81 11       	cpse	r24, r1
    1fc6:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskMissedYield>
    1fca:	f8 01       	movw	r30, r16
    1fcc:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fce:	81 50       	subi	r24, 0x01	; 1
    1fd0:	85 8f       	std	Z+29, r24	; 0x1d
    1fd2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fd4:	18 16       	cp	r1, r24
    1fd6:	7c f3       	brlt	.-34     	; 0x1fb6 <xQueueGive+0x1de>
    1fd8:	f8 01       	movw	r30, r16
    1fda:	b5 8e       	std	Z+29, r11	; 0x1d
    1fdc:	0f 90       	pop	r0
    1fde:	0f be       	out	0x3f, r0	; 63
    1fe0:	c1 d5       	rcall	.+2946   	; 0x2b64 <xTaskResumeAll>
    1fe2:	1a cf       	rjmp	.-460    	; 0x1e18 <xQueueGive+0x40>
    1fe4:	0f b6       	in	r0, 0x3f	; 63
    1fe6:	f8 94       	cli
    1fe8:	0f 92       	push	r0
    1fea:	f8 01       	movw	r30, r16
    1fec:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fee:	18 16       	cp	r1, r24
    1ff0:	d4 f4       	brge	.+52     	; 0x2026 <xQueueGive+0x24e>
    1ff2:	81 89       	ldd	r24, Z+17	; 0x11
    1ff4:	81 11       	cpse	r24, r1
    1ff6:	06 c0       	rjmp	.+12     	; 0x2004 <xQueueGive+0x22c>
    1ff8:	16 c0       	rjmp	.+44     	; 0x2026 <xQueueGive+0x24e>
    1ffa:	f8 01       	movw	r30, r16
    1ffc:	81 89       	ldd	r24, Z+17	; 0x11
    1ffe:	81 11       	cpse	r24, r1
    2000:	05 c0       	rjmp	.+10     	; 0x200c <xQueueGive+0x234>
    2002:	11 c0       	rjmp	.+34     	; 0x2026 <xQueueGive+0x24e>
    2004:	78 01       	movw	r14, r16
    2006:	f1 e1       	ldi	r31, 0x11	; 17
    2008:	ef 0e       	add	r14, r31
    200a:	f1 1c       	adc	r15, r1
    200c:	c7 01       	movw	r24, r14
    200e:	0e 94 a7 18 	call	0x314e	; 0x314e <xTaskRemoveFromEventList>
    2012:	81 11       	cpse	r24, r1
    2014:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskMissedYield>
    2018:	f8 01       	movw	r30, r16
    201a:	86 8d       	ldd	r24, Z+30	; 0x1e
    201c:	81 50       	subi	r24, 0x01	; 1
    201e:	86 8f       	std	Z+30, r24	; 0x1e
    2020:	86 8d       	ldd	r24, Z+30	; 0x1e
    2022:	18 16       	cp	r1, r24
    2024:	54 f3       	brlt	.-44     	; 0x1ffa <xQueueGive+0x222>
    2026:	8f ef       	ldi	r24, 0xFF	; 255
    2028:	f8 01       	movw	r30, r16
    202a:	86 8f       	std	Z+30, r24	; 0x1e
    202c:	0f 90       	pop	r0
    202e:	0f be       	out	0x3f, r0	; 63
    2030:	0f b6       	in	r0, 0x3f	; 63
    2032:	f8 94       	cli
    2034:	0f 92       	push	r0
    2036:	85 8d       	ldd	r24, Z+29	; 0x1d
    2038:	18 16       	cp	r1, r24
    203a:	d4 f4       	brge	.+52     	; 0x2070 <xQueueGive+0x298>
    203c:	80 85       	ldd	r24, Z+8	; 0x08
    203e:	81 11       	cpse	r24, r1
    2040:	06 c0       	rjmp	.+12     	; 0x204e <xQueueGive+0x276>
    2042:	16 c0       	rjmp	.+44     	; 0x2070 <xQueueGive+0x298>
    2044:	f8 01       	movw	r30, r16
    2046:	80 85       	ldd	r24, Z+8	; 0x08
    2048:	81 11       	cpse	r24, r1
    204a:	05 c0       	rjmp	.+10     	; 0x2056 <xQueueGive+0x27e>
    204c:	11 c0       	rjmp	.+34     	; 0x2070 <xQueueGive+0x298>
    204e:	78 01       	movw	r14, r16
    2050:	f8 e0       	ldi	r31, 0x08	; 8
    2052:	ef 0e       	add	r14, r31
    2054:	f1 1c       	adc	r15, r1
    2056:	c7 01       	movw	r24, r14
    2058:	0e 94 a7 18 	call	0x314e	; 0x314e <xTaskRemoveFromEventList>
    205c:	81 11       	cpse	r24, r1
    205e:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskMissedYield>
    2062:	f8 01       	movw	r30, r16
    2064:	85 8d       	ldd	r24, Z+29	; 0x1d
    2066:	81 50       	subi	r24, 0x01	; 1
    2068:	85 8f       	std	Z+29, r24	; 0x1d
    206a:	85 8d       	ldd	r24, Z+29	; 0x1d
    206c:	18 16       	cp	r1, r24
    206e:	54 f3       	brlt	.-44     	; 0x2044 <xQueueGive+0x26c>
    2070:	8f ef       	ldi	r24, 0xFF	; 255
    2072:	f8 01       	movw	r30, r16
    2074:	85 8f       	std	Z+29, r24	; 0x1d
    2076:	0f 90       	pop	r0
    2078:	0f be       	out	0x3f, r0	; 63
    207a:	74 d5       	rcall	.+2792   	; 0x2b64 <xTaskResumeAll>
    207c:	80 e0       	ldi	r24, 0x00	; 0
    207e:	08 c0       	rjmp	.+16     	; 0x2090 <xQueueGive+0x2b8>
    2080:	f8 01       	movw	r30, r16
    2082:	82 8d       	ldd	r24, Z+26	; 0x1a
    2084:	8f 5f       	subi	r24, 0xFF	; 255
    2086:	82 8f       	std	Z+26, r24	; 0x1a
    2088:	81 89       	ldd	r24, Z+17	; 0x11
    208a:	81 11       	cpse	r24, r1
    208c:	df ce       	rjmp	.-578    	; 0x1e4c <xQueueGive+0x74>
    208e:	e8 ce       	rjmp	.-560    	; 0x1e60 <xQueueGive+0x88>
    2090:	0f 90       	pop	r0
    2092:	0f 90       	pop	r0
    2094:	0f 90       	pop	r0
    2096:	0f 90       	pop	r0
    2098:	0f 90       	pop	r0
    209a:	df 91       	pop	r29
    209c:	cf 91       	pop	r28
    209e:	1f 91       	pop	r17
    20a0:	0f 91       	pop	r16
    20a2:	ff 90       	pop	r15
    20a4:	ef 90       	pop	r14
    20a6:	df 90       	pop	r13
    20a8:	cf 90       	pop	r12
    20aa:	bf 90       	pop	r11
    20ac:	af 90       	pop	r10
    20ae:	9f 90       	pop	r9
    20b0:	08 95       	ret

000020b2 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    20b2:	cf 93       	push	r28
    20b4:	df 93       	push	r29
    20b6:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    20b8:	92 8d       	ldd	r25, Z+26	; 0x1a
    20ba:	83 8d       	ldd	r24, Z+27	; 0x1b
    20bc:	98 17       	cp	r25, r24
    20be:	d0 f4       	brcc	.+52     	; 0x20f4 <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    20c0:	82 8d       	ldd	r24, Z+26	; 0x1a
    20c2:	8f 5f       	subi	r24, 0xFF	; 255
    20c4:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    20c6:	86 8d       	ldd	r24, Z+30	; 0x1e
    20c8:	8f 3f       	cpi	r24, 0xFF	; 255
    20ca:	79 f4       	brne	.+30     	; 0x20ea <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20cc:	81 89       	ldd	r24, Z+17	; 0x11
    20ce:	88 23       	and	r24, r24
    20d0:	99 f0       	breq	.+38     	; 0x20f8 <xQueueGiveFromISR+0x46>
    20d2:	eb 01       	movw	r28, r22
    20d4:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20d6:	41 96       	adiw	r24, 0x11	; 17
    20d8:	0e 94 a7 18 	call	0x314e	; 0x314e <xTaskRemoveFromEventList>
    20dc:	88 23       	and	r24, r24
    20de:	71 f0       	breq	.+28     	; 0x20fc <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    20e0:	20 97       	sbiw	r28, 0x00	; 0
    20e2:	71 f0       	breq	.+28     	; 0x2100 <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    20e4:	81 e0       	ldi	r24, 0x01	; 1
    20e6:	88 83       	st	Y, r24
    20e8:	0c c0       	rjmp	.+24     	; 0x2102 <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    20ea:	86 8d       	ldd	r24, Z+30	; 0x1e
    20ec:	8f 5f       	subi	r24, 0xFF	; 255
    20ee:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    20f0:	81 e0       	ldi	r24, 0x01	; 1
    20f2:	07 c0       	rjmp	.+14     	; 0x2102 <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    20f4:	80 e0       	ldi	r24, 0x00	; 0
    20f6:	05 c0       	rjmp	.+10     	; 0x2102 <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    20f8:	81 e0       	ldi	r24, 0x01	; 1
    20fa:	03 c0       	rjmp	.+6      	; 0x2102 <xQueueGiveFromISR+0x50>
    20fc:	81 e0       	ldi	r24, 0x01	; 1
    20fe:	01 c0       	rjmp	.+2      	; 0x2102 <xQueueGiveFromISR+0x50>
    2100:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2102:	df 91       	pop	r29
    2104:	cf 91       	pop	r28
    2106:	08 95       	ret

00002108 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    2108:	6f 92       	push	r6
    210a:	7f 92       	push	r7
    210c:	8f 92       	push	r8
    210e:	9f 92       	push	r9
    2110:	af 92       	push	r10
    2112:	bf 92       	push	r11
    2114:	cf 92       	push	r12
    2116:	df 92       	push	r13
    2118:	ef 92       	push	r14
    211a:	ff 92       	push	r15
    211c:	0f 93       	push	r16
    211e:	1f 93       	push	r17
    2120:	cf 93       	push	r28
    2122:	df 93       	push	r29
    2124:	00 d0       	rcall	.+0      	; 0x2126 <xQueueGenericReceive+0x1e>
    2126:	1f 92       	push	r1
    2128:	1f 92       	push	r1
    212a:	cd b7       	in	r28, 0x3d	; 61
    212c:	de b7       	in	r29, 0x3e	; 62
    212e:	8c 01       	movw	r16, r24
    2130:	5b 01       	movw	r10, r22
    2132:	5d 83       	std	Y+5, r21	; 0x05
    2134:	4c 83       	std	Y+4, r20	; 0x04
    2136:	62 2e       	mov	r6, r18
BaseType_t xEntryTimeSet = pdFALSE;
    2138:	81 2c       	mov	r8, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    213a:	77 24       	eor	r7, r7
    213c:	73 94       	inc	r7
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    213e:	99 24       	eor	r9, r9
    2140:	9a 94       	dec	r9
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2142:	6c 01       	movw	r12, r24
    2144:	88 e0       	ldi	r24, 0x08	; 8
    2146:	c8 0e       	add	r12, r24
    2148:	d1 1c       	adc	r13, r1
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    214a:	78 01       	movw	r14, r16
    214c:	e1 e1       	ldi	r30, 0x11	; 17
    214e:	ee 0e       	add	r14, r30
    2150:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2152:	0f b6       	in	r0, 0x3f	; 63
    2154:	f8 94       	cli
    2156:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2158:	f8 01       	movw	r30, r16
    215a:	82 8d       	ldd	r24, Z+26	; 0x1a
    215c:	88 23       	and	r24, r24
    215e:	09 f4       	brne	.+2      	; 0x2162 <xQueueGenericReceive+0x5a>
    2160:	43 c0       	rjmp	.+134    	; 0x21e8 <xQueueGenericReceive+0xe0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2162:	e6 80       	ldd	r14, Z+6	; 0x06
    2164:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2166:	44 8d       	ldd	r20, Z+28	; 0x1c
    2168:	44 23       	and	r20, r20
    216a:	a9 f0       	breq	.+42     	; 0x2196 <xQueueGenericReceive+0x8e>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    216c:	50 e0       	ldi	r21, 0x00	; 0
    216e:	c7 01       	movw	r24, r14
    2170:	84 0f       	add	r24, r20
    2172:	95 1f       	adc	r25, r21
    2174:	97 83       	std	Z+7, r25	; 0x07
    2176:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2178:	22 81       	ldd	r18, Z+2	; 0x02
    217a:	33 81       	ldd	r19, Z+3	; 0x03
    217c:	82 17       	cp	r24, r18
    217e:	93 07       	cpc	r25, r19
    2180:	20 f0       	brcs	.+8      	; 0x218a <xQueueGenericReceive+0x82>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2182:	80 81       	ld	r24, Z
    2184:	91 81       	ldd	r25, Z+1	; 0x01
    2186:	97 83       	std	Z+7, r25	; 0x07
    2188:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    218a:	f8 01       	movw	r30, r16
    218c:	66 81       	ldd	r22, Z+6	; 0x06
    218e:	77 81       	ldd	r23, Z+7	; 0x07
    2190:	c5 01       	movw	r24, r10
    2192:	0e 94 25 20 	call	0x404a	; 0x404a <memcpy>
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    2196:	61 10       	cpse	r6, r1
    2198:	18 c0       	rjmp	.+48     	; 0x21ca <xQueueGenericReceive+0xc2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    219a:	f8 01       	movw	r30, r16
    219c:	82 8d       	ldd	r24, Z+26	; 0x1a
    219e:	81 50       	subi	r24, 0x01	; 1
    21a0:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    21a2:	80 81       	ld	r24, Z
    21a4:	91 81       	ldd	r25, Z+1	; 0x01
    21a6:	89 2b       	or	r24, r25
    21a8:	29 f4       	brne	.+10     	; 0x21b4 <xQueueGenericReceive+0xac>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    21aa:	0e 94 db 19 	call	0x33b6	; 0x33b6 <pvTaskIncrementMutexHeldCount>
    21ae:	f8 01       	movw	r30, r16
    21b0:	93 83       	std	Z+3, r25	; 0x03
    21b2:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    21b4:	f8 01       	movw	r30, r16
    21b6:	80 85       	ldd	r24, Z+8	; 0x08
    21b8:	88 23       	and	r24, r24
    21ba:	91 f0       	breq	.+36     	; 0x21e0 <xQueueGenericReceive+0xd8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    21bc:	c8 01       	movw	r24, r16
    21be:	08 96       	adiw	r24, 0x08	; 8
    21c0:	c6 d7       	rcall	.+3980   	; 0x314e <xTaskRemoveFromEventList>
    21c2:	81 30       	cpi	r24, 0x01	; 1
    21c4:	69 f4       	brne	.+26     	; 0x21e0 <xQueueGenericReceive+0xd8>
						{
							queueYIELD_IF_USING_PREEMPTION();
    21c6:	11 db       	rcall	.-2526   	; 0x17ea <vPortYield>
    21c8:	0b c0       	rjmp	.+22     	; 0x21e0 <xQueueGenericReceive+0xd8>
    21ca:	f8 01       	movw	r30, r16
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    21cc:	f7 82       	std	Z+7, r15	; 0x07
    21ce:	e6 82       	std	Z+6, r14	; 0x06
    21d0:	81 89       	ldd	r24, Z+17	; 0x11

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    21d2:	88 23       	and	r24, r24
    21d4:	29 f0       	breq	.+10     	; 0x21e0 <xQueueGenericReceive+0xd8>
    21d6:	c8 01       	movw	r24, r16
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    21d8:	41 96       	adiw	r24, 0x11	; 17
    21da:	b9 d7       	rcall	.+3954   	; 0x314e <xTaskRemoveFromEventList>
    21dc:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    21de:	05 db       	rcall	.-2550   	; 0x17ea <vPortYield>
    21e0:	0f 90       	pop	r0
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    21e2:	0f be       	out	0x3f, r0	; 63
    21e4:	81 e0       	ldi	r24, 0x01	; 1
				return pdPASS;
    21e6:	08 c1       	rjmp	.+528    	; 0x23f8 <__stack+0x1f9>
    21e8:	8c 81       	ldd	r24, Y+4	; 0x04
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    21ea:	9d 81       	ldd	r25, Y+5	; 0x05
    21ec:	89 2b       	or	r24, r25
    21ee:	21 f4       	brne	.+8      	; 0x21f8 <xQueueGenericReceive+0xf0>
    21f0:	0f 90       	pop	r0
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    21f2:	0f be       	out	0x3f, r0	; 63
    21f4:	80 e0       	ldi	r24, 0x00	; 0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    21f6:	00 c1       	rjmp	.+512    	; 0x23f8 <__stack+0x1f9>
    21f8:	81 10       	cpse	r8, r1
				}
				else if( xEntryTimeSet == pdFALSE )
    21fa:	04 c0       	rjmp	.+8      	; 0x2204 <__stack+0x5>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    21fc:	ce 01       	movw	r24, r28
    21fe:	01 96       	adiw	r24, 0x01	; 1
    2200:	ee d7       	rcall	.+4060   	; 0x31de <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2202:	87 2c       	mov	r8, r7
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2204:	0f 90       	pop	r0
    2206:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2208:	a7 d4       	rcall	.+2382   	; 0x2b58 <vTaskSuspendAll>
    220a:	0f b6       	in	r0, 0x3f	; 63
		prvLockQueue( pxQueue );
    220c:	f8 94       	cli
    220e:	0f 92       	push	r0
    2210:	f8 01       	movw	r30, r16
    2212:	85 8d       	ldd	r24, Z+29	; 0x1d
    2214:	8f 3f       	cpi	r24, 0xFF	; 255
    2216:	09 f4       	brne	.+2      	; 0x221a <__stack+0x1b>
    2218:	15 8e       	std	Z+29, r1	; 0x1d
    221a:	f8 01       	movw	r30, r16
    221c:	86 8d       	ldd	r24, Z+30	; 0x1e
    221e:	8f 3f       	cpi	r24, 0xFF	; 255
    2220:	09 f4       	brne	.+2      	; 0x2224 <__stack+0x25>
    2222:	16 8e       	std	Z+30, r1	; 0x1e
    2224:	0f 90       	pop	r0
    2226:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2228:	be 01       	movw	r22, r28
    222a:	6c 5f       	subi	r22, 0xFC	; 252
    222c:	7f 4f       	sbci	r23, 0xFF	; 255
    222e:	ce 01       	movw	r24, r28
    2230:	01 96       	adiw	r24, 0x01	; 1
    2232:	e0 d7       	rcall	.+4032   	; 0x31f4 <xTaskCheckForTimeOut>
    2234:	81 11       	cpse	r24, r1
    2236:	97 c0       	rjmp	.+302    	; 0x2366 <__stack+0x167>
    2238:	0f b6       	in	r0, 0x3f	; 63

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    223a:	f8 94       	cli
    223c:	0f 92       	push	r0
    223e:	f8 01       	movw	r30, r16
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2240:	82 8d       	ldd	r24, Z+26	; 0x1a
    2242:	0f 90       	pop	r0
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2244:	0f be       	out	0x3f, r0	; 63
    2246:	81 11       	cpse	r24, r1
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2248:	51 c0       	rjmp	.+162    	; 0x22ec <__stack+0xed>
    224a:	80 81       	ld	r24, Z
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    224c:	91 81       	ldd	r25, Z+1	; 0x01
    224e:	89 2b       	or	r24, r25
    2250:	49 f4       	brne	.+18     	; 0x2264 <__stack+0x65>
    2252:	0f b6       	in	r0, 0x3f	; 63
					{
						taskENTER_CRITICAL();
    2254:	f8 94       	cli
    2256:	0f 92       	push	r0
    2258:	82 81       	ldd	r24, Z+2	; 0x02
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    225a:	93 81       	ldd	r25, Z+3	; 0x03
    225c:	0e 94 39 19 	call	0x3272	; 0x3272 <vTaskPriorityInherit>
    2260:	0f 90       	pop	r0
						}
						taskEXIT_CRITICAL();
    2262:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2264:	6c 81       	ldd	r22, Y+4	; 0x04
    2266:	7d 81       	ldd	r23, Y+5	; 0x05
    2268:	c7 01       	movw	r24, r14
    226a:	16 d7       	rcall	.+3628   	; 0x3098 <vTaskPlaceOnEventList>
    226c:	0f b6       	in	r0, 0x3f	; 63

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    226e:	f8 94       	cli
    2270:	0f 92       	push	r0
    2272:	f8 01       	movw	r30, r16
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2274:	86 8d       	ldd	r24, Z+30	; 0x1e
    2276:	18 16       	cp	r1, r24
    2278:	9c f4       	brge	.+38     	; 0x22a0 <__stack+0xa1>
    227a:	81 89       	ldd	r24, Z+17	; 0x11
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    227c:	81 11       	cpse	r24, r1
    227e:	05 c0       	rjmp	.+10     	; 0x228a <__stack+0x8b>
    2280:	0f c0       	rjmp	.+30     	; 0x22a0 <__stack+0xa1>
    2282:	f8 01       	movw	r30, r16
    2284:	81 89       	ldd	r24, Z+17	; 0x11
    2286:	88 23       	and	r24, r24
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2288:	59 f0       	breq	.+22     	; 0x22a0 <__stack+0xa1>
    228a:	c7 01       	movw	r24, r14
    228c:	60 d7       	rcall	.+3776   	; 0x314e <xTaskRemoveFromEventList>
    228e:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    2290:	ec d7       	rcall	.+4056   	; 0x326a <vTaskMissedYield>
    2292:	f8 01       	movw	r30, r16
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2294:	86 8d       	ldd	r24, Z+30	; 0x1e
    2296:	81 50       	subi	r24, 0x01	; 1
    2298:	86 8f       	std	Z+30, r24	; 0x1e
    229a:	86 8d       	ldd	r24, Z+30	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    229c:	18 16       	cp	r1, r24
    229e:	8c f3       	brlt	.-30     	; 0x2282 <__stack+0x83>
    22a0:	f8 01       	movw	r30, r16
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    22a2:	96 8e       	std	Z+30, r9	; 0x1e
    22a4:	0f 90       	pop	r0
	}
	taskEXIT_CRITICAL();
    22a6:	0f be       	out	0x3f, r0	; 63
    22a8:	0f b6       	in	r0, 0x3f	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    22aa:	f8 94       	cli
    22ac:	0f 92       	push	r0
    22ae:	85 8d       	ldd	r24, Z+29	; 0x1d
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    22b0:	18 16       	cp	r1, r24
    22b2:	9c f4       	brge	.+38     	; 0x22da <__stack+0xdb>
    22b4:	80 85       	ldd	r24, Z+8	; 0x08
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    22b6:	81 11       	cpse	r24, r1
    22b8:	05 c0       	rjmp	.+10     	; 0x22c4 <__stack+0xc5>
    22ba:	0f c0       	rjmp	.+30     	; 0x22da <__stack+0xdb>
    22bc:	f8 01       	movw	r30, r16
    22be:	80 85       	ldd	r24, Z+8	; 0x08
    22c0:	88 23       	and	r24, r24
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    22c2:	59 f0       	breq	.+22     	; 0x22da <__stack+0xdb>
    22c4:	c6 01       	movw	r24, r12
    22c6:	43 d7       	rcall	.+3718   	; 0x314e <xTaskRemoveFromEventList>
    22c8:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    22ca:	cf d7       	rcall	.+3998   	; 0x326a <vTaskMissedYield>
    22cc:	f8 01       	movw	r30, r16
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    22ce:	85 8d       	ldd	r24, Z+29	; 0x1d
    22d0:	81 50       	subi	r24, 0x01	; 1
    22d2:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    22d4:	85 8d       	ldd	r24, Z+29	; 0x1d
    22d6:	18 16       	cp	r1, r24
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    22d8:	8c f3       	brlt	.-30     	; 0x22bc <__stack+0xbd>
    22da:	f8 01       	movw	r30, r16
	}
	taskEXIT_CRITICAL();
    22dc:	95 8e       	std	Z+29, r9	; 0x1d
    22de:	0f 90       	pop	r0
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
    22e0:	0f be       	out	0x3f, r0	; 63
    22e2:	40 d4       	rcall	.+2176   	; 0x2b64 <xTaskResumeAll>
    22e4:	81 11       	cpse	r24, r1
    22e6:	35 cf       	rjmp	.-406    	; 0x2152 <xQueueGenericReceive+0x4a>
				{
					portYIELD_WITHIN_API();
    22e8:	80 da       	rcall	.-2816   	; 0x17ea <vPortYield>
    22ea:	33 cf       	rjmp	.-410    	; 0x2152 <xQueueGenericReceive+0x4a>
    22ec:	0f b6       	in	r0, 0x3f	; 63

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    22ee:	f8 94       	cli
    22f0:	0f 92       	push	r0
    22f2:	f8 01       	movw	r30, r16
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    22f4:	86 8d       	ldd	r24, Z+30	; 0x1e
    22f6:	18 16       	cp	r1, r24
    22f8:	9c f4       	brge	.+38     	; 0x2320 <__stack+0x121>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22fa:	81 89       	ldd	r24, Z+17	; 0x11
    22fc:	81 11       	cpse	r24, r1
    22fe:	05 c0       	rjmp	.+10     	; 0x230a <__stack+0x10b>
    2300:	0f c0       	rjmp	.+30     	; 0x2320 <__stack+0x121>
    2302:	f8 01       	movw	r30, r16
    2304:	81 89       	ldd	r24, Z+17	; 0x11
    2306:	88 23       	and	r24, r24
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2308:	59 f0       	breq	.+22     	; 0x2320 <__stack+0x121>
    230a:	c7 01       	movw	r24, r14
    230c:	20 d7       	rcall	.+3648   	; 0x314e <xTaskRemoveFromEventList>
    230e:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    2310:	ac d7       	rcall	.+3928   	; 0x326a <vTaskMissedYield>
    2312:	f8 01       	movw	r30, r16
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2314:	86 8d       	ldd	r24, Z+30	; 0x1e
    2316:	81 50       	subi	r24, 0x01	; 1
    2318:	86 8f       	std	Z+30, r24	; 0x1e
    231a:	86 8d       	ldd	r24, Z+30	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    231c:	18 16       	cp	r1, r24
    231e:	8c f3       	brlt	.-30     	; 0x2302 <__stack+0x103>
    2320:	f8 01       	movw	r30, r16
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2322:	96 8e       	std	Z+30, r9	; 0x1e
    2324:	0f 90       	pop	r0
	}
	taskEXIT_CRITICAL();
    2326:	0f be       	out	0x3f, r0	; 63
    2328:	0f b6       	in	r0, 0x3f	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    232a:	f8 94       	cli
    232c:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    232e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2330:	18 16       	cp	r1, r24
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2332:	9c f4       	brge	.+38     	; 0x235a <__stack+0x15b>
    2334:	80 85       	ldd	r24, Z+8	; 0x08
    2336:	81 11       	cpse	r24, r1
    2338:	05 c0       	rjmp	.+10     	; 0x2344 <__stack+0x145>
    233a:	0f c0       	rjmp	.+30     	; 0x235a <__stack+0x15b>
    233c:	f8 01       	movw	r30, r16
    233e:	80 85       	ldd	r24, Z+8	; 0x08
    2340:	88 23       	and	r24, r24
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2342:	59 f0       	breq	.+22     	; 0x235a <__stack+0x15b>
    2344:	c6 01       	movw	r24, r12
    2346:	03 d7       	rcall	.+3590   	; 0x314e <xTaskRemoveFromEventList>
				{
					vTaskMissedYield();
    2348:	81 11       	cpse	r24, r1
    234a:	8f d7       	rcall	.+3870   	; 0x326a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    234c:	f8 01       	movw	r30, r16
    234e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2350:	81 50       	subi	r24, 0x01	; 1
    2352:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2354:	85 8d       	ldd	r24, Z+29	; 0x1d
    2356:	18 16       	cp	r1, r24
    2358:	8c f3       	brlt	.-30     	; 0x233c <__stack+0x13d>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    235a:	f8 01       	movw	r30, r16
    235c:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    235e:	0f 90       	pop	r0
    2360:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
    2362:	00 d4       	rcall	.+2048   	; 0x2b64 <xTaskResumeAll>
    2364:	f6 ce       	rjmp	.-532    	; 0x2152 <xQueueGenericReceive+0x4a>
    2366:	0f b6       	in	r0, 0x3f	; 63

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2368:	f8 94       	cli
    236a:	0f 92       	push	r0
    236c:	f8 01       	movw	r30, r16
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    236e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2370:	18 16       	cp	r1, r24
    2372:	c4 f4       	brge	.+48     	; 0x23a4 <__stack+0x1a5>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2374:	81 89       	ldd	r24, Z+17	; 0x11
    2376:	81 11       	cpse	r24, r1
    2378:	06 c0       	rjmp	.+12     	; 0x2386 <__stack+0x187>
    237a:	14 c0       	rjmp	.+40     	; 0x23a4 <__stack+0x1a5>
    237c:	f8 01       	movw	r30, r16
    237e:	81 89       	ldd	r24, Z+17	; 0x11
    2380:	81 11       	cpse	r24, r1
    2382:	05 c0       	rjmp	.+10     	; 0x238e <__stack+0x18f>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2384:	0f c0       	rjmp	.+30     	; 0x23a4 <__stack+0x1a5>
    2386:	78 01       	movw	r14, r16
    2388:	f1 e1       	ldi	r31, 0x11	; 17
    238a:	ef 0e       	add	r14, r31
    238c:	f1 1c       	adc	r15, r1
    238e:	c7 01       	movw	r24, r14
    2390:	de d6       	rcall	.+3516   	; 0x314e <xTaskRemoveFromEventList>
    2392:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    2394:	6a d7       	rcall	.+3796   	; 0x326a <vTaskMissedYield>
    2396:	f8 01       	movw	r30, r16
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2398:	86 8d       	ldd	r24, Z+30	; 0x1e
    239a:	81 50       	subi	r24, 0x01	; 1
    239c:	86 8f       	std	Z+30, r24	; 0x1e
    239e:	86 8d       	ldd	r24, Z+30	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    23a0:	18 16       	cp	r1, r24
    23a2:	64 f3       	brlt	.-40     	; 0x237c <__stack+0x17d>
    23a4:	8f ef       	ldi	r24, 0xFF	; 255
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    23a6:	f8 01       	movw	r30, r16
    23a8:	86 8f       	std	Z+30, r24	; 0x1e
    23aa:	0f 90       	pop	r0
	}
	taskEXIT_CRITICAL();
    23ac:	0f be       	out	0x3f, r0	; 63
    23ae:	0f b6       	in	r0, 0x3f	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    23b0:	f8 94       	cli
    23b2:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    23b4:	85 8d       	ldd	r24, Z+29	; 0x1d
    23b6:	18 16       	cp	r1, r24
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    23b8:	c4 f4       	brge	.+48     	; 0x23ea <__stack+0x1eb>
    23ba:	80 85       	ldd	r24, Z+8	; 0x08
    23bc:	81 11       	cpse	r24, r1
    23be:	06 c0       	rjmp	.+12     	; 0x23cc <__stack+0x1cd>
    23c0:	14 c0       	rjmp	.+40     	; 0x23ea <__stack+0x1eb>
    23c2:	f8 01       	movw	r30, r16
    23c4:	80 85       	ldd	r24, Z+8	; 0x08
    23c6:	81 11       	cpse	r24, r1
    23c8:	05 c0       	rjmp	.+10     	; 0x23d4 <__stack+0x1d5>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    23ca:	0f c0       	rjmp	.+30     	; 0x23ea <__stack+0x1eb>
    23cc:	78 01       	movw	r14, r16
    23ce:	f8 e0       	ldi	r31, 0x08	; 8
    23d0:	ef 0e       	add	r14, r31
    23d2:	f1 1c       	adc	r15, r1
    23d4:	c7 01       	movw	r24, r14
    23d6:	bb d6       	rcall	.+3446   	; 0x314e <xTaskRemoveFromEventList>
				{
					vTaskMissedYield();
    23d8:	81 11       	cpse	r24, r1
    23da:	47 d7       	rcall	.+3726   	; 0x326a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    23dc:	f8 01       	movw	r30, r16
    23de:	85 8d       	ldd	r24, Z+29	; 0x1d
    23e0:	81 50       	subi	r24, 0x01	; 1
    23e2:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    23e4:	85 8d       	ldd	r24, Z+29	; 0x1d
    23e6:	18 16       	cp	r1, r24
    23e8:	64 f3       	brlt	.-40     	; 0x23c2 <__stack+0x1c3>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    23ea:	8f ef       	ldi	r24, 0xFF	; 255
    23ec:	f8 01       	movw	r30, r16
    23ee:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    23f0:	0f 90       	pop	r0
    23f2:	0f be       	out	0x3f, r0	; 63
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
    23f4:	b7 d3       	rcall	.+1902   	; 0x2b64 <xTaskResumeAll>
    23f6:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    23f8:	0f 90       	pop	r0
		}
	}
}
    23fa:	0f 90       	pop	r0
    23fc:	0f 90       	pop	r0
    23fe:	0f 90       	pop	r0
    2400:	0f 90       	pop	r0
    2402:	df 91       	pop	r29
    2404:	cf 91       	pop	r28
    2406:	1f 91       	pop	r17
    2408:	0f 91       	pop	r16
    240a:	ff 90       	pop	r15
    240c:	ef 90       	pop	r14
    240e:	df 90       	pop	r13
    2410:	cf 90       	pop	r12
    2412:	bf 90       	pop	r11
    2414:	af 90       	pop	r10
    2416:	9f 90       	pop	r9
    2418:	8f 90       	pop	r8
    241a:	7f 90       	pop	r7
    241c:	6f 90       	pop	r6
    241e:	08 95       	ret

00002420 <xTaskGenericCreate>:
    2420:	4f 92       	push	r4
    2422:	5f 92       	push	r5
    2424:	6f 92       	push	r6
    2426:	7f 92       	push	r7
    2428:	8f 92       	push	r8
    242a:	9f 92       	push	r9
    242c:	af 92       	push	r10
    242e:	bf 92       	push	r11
    2430:	cf 92       	push	r12
    2432:	df 92       	push	r13
    2434:	ef 92       	push	r14
    2436:	ff 92       	push	r15
    2438:	0f 93       	push	r16
    243a:	1f 93       	push	r17
    243c:	cf 93       	push	r28
    243e:	df 93       	push	r29
    2440:	4c 01       	movw	r8, r24
    2442:	eb 01       	movw	r28, r22
    2444:	5a 01       	movw	r10, r20
    2446:	29 01       	movw	r4, r18
    2448:	c1 14       	cp	r12, r1
    244a:	d1 04       	cpc	r13, r1
    244c:	31 f4       	brne	.+12     	; 0x245a <xTaskGenericCreate+0x3a>
    244e:	ca 01       	movw	r24, r20
    2450:	51 d8       	rcall	.-3934   	; 0x14f4 <pvPortMalloc>
    2452:	6c 01       	movw	r12, r24
    2454:	89 2b       	or	r24, r25
    2456:	09 f4       	brne	.+2      	; 0x245a <xTaskGenericCreate+0x3a>
    2458:	e1 c0       	rjmp	.+450    	; 0x261c <xTaskGenericCreate+0x1fc>
    245a:	88 e2       	ldi	r24, 0x28	; 40
    245c:	90 e0       	ldi	r25, 0x00	; 0
    245e:	4a d8       	rcall	.-3948   	; 0x14f4 <pvPortMalloc>
    2460:	3c 01       	movw	r6, r24
    2462:	00 97       	sbiw	r24, 0x00	; 0
    2464:	b9 f0       	breq	.+46     	; 0x2494 <xTaskGenericCreate+0x74>
    2466:	fc 01       	movw	r30, r24
    2468:	d0 8e       	std	Z+24, r13	; 0x18
    246a:	c7 8a       	std	Z+23, r12	; 0x17
    246c:	a5 01       	movw	r20, r10
    246e:	65 ea       	ldi	r22, 0xA5	; 165
    2470:	70 e0       	ldi	r23, 0x00	; 0
    2472:	c6 01       	movw	r24, r12
    2474:	0e 94 2e 20 	call	0x405c	; 0x405c <memset>
    2478:	f1 e0       	ldi	r31, 0x01	; 1
    247a:	af 1a       	sub	r10, r31
    247c:	b1 08       	sbc	r11, r1
    247e:	f3 01       	movw	r30, r6
    2480:	87 89       	ldd	r24, Z+23	; 0x17
    2482:	90 8d       	ldd	r25, Z+24	; 0x18
    2484:	a8 0e       	add	r10, r24
    2486:	b9 1e       	adc	r11, r25
    2488:	88 81       	ld	r24, Y
    248a:	81 8f       	std	Z+25, r24	; 0x19
    248c:	88 81       	ld	r24, Y
    248e:	81 11       	cpse	r24, r1
    2490:	04 c0       	rjmp	.+8      	; 0x249a <xTaskGenericCreate+0x7a>
    2492:	13 c0       	rjmp	.+38     	; 0x24ba <xTaskGenericCreate+0x9a>
    2494:	c6 01       	movw	r24, r12
    2496:	63 d8       	rcall	.-3898   	; 0x155e <vPortFree>
    2498:	c1 c0       	rjmp	.+386    	; 0x261c <xTaskGenericCreate+0x1fc>
    249a:	d3 01       	movw	r26, r6
    249c:	5a 96       	adiw	r26, 0x1a	; 26
    249e:	fe 01       	movw	r30, r28
    24a0:	31 96       	adiw	r30, 0x01	; 1
    24a2:	9e 01       	movw	r18, r28
    24a4:	28 5f       	subi	r18, 0xF8	; 248
    24a6:	3f 4f       	sbci	r19, 0xFF	; 255
    24a8:	ef 01       	movw	r28, r30
    24aa:	81 91       	ld	r24, Z+
    24ac:	8d 93       	st	X+, r24
    24ae:	88 81       	ld	r24, Y
    24b0:	88 23       	and	r24, r24
    24b2:	19 f0       	breq	.+6      	; 0x24ba <xTaskGenericCreate+0x9a>
    24b4:	2e 17       	cp	r18, r30
    24b6:	3f 07       	cpc	r19, r31
    24b8:	b9 f7       	brne	.-18     	; 0x24a8 <xTaskGenericCreate+0x88>
    24ba:	f3 01       	movw	r30, r6
    24bc:	10 a2       	std	Z+32, r1	; 0x20
    24be:	10 2f       	mov	r17, r16
    24c0:	04 30       	cpi	r16, 0x04	; 4
    24c2:	08 f0       	brcs	.+2      	; 0x24c6 <xTaskGenericCreate+0xa6>
    24c4:	13 e0       	ldi	r17, 0x03	; 3
    24c6:	f3 01       	movw	r30, r6
    24c8:	16 8b       	std	Z+22, r17	; 0x16
    24ca:	11 a3       	std	Z+33, r17	; 0x21
    24cc:	12 a2       	std	Z+34, r1	; 0x22
    24ce:	e3 01       	movw	r28, r6
    24d0:	22 96       	adiw	r28, 0x02	; 2
    24d2:	ce 01       	movw	r24, r28
    24d4:	53 d8       	rcall	.-3930   	; 0x157c <vListInitialiseItem>
    24d6:	c3 01       	movw	r24, r6
    24d8:	0c 96       	adiw	r24, 0x0c	; 12
    24da:	50 d8       	rcall	.-3936   	; 0x157c <vListInitialiseItem>
    24dc:	f3 01       	movw	r30, r6
    24de:	71 86       	std	Z+9, r7	; 0x09
    24e0:	60 86       	std	Z+8, r6	; 0x08
    24e2:	84 e0       	ldi	r24, 0x04	; 4
    24e4:	90 e0       	ldi	r25, 0x00	; 0
    24e6:	81 1b       	sub	r24, r17
    24e8:	91 09       	sbc	r25, r1
    24ea:	95 87       	std	Z+13, r25	; 0x0d
    24ec:	84 87       	std	Z+12, r24	; 0x0c
    24ee:	73 8a       	std	Z+19, r7	; 0x13
    24f0:	62 8a       	std	Z+18, r6	; 0x12
    24f2:	13 a2       	std	Z+35, r1	; 0x23
    24f4:	14 a2       	std	Z+36, r1	; 0x24
    24f6:	15 a2       	std	Z+37, r1	; 0x25
    24f8:	16 a2       	std	Z+38, r1	; 0x26
    24fa:	17 a2       	std	Z+39, r1	; 0x27
    24fc:	a2 01       	movw	r20, r4
    24fe:	b4 01       	movw	r22, r8
    2500:	c5 01       	movw	r24, r10
    2502:	b8 d8       	rcall	.-3728   	; 0x1674 <pxPortInitialiseStack>
    2504:	f3 01       	movw	r30, r6
    2506:	91 83       	std	Z+1, r25	; 0x01
    2508:	80 83       	st	Z, r24
    250a:	e1 14       	cp	r14, r1
    250c:	f1 04       	cpc	r15, r1
    250e:	19 f0       	breq	.+6      	; 0x2516 <xTaskGenericCreate+0xf6>
    2510:	f7 01       	movw	r30, r14
    2512:	71 82       	std	Z+1, r7	; 0x01
    2514:	60 82       	st	Z, r6
    2516:	0f b6       	in	r0, 0x3f	; 63
    2518:	f8 94       	cli
    251a:	0f 92       	push	r0
    251c:	80 91 a6 15 	lds	r24, 0x15A6	; 0x8015a6 <uxCurrentNumberOfTasks>
    2520:	8f 5f       	subi	r24, 0xFF	; 255
    2522:	80 93 a6 15 	sts	0x15A6, r24	; 0x8015a6 <uxCurrentNumberOfTasks>
    2526:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <pxCurrentTCB>
    252a:	90 91 fe 15 	lds	r25, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    252e:	89 2b       	or	r24, r25
    2530:	b1 f5       	brne	.+108    	; 0x259e <xTaskGenericCreate+0x17e>
    2532:	70 92 fe 15 	sts	0x15FE, r7	; 0x8015fe <pxCurrentTCB+0x1>
    2536:	60 92 fd 15 	sts	0x15FD, r6	; 0x8015fd <pxCurrentTCB>
    253a:	80 91 a6 15 	lds	r24, 0x15A6	; 0x8015a6 <uxCurrentNumberOfTasks>
    253e:	81 30       	cpi	r24, 0x01	; 1
    2540:	09 f0       	breq	.+2      	; 0x2544 <xTaskGenericCreate+0x124>
    2542:	3c c0       	rjmp	.+120    	; 0x25bc <xTaskGenericCreate+0x19c>
    2544:	89 ed       	ldi	r24, 0xD9	; 217
    2546:	95 e1       	ldi	r25, 0x15	; 21
    2548:	0b d8       	rcall	.-4074   	; 0x1560 <vListInitialise>
    254a:	82 ee       	ldi	r24, 0xE2	; 226
    254c:	95 e1       	ldi	r25, 0x15	; 21
    254e:	08 d8       	rcall	.-4080   	; 0x1560 <vListInitialise>
    2550:	8b ee       	ldi	r24, 0xEB	; 235
    2552:	95 e1       	ldi	r25, 0x15	; 21
    2554:	05 d8       	rcall	.-4086   	; 0x1560 <vListInitialise>
    2556:	84 ef       	ldi	r24, 0xF4	; 244
    2558:	95 e1       	ldi	r25, 0x15	; 21
    255a:	02 d8       	rcall	.-4092   	; 0x1560 <vListInitialise>
    255c:	80 ed       	ldi	r24, 0xD0	; 208
    255e:	95 e1       	ldi	r25, 0x15	; 21
    2560:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialise>
    2564:	87 ec       	ldi	r24, 0xC7	; 199
    2566:	95 e1       	ldi	r25, 0x15	; 21
    2568:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialise>
    256c:	8a eb       	ldi	r24, 0xBA	; 186
    256e:	95 e1       	ldi	r25, 0x15	; 21
    2570:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialise>
    2574:	81 eb       	ldi	r24, 0xB1	; 177
    2576:	95 e1       	ldi	r25, 0x15	; 21
    2578:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialise>
    257c:	87 ea       	ldi	r24, 0xA7	; 167
    257e:	95 e1       	ldi	r25, 0x15	; 21
    2580:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialise>
    2584:	80 ed       	ldi	r24, 0xD0	; 208
    2586:	95 e1       	ldi	r25, 0x15	; 21
    2588:	90 93 c6 15 	sts	0x15C6, r25	; 0x8015c6 <pxDelayedTaskList+0x1>
    258c:	80 93 c5 15 	sts	0x15C5, r24	; 0x8015c5 <pxDelayedTaskList>
    2590:	87 ec       	ldi	r24, 0xC7	; 199
    2592:	95 e1       	ldi	r25, 0x15	; 21
    2594:	90 93 c4 15 	sts	0x15C4, r25	; 0x8015c4 <pxOverflowDelayedTaskList+0x1>
    2598:	80 93 c3 15 	sts	0x15C3, r24	; 0x8015c3 <pxOverflowDelayedTaskList>
    259c:	0f c0       	rjmp	.+30     	; 0x25bc <xTaskGenericCreate+0x19c>
    259e:	80 91 a2 15 	lds	r24, 0x15A2	; 0x8015a2 <xSchedulerRunning>
    25a2:	81 11       	cpse	r24, r1
    25a4:	0b c0       	rjmp	.+22     	; 0x25bc <xTaskGenericCreate+0x19c>
    25a6:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    25aa:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    25ae:	86 89       	ldd	r24, Z+22	; 0x16
    25b0:	08 17       	cp	r16, r24
    25b2:	20 f0       	brcs	.+8      	; 0x25bc <xTaskGenericCreate+0x19c>
    25b4:	70 92 fe 15 	sts	0x15FE, r7	; 0x8015fe <pxCurrentTCB+0x1>
    25b8:	60 92 fd 15 	sts	0x15FD, r6	; 0x8015fd <pxCurrentTCB>
    25bc:	80 91 9e 15 	lds	r24, 0x159E	; 0x80159e <uxTaskNumber>
    25c0:	8f 5f       	subi	r24, 0xFF	; 255
    25c2:	80 93 9e 15 	sts	0x159E, r24	; 0x80159e <uxTaskNumber>
    25c6:	f3 01       	movw	r30, r6
    25c8:	86 89       	ldd	r24, Z+22	; 0x16
    25ca:	90 91 a3 15 	lds	r25, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
    25ce:	98 17       	cp	r25, r24
    25d0:	10 f4       	brcc	.+4      	; 0x25d6 <xTaskGenericCreate+0x1b6>
    25d2:	80 93 a3 15 	sts	0x15A3, r24	; 0x8015a3 <uxTopReadyPriority>
    25d6:	90 e0       	ldi	r25, 0x00	; 0
    25d8:	9c 01       	movw	r18, r24
    25da:	22 0f       	add	r18, r18
    25dc:	33 1f       	adc	r19, r19
    25de:	22 0f       	add	r18, r18
    25e0:	33 1f       	adc	r19, r19
    25e2:	22 0f       	add	r18, r18
    25e4:	33 1f       	adc	r19, r19
    25e6:	82 0f       	add	r24, r18
    25e8:	93 1f       	adc	r25, r19
    25ea:	be 01       	movw	r22, r28
    25ec:	87 52       	subi	r24, 0x27	; 39
    25ee:	9a 4e       	sbci	r25, 0xEA	; 234
    25f0:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    25f4:	0f 90       	pop	r0
    25f6:	0f be       	out	0x3f, r0	; 63
    25f8:	80 91 a2 15 	lds	r24, 0x15A2	; 0x8015a2 <xSchedulerRunning>
    25fc:	88 23       	and	r24, r24
    25fe:	51 f0       	breq	.+20     	; 0x2614 <xTaskGenericCreate+0x1f4>
    2600:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    2604:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    2608:	86 89       	ldd	r24, Z+22	; 0x16
    260a:	80 17       	cp	r24, r16
    260c:	28 f4       	brcc	.+10     	; 0x2618 <xTaskGenericCreate+0x1f8>
    260e:	ed d8       	rcall	.-3622   	; 0x17ea <vPortYield>
    2610:	81 e0       	ldi	r24, 0x01	; 1
    2612:	05 c0       	rjmp	.+10     	; 0x261e <xTaskGenericCreate+0x1fe>
    2614:	81 e0       	ldi	r24, 0x01	; 1
    2616:	03 c0       	rjmp	.+6      	; 0x261e <xTaskGenericCreate+0x1fe>
    2618:	81 e0       	ldi	r24, 0x01	; 1
    261a:	01 c0       	rjmp	.+2      	; 0x261e <xTaskGenericCreate+0x1fe>
    261c:	8f ef       	ldi	r24, 0xFF	; 255
    261e:	df 91       	pop	r29
    2620:	cf 91       	pop	r28
    2622:	1f 91       	pop	r17
    2624:	0f 91       	pop	r16
    2626:	ff 90       	pop	r15
    2628:	ef 90       	pop	r14
    262a:	df 90       	pop	r13
    262c:	cf 90       	pop	r12
    262e:	bf 90       	pop	r11
    2630:	af 90       	pop	r10
    2632:	9f 90       	pop	r9
    2634:	8f 90       	pop	r8
    2636:	7f 90       	pop	r7
    2638:	6f 90       	pop	r6
    263a:	5f 90       	pop	r5
    263c:	4f 90       	pop	r4
    263e:	08 95       	ret

00002640 <vTaskDelay>:
    2640:	9f 92       	push	r9
    2642:	af 92       	push	r10
    2644:	bf 92       	push	r11
    2646:	cf 92       	push	r12
    2648:	df 92       	push	r13
    264a:	ef 92       	push	r14
    264c:	ff 92       	push	r15
    264e:	0f 93       	push	r16
    2650:	1f 93       	push	r17
    2652:	cf 93       	push	r28
    2654:	df 93       	push	r29
    2656:	00 97       	sbiw	r24, 0x00	; 0
    2658:	09 f4       	brne	.+2      	; 0x265c <vTaskDelay+0x1c>
    265a:	7e c1       	rjmp	.+764    	; 0x2958 <vTaskDelay+0x318>
    265c:	20 91 9b 15 	lds	r18, 0x159B	; 0x80159b <uxSchedulerSuspended>
    2660:	2f 5f       	subi	r18, 0xFF	; 255
    2662:	20 93 9b 15 	sts	0x159B, r18	; 0x80159b <uxSchedulerSuspended>
    2666:	c0 91 a4 15 	lds	r28, 0x15A4	; 0x8015a4 <xTickCount>
    266a:	d0 91 a5 15 	lds	r29, 0x15A5	; 0x8015a5 <xTickCount+0x1>
    266e:	c8 0f       	add	r28, r24
    2670:	d9 1f       	adc	r29, r25
    2672:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <pxCurrentTCB>
    2676:	90 91 fe 15 	lds	r25, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    267a:	02 96       	adiw	r24, 0x02	; 2
    267c:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    2680:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    2684:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    2688:	d3 83       	std	Z+3, r29	; 0x03
    268a:	c2 83       	std	Z+2, r28	; 0x02
    268c:	80 91 a4 15 	lds	r24, 0x15A4	; 0x8015a4 <xTickCount>
    2690:	90 91 a5 15 	lds	r25, 0x15A5	; 0x8015a5 <xTickCount+0x1>
    2694:	c8 17       	cp	r28, r24
    2696:	d9 07       	cpc	r29, r25
    2698:	68 f4       	brcc	.+26     	; 0x26b4 <vTaskDelay+0x74>
    269a:	60 91 fd 15 	lds	r22, 0x15FD	; 0x8015fd <pxCurrentTCB>
    269e:	70 91 fe 15 	lds	r23, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    26a2:	80 91 c3 15 	lds	r24, 0x15C3	; 0x8015c3 <pxOverflowDelayedTaskList>
    26a6:	90 91 c4 15 	lds	r25, 0x15C4	; 0x8015c4 <pxOverflowDelayedTaskList+0x1>
    26aa:	6e 5f       	subi	r22, 0xFE	; 254
    26ac:	7f 4f       	sbci	r23, 0xFF	; 255
    26ae:	0e 94 e3 0a 	call	0x15c6	; 0x15c6 <vListInsert>
    26b2:	17 c0       	rjmp	.+46     	; 0x26e2 <vTaskDelay+0xa2>
    26b4:	60 91 fd 15 	lds	r22, 0x15FD	; 0x8015fd <pxCurrentTCB>
    26b8:	70 91 fe 15 	lds	r23, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    26bc:	80 91 c5 15 	lds	r24, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    26c0:	90 91 c6 15 	lds	r25, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    26c4:	6e 5f       	subi	r22, 0xFE	; 254
    26c6:	7f 4f       	sbci	r23, 0xFF	; 255
    26c8:	0e 94 e3 0a 	call	0x15c6	; 0x15c6 <vListInsert>
    26cc:	80 91 9c 15 	lds	r24, 0x159C	; 0x80159c <xNextTaskUnblockTime>
    26d0:	90 91 9d 15 	lds	r25, 0x159D	; 0x80159d <xNextTaskUnblockTime+0x1>
    26d4:	c8 17       	cp	r28, r24
    26d6:	d9 07       	cpc	r29, r25
    26d8:	20 f4       	brcc	.+8      	; 0x26e2 <vTaskDelay+0xa2>
    26da:	d0 93 9d 15 	sts	0x159D, r29	; 0x80159d <xNextTaskUnblockTime+0x1>
    26de:	c0 93 9c 15 	sts	0x159C, r28	; 0x80159c <xNextTaskUnblockTime>
    26e2:	0f b6       	in	r0, 0x3f	; 63
    26e4:	f8 94       	cli
    26e6:	0f 92       	push	r0
    26e8:	80 91 9b 15 	lds	r24, 0x159B	; 0x80159b <uxSchedulerSuspended>
    26ec:	81 50       	subi	r24, 0x01	; 1
    26ee:	80 93 9b 15 	sts	0x159B, r24	; 0x80159b <uxSchedulerSuspended>
    26f2:	80 91 9b 15 	lds	r24, 0x159B	; 0x80159b <uxSchedulerSuspended>
    26f6:	81 11       	cpse	r24, r1
    26f8:	28 c1       	rjmp	.+592    	; 0x294a <vTaskDelay+0x30a>
    26fa:	80 91 a6 15 	lds	r24, 0x15A6	; 0x8015a6 <uxCurrentNumberOfTasks>
    26fe:	81 11       	cpse	r24, r1
    2700:	33 c0       	rjmp	.+102    	; 0x2768 <vTaskDelay+0x128>
    2702:	26 c1       	rjmp	.+588    	; 0x2950 <vTaskDelay+0x310>
    2704:	d7 01       	movw	r26, r14
    2706:	15 96       	adiw	r26, 0x05	; 5
    2708:	ed 91       	ld	r30, X+
    270a:	fc 91       	ld	r31, X
    270c:	16 97       	sbiw	r26, 0x06	; 6
    270e:	c6 81       	ldd	r28, Z+6	; 0x06
    2710:	d7 81       	ldd	r29, Z+7	; 0x07
    2712:	ce 01       	movw	r24, r28
    2714:	0c 96       	adiw	r24, 0x0c	; 12
    2716:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    271a:	8e 01       	movw	r16, r28
    271c:	0e 5f       	subi	r16, 0xFE	; 254
    271e:	1f 4f       	sbci	r17, 0xFF	; 255
    2720:	c8 01       	movw	r24, r16
    2722:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    2726:	8e 89       	ldd	r24, Y+22	; 0x16
    2728:	90 91 a3 15 	lds	r25, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
    272c:	98 17       	cp	r25, r24
    272e:	10 f4       	brcc	.+4      	; 0x2734 <vTaskDelay+0xf4>
    2730:	80 93 a3 15 	sts	0x15A3, r24	; 0x8015a3 <uxTopReadyPriority>
    2734:	90 e0       	ldi	r25, 0x00	; 0
    2736:	9c 01       	movw	r18, r24
    2738:	22 0f       	add	r18, r18
    273a:	33 1f       	adc	r19, r19
    273c:	22 0f       	add	r18, r18
    273e:	33 1f       	adc	r19, r19
    2740:	22 0f       	add	r18, r18
    2742:	33 1f       	adc	r19, r19
    2744:	82 0f       	add	r24, r18
    2746:	93 1f       	adc	r25, r19
    2748:	b8 01       	movw	r22, r16
    274a:	87 52       	subi	r24, 0x27	; 39
    274c:	9a 4e       	sbci	r25, 0xEA	; 234
    274e:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    2752:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    2756:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    275a:	9e 89       	ldd	r25, Y+22	; 0x16
    275c:	86 89       	ldd	r24, Z+22	; 0x16
    275e:	98 17       	cp	r25, r24
    2760:	58 f0       	brcs	.+22     	; 0x2778 <vTaskDelay+0x138>
    2762:	d0 92 a0 15 	sts	0x15A0, r13	; 0x8015a0 <xYieldPending>
    2766:	08 c0       	rjmp	.+16     	; 0x2778 <vTaskDelay+0x138>
    2768:	0f 2e       	mov	r0, r31
    276a:	fa eb       	ldi	r31, 0xBA	; 186
    276c:	ef 2e       	mov	r14, r31
    276e:	f5 e1       	ldi	r31, 0x15	; 21
    2770:	ff 2e       	mov	r15, r31
    2772:	f0 2d       	mov	r31, r0
    2774:	dd 24       	eor	r13, r13
    2776:	d3 94       	inc	r13
    2778:	f7 01       	movw	r30, r14
    277a:	80 81       	ld	r24, Z
    277c:	81 11       	cpse	r24, r1
    277e:	c2 cf       	rjmp	.-124    	; 0x2704 <vTaskDelay+0xc4>
    2780:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
    2784:	88 23       	and	r24, r24
    2786:	09 f4       	brne	.+2      	; 0x278a <vTaskDelay+0x14a>
    2788:	d8 c0       	rjmp	.+432    	; 0x293a <vTaskDelay+0x2fa>
    278a:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
    278e:	88 23       	and	r24, r24
    2790:	09 f4       	brne	.+2      	; 0x2794 <vTaskDelay+0x154>
    2792:	d3 c0       	rjmp	.+422    	; 0x293a <vTaskDelay+0x2fa>
    2794:	91 2c       	mov	r9, r1
    2796:	bb 24       	eor	r11, r11
    2798:	b3 94       	inc	r11
    279a:	cc 24       	eor	r12, r12
    279c:	ca 94       	dec	r12
    279e:	dc 2c       	mov	r13, r12
    27a0:	80 91 9b 15 	lds	r24, 0x159B	; 0x80159b <uxSchedulerSuspended>
    27a4:	81 11       	cpse	r24, r1
    27a6:	af c0       	rjmp	.+350    	; 0x2906 <vTaskDelay+0x2c6>
    27a8:	80 91 a4 15 	lds	r24, 0x15A4	; 0x8015a4 <xTickCount>
    27ac:	90 91 a5 15 	lds	r25, 0x15A5	; 0x8015a5 <xTickCount+0x1>
    27b0:	01 96       	adiw	r24, 0x01	; 1
    27b2:	90 93 a5 15 	sts	0x15A5, r25	; 0x8015a5 <xTickCount+0x1>
    27b6:	80 93 a4 15 	sts	0x15A4, r24	; 0x8015a4 <xTickCount>
    27ba:	e0 90 a4 15 	lds	r14, 0x15A4	; 0x8015a4 <xTickCount>
    27be:	f0 90 a5 15 	lds	r15, 0x15A5	; 0x8015a5 <xTickCount+0x1>
    27c2:	e1 14       	cp	r14, r1
    27c4:	f1 04       	cpc	r15, r1
    27c6:	89 f5       	brne	.+98     	; 0x282a <vTaskDelay+0x1ea>
    27c8:	80 91 c5 15 	lds	r24, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    27cc:	90 91 c6 15 	lds	r25, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    27d0:	20 91 c3 15 	lds	r18, 0x15C3	; 0x8015c3 <pxOverflowDelayedTaskList>
    27d4:	30 91 c4 15 	lds	r19, 0x15C4	; 0x8015c4 <pxOverflowDelayedTaskList+0x1>
    27d8:	30 93 c6 15 	sts	0x15C6, r19	; 0x8015c6 <pxDelayedTaskList+0x1>
    27dc:	20 93 c5 15 	sts	0x15C5, r18	; 0x8015c5 <pxDelayedTaskList>
    27e0:	90 93 c4 15 	sts	0x15C4, r25	; 0x8015c4 <pxOverflowDelayedTaskList+0x1>
    27e4:	80 93 c3 15 	sts	0x15C3, r24	; 0x8015c3 <pxOverflowDelayedTaskList>
    27e8:	80 91 9f 15 	lds	r24, 0x159F	; 0x80159f <xNumOfOverflows>
    27ec:	8f 5f       	subi	r24, 0xFF	; 255
    27ee:	80 93 9f 15 	sts	0x159F, r24	; 0x80159f <xNumOfOverflows>
    27f2:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    27f6:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    27fa:	80 81       	ld	r24, Z
    27fc:	81 11       	cpse	r24, r1
    27fe:	05 c0       	rjmp	.+10     	; 0x280a <vTaskDelay+0x1ca>
    2800:	d0 92 9d 15 	sts	0x159D, r13	; 0x80159d <xNextTaskUnblockTime+0x1>
    2804:	c0 92 9c 15 	sts	0x159C, r12	; 0x80159c <xNextTaskUnblockTime>
    2808:	10 c0       	rjmp	.+32     	; 0x282a <vTaskDelay+0x1ea>
    280a:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    280e:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    2812:	05 80       	ldd	r0, Z+5	; 0x05
    2814:	f6 81       	ldd	r31, Z+6	; 0x06
    2816:	e0 2d       	mov	r30, r0
    2818:	06 80       	ldd	r0, Z+6	; 0x06
    281a:	f7 81       	ldd	r31, Z+7	; 0x07
    281c:	e0 2d       	mov	r30, r0
    281e:	82 81       	ldd	r24, Z+2	; 0x02
    2820:	93 81       	ldd	r25, Z+3	; 0x03
    2822:	90 93 9d 15 	sts	0x159D, r25	; 0x80159d <xNextTaskUnblockTime+0x1>
    2826:	80 93 9c 15 	sts	0x159C, r24	; 0x80159c <xNextTaskUnblockTime>
    282a:	80 91 9c 15 	lds	r24, 0x159C	; 0x80159c <xNextTaskUnblockTime>
    282e:	90 91 9d 15 	lds	r25, 0x159D	; 0x80159d <xNextTaskUnblockTime+0x1>
    2832:	e8 16       	cp	r14, r24
    2834:	f9 06       	cpc	r15, r25
    2836:	10 f4       	brcc	.+4      	; 0x283c <vTaskDelay+0x1fc>
    2838:	a9 2c       	mov	r10, r9
    283a:	4f c0       	rjmp	.+158    	; 0x28da <vTaskDelay+0x29a>
    283c:	a9 2c       	mov	r10, r9
    283e:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    2842:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    2846:	80 81       	ld	r24, Z
    2848:	81 11       	cpse	r24, r1
    284a:	05 c0       	rjmp	.+10     	; 0x2856 <vTaskDelay+0x216>
    284c:	d0 92 9d 15 	sts	0x159D, r13	; 0x80159d <xNextTaskUnblockTime+0x1>
    2850:	c0 92 9c 15 	sts	0x159C, r12	; 0x80159c <xNextTaskUnblockTime>
    2854:	42 c0       	rjmp	.+132    	; 0x28da <vTaskDelay+0x29a>
    2856:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    285a:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    285e:	05 80       	ldd	r0, Z+5	; 0x05
    2860:	f6 81       	ldd	r31, Z+6	; 0x06
    2862:	e0 2d       	mov	r30, r0
    2864:	c6 81       	ldd	r28, Z+6	; 0x06
    2866:	d7 81       	ldd	r29, Z+7	; 0x07
    2868:	8a 81       	ldd	r24, Y+2	; 0x02
    286a:	9b 81       	ldd	r25, Y+3	; 0x03
    286c:	e8 16       	cp	r14, r24
    286e:	f9 06       	cpc	r15, r25
    2870:	28 f4       	brcc	.+10     	; 0x287c <vTaskDelay+0x23c>
    2872:	90 93 9d 15 	sts	0x159D, r25	; 0x80159d <xNextTaskUnblockTime+0x1>
    2876:	80 93 9c 15 	sts	0x159C, r24	; 0x80159c <xNextTaskUnblockTime>
    287a:	2f c0       	rjmp	.+94     	; 0x28da <vTaskDelay+0x29a>
    287c:	8e 01       	movw	r16, r28
    287e:	0e 5f       	subi	r16, 0xFE	; 254
    2880:	1f 4f       	sbci	r17, 0xFF	; 255
    2882:	c8 01       	movw	r24, r16
    2884:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    2888:	8c 89       	ldd	r24, Y+20	; 0x14
    288a:	9d 89       	ldd	r25, Y+21	; 0x15
    288c:	89 2b       	or	r24, r25
    288e:	21 f0       	breq	.+8      	; 0x2898 <vTaskDelay+0x258>
    2890:	ce 01       	movw	r24, r28
    2892:	0c 96       	adiw	r24, 0x0c	; 12
    2894:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    2898:	8e 89       	ldd	r24, Y+22	; 0x16
    289a:	90 91 a3 15 	lds	r25, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
    289e:	98 17       	cp	r25, r24
    28a0:	10 f4       	brcc	.+4      	; 0x28a6 <vTaskDelay+0x266>
    28a2:	80 93 a3 15 	sts	0x15A3, r24	; 0x8015a3 <uxTopReadyPriority>
    28a6:	90 e0       	ldi	r25, 0x00	; 0
    28a8:	9c 01       	movw	r18, r24
    28aa:	22 0f       	add	r18, r18
    28ac:	33 1f       	adc	r19, r19
    28ae:	22 0f       	add	r18, r18
    28b0:	33 1f       	adc	r19, r19
    28b2:	22 0f       	add	r18, r18
    28b4:	33 1f       	adc	r19, r19
    28b6:	82 0f       	add	r24, r18
    28b8:	93 1f       	adc	r25, r19
    28ba:	b8 01       	movw	r22, r16
    28bc:	87 52       	subi	r24, 0x27	; 39
    28be:	9a 4e       	sbci	r25, 0xEA	; 234
    28c0:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    28c4:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    28c8:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    28cc:	9e 89       	ldd	r25, Y+22	; 0x16
    28ce:	86 89       	ldd	r24, Z+22	; 0x16
    28d0:	98 17       	cp	r25, r24
    28d2:	08 f4       	brcc	.+2      	; 0x28d6 <vTaskDelay+0x296>
    28d4:	b4 cf       	rjmp	.-152    	; 0x283e <vTaskDelay+0x1fe>
    28d6:	ab 2c       	mov	r10, r11
    28d8:	b2 cf       	rjmp	.-156    	; 0x283e <vTaskDelay+0x1fe>
    28da:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    28de:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    28e2:	86 89       	ldd	r24, Z+22	; 0x16
    28e4:	90 e0       	ldi	r25, 0x00	; 0
    28e6:	fc 01       	movw	r30, r24
    28e8:	ee 0f       	add	r30, r30
    28ea:	ff 1f       	adc	r31, r31
    28ec:	ee 0f       	add	r30, r30
    28ee:	ff 1f       	adc	r31, r31
    28f0:	ee 0f       	add	r30, r30
    28f2:	ff 1f       	adc	r31, r31
    28f4:	8e 0f       	add	r24, r30
    28f6:	9f 1f       	adc	r25, r31
    28f8:	fc 01       	movw	r30, r24
    28fa:	e7 52       	subi	r30, 0x27	; 39
    28fc:	fa 4e       	sbci	r31, 0xEA	; 234
    28fe:	80 81       	ld	r24, Z
    2900:	82 30       	cpi	r24, 0x02	; 2
    2902:	68 f5       	brcc	.+90     	; 0x295e <vTaskDelay+0x31e>
    2904:	0a c0       	rjmp	.+20     	; 0x291a <vTaskDelay+0x2da>
    2906:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
    290a:	8f 5f       	subi	r24, 0xFF	; 255
    290c:	80 93 a1 15 	sts	0x15A1, r24	; 0x8015a1 <uxPendedTicks>
    2910:	80 91 a0 15 	lds	r24, 0x15A0	; 0x8015a0 <xYieldPending>
    2914:	88 23       	and	r24, r24
    2916:	41 f0       	breq	.+16     	; 0x2928 <vTaskDelay+0x2e8>
    2918:	05 c0       	rjmp	.+10     	; 0x2924 <vTaskDelay+0x2e4>
    291a:	80 91 a0 15 	lds	r24, 0x15A0	; 0x8015a0 <xYieldPending>
    291e:	81 11       	cpse	r24, r1
    2920:	01 c0       	rjmp	.+2      	; 0x2924 <vTaskDelay+0x2e4>
    2922:	a1 10       	cpse	r10, r1
    2924:	b0 92 a0 15 	sts	0x15A0, r11	; 0x8015a0 <xYieldPending>
    2928:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
    292c:	81 50       	subi	r24, 0x01	; 1
    292e:	80 93 a1 15 	sts	0x15A1, r24	; 0x8015a1 <uxPendedTicks>
    2932:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
    2936:	81 11       	cpse	r24, r1
    2938:	33 cf       	rjmp	.-410    	; 0x27a0 <vTaskDelay+0x160>
    293a:	80 91 a0 15 	lds	r24, 0x15A0	; 0x8015a0 <xYieldPending>
    293e:	81 30       	cpi	r24, 0x01	; 1
    2940:	31 f4       	brne	.+12     	; 0x294e <vTaskDelay+0x30e>
    2942:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <vPortYield>
    2946:	81 e0       	ldi	r24, 0x01	; 1
    2948:	03 c0       	rjmp	.+6      	; 0x2950 <vTaskDelay+0x310>
    294a:	80 e0       	ldi	r24, 0x00	; 0
    294c:	01 c0       	rjmp	.+2      	; 0x2950 <vTaskDelay+0x310>
    294e:	80 e0       	ldi	r24, 0x00	; 0
    2950:	0f 90       	pop	r0
    2952:	0f be       	out	0x3f, r0	; 63
    2954:	81 11       	cpse	r24, r1
    2956:	06 c0       	rjmp	.+12     	; 0x2964 <vTaskDelay+0x324>
    2958:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <vPortYield>
    295c:	03 c0       	rjmp	.+6      	; 0x2964 <vTaskDelay+0x324>
    295e:	80 91 a0 15 	lds	r24, 0x15A0	; 0x8015a0 <xYieldPending>
    2962:	e0 cf       	rjmp	.-64     	; 0x2924 <vTaskDelay+0x2e4>
    2964:	df 91       	pop	r29
    2966:	cf 91       	pop	r28
    2968:	1f 91       	pop	r17
    296a:	0f 91       	pop	r16
    296c:	ff 90       	pop	r15
    296e:	ef 90       	pop	r14
    2970:	df 90       	pop	r13
    2972:	cf 90       	pop	r12
    2974:	bf 90       	pop	r11
    2976:	af 90       	pop	r10
    2978:	9f 90       	pop	r9
    297a:	08 95       	ret

0000297c <vTaskStartScheduler>:
    297c:	ef 92       	push	r14
    297e:	ff 92       	push	r15
    2980:	0f 93       	push	r16
    2982:	1f 93       	push	r17
    2984:	cf 93       	push	r28
    2986:	df 93       	push	r29
    2988:	84 e6       	ldi	r24, 0x64	; 100
    298a:	90 e0       	ldi	r25, 0x00	; 0
    298c:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <pvPortMalloc>
    2990:	8c 01       	movw	r16, r24
    2992:	89 2b       	or	r24, r25
    2994:	09 f4       	brne	.+2      	; 0x2998 <vTaskStartScheduler+0x1c>
    2996:	d9 c0       	rjmp	.+434    	; 0x2b4a <vTaskStartScheduler+0x1ce>
    2998:	88 e2       	ldi	r24, 0x28	; 40
    299a:	90 e0       	ldi	r25, 0x00	; 0
    299c:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <pvPortMalloc>
    29a0:	ec 01       	movw	r28, r24
    29a2:	89 2b       	or	r24, r25
    29a4:	b1 f0       	breq	.+44     	; 0x29d2 <vTaskStartScheduler+0x56>
    29a6:	18 8f       	std	Y+24, r17	; 0x18
    29a8:	0f 8b       	std	Y+23, r16	; 0x17
    29aa:	44 e6       	ldi	r20, 0x64	; 100
    29ac:	50 e0       	ldi	r21, 0x00	; 0
    29ae:	65 ea       	ldi	r22, 0xA5	; 165
    29b0:	70 e0       	ldi	r23, 0x00	; 0
    29b2:	c8 01       	movw	r24, r16
    29b4:	0e 94 2e 20 	call	0x405c	; 0x405c <memset>
    29b8:	0f 89       	ldd	r16, Y+23	; 0x17
    29ba:	18 8d       	ldd	r17, Y+24	; 0x18
    29bc:	0d 59       	subi	r16, 0x9D	; 157
    29be:	1f 4f       	sbci	r17, 0xFF	; 255
    29c0:	89 e4       	ldi	r24, 0x49	; 73
    29c2:	89 8f       	std	Y+25, r24	; 0x19
    29c4:	e9 e6       	ldi	r30, 0x69	; 105
    29c6:	f3 e0       	ldi	r31, 0x03	; 3
    29c8:	de 01       	movw	r26, r28
    29ca:	5a 96       	adiw	r26, 0x1a	; 26
    29cc:	20 e7       	ldi	r18, 0x70	; 112
    29ce:	33 e0       	ldi	r19, 0x03	; 3
    29d0:	04 c0       	rjmp	.+8      	; 0x29da <vTaskStartScheduler+0x5e>
    29d2:	c8 01       	movw	r24, r16
    29d4:	0e 94 af 0a 	call	0x155e	; 0x155e <vPortFree>
    29d8:	b8 c0       	rjmp	.+368    	; 0x2b4a <vTaskStartScheduler+0x1ce>
    29da:	81 91       	ld	r24, Z+
    29dc:	8d 93       	st	X+, r24
    29de:	88 23       	and	r24, r24
    29e0:	19 f0       	breq	.+6      	; 0x29e8 <vTaskStartScheduler+0x6c>
    29e2:	e2 17       	cp	r30, r18
    29e4:	f3 07       	cpc	r31, r19
    29e6:	c9 f7       	brne	.-14     	; 0x29da <vTaskStartScheduler+0x5e>
    29e8:	18 a2       	std	Y+32, r1	; 0x20
    29ea:	1e 8a       	std	Y+22, r1	; 0x16
    29ec:	19 a2       	std	Y+33, r1	; 0x21
    29ee:	1a a2       	std	Y+34, r1	; 0x22
    29f0:	7e 01       	movw	r14, r28
    29f2:	82 e0       	ldi	r24, 0x02	; 2
    29f4:	e8 0e       	add	r14, r24
    29f6:	f1 1c       	adc	r15, r1
    29f8:	c7 01       	movw	r24, r14
    29fa:	0e 94 be 0a 	call	0x157c	; 0x157c <vListInitialiseItem>
    29fe:	ce 01       	movw	r24, r28
    2a00:	0c 96       	adiw	r24, 0x0c	; 12
    2a02:	0e 94 be 0a 	call	0x157c	; 0x157c <vListInitialiseItem>
    2a06:	d9 87       	std	Y+9, r29	; 0x09
    2a08:	c8 87       	std	Y+8, r28	; 0x08
    2a0a:	84 e0       	ldi	r24, 0x04	; 4
    2a0c:	90 e0       	ldi	r25, 0x00	; 0
    2a0e:	9d 87       	std	Y+13, r25	; 0x0d
    2a10:	8c 87       	std	Y+12, r24	; 0x0c
    2a12:	db 8b       	std	Y+19, r29	; 0x13
    2a14:	ca 8b       	std	Y+18, r28	; 0x12
    2a16:	1b a2       	std	Y+35, r1	; 0x23
    2a18:	1c a2       	std	Y+36, r1	; 0x24
    2a1a:	1d a2       	std	Y+37, r1	; 0x25
    2a1c:	1e a2       	std	Y+38, r1	; 0x26
    2a1e:	1f a2       	std	Y+39, r1	; 0x27
    2a20:	40 e0       	ldi	r20, 0x00	; 0
    2a22:	50 e0       	ldi	r21, 0x00	; 0
    2a24:	62 e8       	ldi	r22, 0x82	; 130
    2a26:	70 e0       	ldi	r23, 0x00	; 0
    2a28:	c8 01       	movw	r24, r16
    2a2a:	0e 94 3a 0b 	call	0x1674	; 0x1674 <pxPortInitialiseStack>
    2a2e:	99 83       	std	Y+1, r25	; 0x01
    2a30:	88 83       	st	Y, r24
    2a32:	0f b6       	in	r0, 0x3f	; 63
    2a34:	f8 94       	cli
    2a36:	0f 92       	push	r0
    2a38:	80 91 a6 15 	lds	r24, 0x15A6	; 0x8015a6 <uxCurrentNumberOfTasks>
    2a3c:	8f 5f       	subi	r24, 0xFF	; 255
    2a3e:	80 93 a6 15 	sts	0x15A6, r24	; 0x8015a6 <uxCurrentNumberOfTasks>
    2a42:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <pxCurrentTCB>
    2a46:	90 91 fe 15 	lds	r25, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    2a4a:	89 2b       	or	r24, r25
    2a4c:	d1 f5       	brne	.+116    	; 0x2ac2 <vTaskStartScheduler+0x146>
    2a4e:	d0 93 fe 15 	sts	0x15FE, r29	; 0x8015fe <pxCurrentTCB+0x1>
    2a52:	c0 93 fd 15 	sts	0x15FD, r28	; 0x8015fd <pxCurrentTCB>
    2a56:	80 91 a6 15 	lds	r24, 0x15A6	; 0x8015a6 <uxCurrentNumberOfTasks>
    2a5a:	81 30       	cpi	r24, 0x01	; 1
    2a5c:	09 f0       	breq	.+2      	; 0x2a60 <vTaskStartScheduler+0xe4>
    2a5e:	40 c0       	rjmp	.+128    	; 0x2ae0 <vTaskStartScheduler+0x164>
    2a60:	89 ed       	ldi	r24, 0xD9	; 217
    2a62:	95 e1       	ldi	r25, 0x15	; 21
    2a64:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialise>
    2a68:	82 ee       	ldi	r24, 0xE2	; 226
    2a6a:	95 e1       	ldi	r25, 0x15	; 21
    2a6c:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialise>
    2a70:	8b ee       	ldi	r24, 0xEB	; 235
    2a72:	95 e1       	ldi	r25, 0x15	; 21
    2a74:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialise>
    2a78:	84 ef       	ldi	r24, 0xF4	; 244
    2a7a:	95 e1       	ldi	r25, 0x15	; 21
    2a7c:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialise>
    2a80:	80 ed       	ldi	r24, 0xD0	; 208
    2a82:	95 e1       	ldi	r25, 0x15	; 21
    2a84:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialise>
    2a88:	87 ec       	ldi	r24, 0xC7	; 199
    2a8a:	95 e1       	ldi	r25, 0x15	; 21
    2a8c:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialise>
    2a90:	8a eb       	ldi	r24, 0xBA	; 186
    2a92:	95 e1       	ldi	r25, 0x15	; 21
    2a94:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialise>
    2a98:	81 eb       	ldi	r24, 0xB1	; 177
    2a9a:	95 e1       	ldi	r25, 0x15	; 21
    2a9c:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialise>
    2aa0:	87 ea       	ldi	r24, 0xA7	; 167
    2aa2:	95 e1       	ldi	r25, 0x15	; 21
    2aa4:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialise>
    2aa8:	80 ed       	ldi	r24, 0xD0	; 208
    2aaa:	95 e1       	ldi	r25, 0x15	; 21
    2aac:	90 93 c6 15 	sts	0x15C6, r25	; 0x8015c6 <pxDelayedTaskList+0x1>
    2ab0:	80 93 c5 15 	sts	0x15C5, r24	; 0x8015c5 <pxDelayedTaskList>
    2ab4:	87 ec       	ldi	r24, 0xC7	; 199
    2ab6:	95 e1       	ldi	r25, 0x15	; 21
    2ab8:	90 93 c4 15 	sts	0x15C4, r25	; 0x8015c4 <pxOverflowDelayedTaskList+0x1>
    2abc:	80 93 c3 15 	sts	0x15C3, r24	; 0x8015c3 <pxOverflowDelayedTaskList>
    2ac0:	0f c0       	rjmp	.+30     	; 0x2ae0 <vTaskStartScheduler+0x164>
    2ac2:	80 91 a2 15 	lds	r24, 0x15A2	; 0x8015a2 <xSchedulerRunning>
    2ac6:	81 11       	cpse	r24, r1
    2ac8:	0b c0       	rjmp	.+22     	; 0x2ae0 <vTaskStartScheduler+0x164>
    2aca:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    2ace:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    2ad2:	86 89       	ldd	r24, Z+22	; 0x16
    2ad4:	81 11       	cpse	r24, r1
    2ad6:	04 c0       	rjmp	.+8      	; 0x2ae0 <vTaskStartScheduler+0x164>
    2ad8:	d0 93 fe 15 	sts	0x15FE, r29	; 0x8015fe <pxCurrentTCB+0x1>
    2adc:	c0 93 fd 15 	sts	0x15FD, r28	; 0x8015fd <pxCurrentTCB>
    2ae0:	80 91 9e 15 	lds	r24, 0x159E	; 0x80159e <uxTaskNumber>
    2ae4:	8f 5f       	subi	r24, 0xFF	; 255
    2ae6:	80 93 9e 15 	sts	0x159E, r24	; 0x80159e <uxTaskNumber>
    2aea:	8e 89       	ldd	r24, Y+22	; 0x16
    2aec:	90 91 a3 15 	lds	r25, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
    2af0:	98 17       	cp	r25, r24
    2af2:	10 f4       	brcc	.+4      	; 0x2af8 <vTaskStartScheduler+0x17c>
    2af4:	80 93 a3 15 	sts	0x15A3, r24	; 0x8015a3 <uxTopReadyPriority>
    2af8:	90 e0       	ldi	r25, 0x00	; 0
    2afa:	9c 01       	movw	r18, r24
    2afc:	22 0f       	add	r18, r18
    2afe:	33 1f       	adc	r19, r19
    2b00:	22 0f       	add	r18, r18
    2b02:	33 1f       	adc	r19, r19
    2b04:	22 0f       	add	r18, r18
    2b06:	33 1f       	adc	r19, r19
    2b08:	82 0f       	add	r24, r18
    2b0a:	93 1f       	adc	r25, r19
    2b0c:	b7 01       	movw	r22, r14
    2b0e:	87 52       	subi	r24, 0x27	; 39
    2b10:	9a 4e       	sbci	r25, 0xEA	; 234
    2b12:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    2b16:	0f 90       	pop	r0
    2b18:	0f be       	out	0x3f, r0	; 63
    2b1a:	80 91 a2 15 	lds	r24, 0x15A2	; 0x8015a2 <xSchedulerRunning>
    2b1e:	88 23       	and	r24, r24
    2b20:	21 f0       	breq	.+8      	; 0x2b2a <vTaskStartScheduler+0x1ae>
    2b22:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <pxCurrentTCB>
    2b26:	90 91 fe 15 	lds	r25, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    2b2a:	f8 94       	cli
    2b2c:	8f ef       	ldi	r24, 0xFF	; 255
    2b2e:	9f ef       	ldi	r25, 0xFF	; 255
    2b30:	90 93 9d 15 	sts	0x159D, r25	; 0x80159d <xNextTaskUnblockTime+0x1>
    2b34:	80 93 9c 15 	sts	0x159C, r24	; 0x80159c <xNextTaskUnblockTime>
    2b38:	81 e0       	ldi	r24, 0x01	; 1
    2b3a:	80 93 a2 15 	sts	0x15A2, r24	; 0x8015a2 <xSchedulerRunning>
    2b3e:	10 92 a5 15 	sts	0x15A5, r1	; 0x8015a5 <xTickCount+0x1>
    2b42:	10 92 a4 15 	sts	0x15A4, r1	; 0x8015a4 <xTickCount>
    2b46:	0e 94 ac 0b 	call	0x1758	; 0x1758 <xPortStartScheduler>
    2b4a:	df 91       	pop	r29
    2b4c:	cf 91       	pop	r28
    2b4e:	1f 91       	pop	r17
    2b50:	0f 91       	pop	r16
    2b52:	ff 90       	pop	r15
    2b54:	ef 90       	pop	r14
    2b56:	08 95       	ret

00002b58 <vTaskSuspendAll>:
    2b58:	80 91 9b 15 	lds	r24, 0x159B	; 0x80159b <uxSchedulerSuspended>
    2b5c:	8f 5f       	subi	r24, 0xFF	; 255
    2b5e:	80 93 9b 15 	sts	0x159B, r24	; 0x80159b <uxSchedulerSuspended>
    2b62:	08 95       	ret

00002b64 <xTaskResumeAll>:
    2b64:	9f 92       	push	r9
    2b66:	af 92       	push	r10
    2b68:	bf 92       	push	r11
    2b6a:	cf 92       	push	r12
    2b6c:	df 92       	push	r13
    2b6e:	ef 92       	push	r14
    2b70:	ff 92       	push	r15
    2b72:	0f 93       	push	r16
    2b74:	1f 93       	push	r17
    2b76:	cf 93       	push	r28
    2b78:	df 93       	push	r29
    2b7a:	0f b6       	in	r0, 0x3f	; 63
    2b7c:	f8 94       	cli
    2b7e:	0f 92       	push	r0
    2b80:	80 91 9b 15 	lds	r24, 0x159B	; 0x80159b <uxSchedulerSuspended>
    2b84:	81 50       	subi	r24, 0x01	; 1
    2b86:	80 93 9b 15 	sts	0x159B, r24	; 0x80159b <uxSchedulerSuspended>
    2b8a:	80 91 9b 15 	lds	r24, 0x159B	; 0x80159b <uxSchedulerSuspended>
    2b8e:	81 11       	cpse	r24, r1
    2b90:	28 c1       	rjmp	.+592    	; 0x2de2 <xTaskResumeAll+0x27e>
    2b92:	80 91 a6 15 	lds	r24, 0x15A6	; 0x8015a6 <uxCurrentNumberOfTasks>
    2b96:	81 11       	cpse	r24, r1
    2b98:	33 c0       	rjmp	.+102    	; 0x2c00 <xTaskResumeAll+0x9c>
    2b9a:	26 c1       	rjmp	.+588    	; 0x2de8 <xTaskResumeAll+0x284>
    2b9c:	d7 01       	movw	r26, r14
    2b9e:	15 96       	adiw	r26, 0x05	; 5
    2ba0:	ed 91       	ld	r30, X+
    2ba2:	fc 91       	ld	r31, X
    2ba4:	16 97       	sbiw	r26, 0x06	; 6
    2ba6:	c6 81       	ldd	r28, Z+6	; 0x06
    2ba8:	d7 81       	ldd	r29, Z+7	; 0x07
    2baa:	ce 01       	movw	r24, r28
    2bac:	0c 96       	adiw	r24, 0x0c	; 12
    2bae:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    2bb2:	8e 01       	movw	r16, r28
    2bb4:	0e 5f       	subi	r16, 0xFE	; 254
    2bb6:	1f 4f       	sbci	r17, 0xFF	; 255
    2bb8:	c8 01       	movw	r24, r16
    2bba:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    2bbe:	8e 89       	ldd	r24, Y+22	; 0x16
    2bc0:	90 91 a3 15 	lds	r25, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
    2bc4:	98 17       	cp	r25, r24
    2bc6:	10 f4       	brcc	.+4      	; 0x2bcc <xTaskResumeAll+0x68>
    2bc8:	80 93 a3 15 	sts	0x15A3, r24	; 0x8015a3 <uxTopReadyPriority>
    2bcc:	90 e0       	ldi	r25, 0x00	; 0
    2bce:	9c 01       	movw	r18, r24
    2bd0:	22 0f       	add	r18, r18
    2bd2:	33 1f       	adc	r19, r19
    2bd4:	22 0f       	add	r18, r18
    2bd6:	33 1f       	adc	r19, r19
    2bd8:	22 0f       	add	r18, r18
    2bda:	33 1f       	adc	r19, r19
    2bdc:	82 0f       	add	r24, r18
    2bde:	93 1f       	adc	r25, r19
    2be0:	b8 01       	movw	r22, r16
    2be2:	87 52       	subi	r24, 0x27	; 39
    2be4:	9a 4e       	sbci	r25, 0xEA	; 234
    2be6:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    2bea:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    2bee:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    2bf2:	9e 89       	ldd	r25, Y+22	; 0x16
    2bf4:	86 89       	ldd	r24, Z+22	; 0x16
    2bf6:	98 17       	cp	r25, r24
    2bf8:	58 f0       	brcs	.+22     	; 0x2c10 <xTaskResumeAll+0xac>
    2bfa:	d0 92 a0 15 	sts	0x15A0, r13	; 0x8015a0 <xYieldPending>
    2bfe:	08 c0       	rjmp	.+16     	; 0x2c10 <xTaskResumeAll+0xac>
    2c00:	0f 2e       	mov	r0, r31
    2c02:	fa eb       	ldi	r31, 0xBA	; 186
    2c04:	ef 2e       	mov	r14, r31
    2c06:	f5 e1       	ldi	r31, 0x15	; 21
    2c08:	ff 2e       	mov	r15, r31
    2c0a:	f0 2d       	mov	r31, r0
    2c0c:	dd 24       	eor	r13, r13
    2c0e:	d3 94       	inc	r13
    2c10:	f7 01       	movw	r30, r14
    2c12:	80 81       	ld	r24, Z
    2c14:	81 11       	cpse	r24, r1
    2c16:	c2 cf       	rjmp	.-124    	; 0x2b9c <xTaskResumeAll+0x38>
    2c18:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
    2c1c:	88 23       	and	r24, r24
    2c1e:	09 f4       	brne	.+2      	; 0x2c22 <xTaskResumeAll+0xbe>
    2c20:	d8 c0       	rjmp	.+432    	; 0x2dd2 <xTaskResumeAll+0x26e>
    2c22:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
    2c26:	88 23       	and	r24, r24
    2c28:	09 f4       	brne	.+2      	; 0x2c2c <xTaskResumeAll+0xc8>
    2c2a:	d3 c0       	rjmp	.+422    	; 0x2dd2 <xTaskResumeAll+0x26e>
    2c2c:	91 2c       	mov	r9, r1
    2c2e:	bb 24       	eor	r11, r11
    2c30:	b3 94       	inc	r11
    2c32:	cc 24       	eor	r12, r12
    2c34:	ca 94       	dec	r12
    2c36:	dc 2c       	mov	r13, r12
    2c38:	80 91 9b 15 	lds	r24, 0x159B	; 0x80159b <uxSchedulerSuspended>
    2c3c:	81 11       	cpse	r24, r1
    2c3e:	af c0       	rjmp	.+350    	; 0x2d9e <xTaskResumeAll+0x23a>
    2c40:	80 91 a4 15 	lds	r24, 0x15A4	; 0x8015a4 <xTickCount>
    2c44:	90 91 a5 15 	lds	r25, 0x15A5	; 0x8015a5 <xTickCount+0x1>
    2c48:	01 96       	adiw	r24, 0x01	; 1
    2c4a:	90 93 a5 15 	sts	0x15A5, r25	; 0x8015a5 <xTickCount+0x1>
    2c4e:	80 93 a4 15 	sts	0x15A4, r24	; 0x8015a4 <xTickCount>
    2c52:	e0 90 a4 15 	lds	r14, 0x15A4	; 0x8015a4 <xTickCount>
    2c56:	f0 90 a5 15 	lds	r15, 0x15A5	; 0x8015a5 <xTickCount+0x1>
    2c5a:	e1 14       	cp	r14, r1
    2c5c:	f1 04       	cpc	r15, r1
    2c5e:	89 f5       	brne	.+98     	; 0x2cc2 <xTaskResumeAll+0x15e>
    2c60:	80 91 c5 15 	lds	r24, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    2c64:	90 91 c6 15 	lds	r25, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    2c68:	20 91 c3 15 	lds	r18, 0x15C3	; 0x8015c3 <pxOverflowDelayedTaskList>
    2c6c:	30 91 c4 15 	lds	r19, 0x15C4	; 0x8015c4 <pxOverflowDelayedTaskList+0x1>
    2c70:	30 93 c6 15 	sts	0x15C6, r19	; 0x8015c6 <pxDelayedTaskList+0x1>
    2c74:	20 93 c5 15 	sts	0x15C5, r18	; 0x8015c5 <pxDelayedTaskList>
    2c78:	90 93 c4 15 	sts	0x15C4, r25	; 0x8015c4 <pxOverflowDelayedTaskList+0x1>
    2c7c:	80 93 c3 15 	sts	0x15C3, r24	; 0x8015c3 <pxOverflowDelayedTaskList>
    2c80:	80 91 9f 15 	lds	r24, 0x159F	; 0x80159f <xNumOfOverflows>
    2c84:	8f 5f       	subi	r24, 0xFF	; 255
    2c86:	80 93 9f 15 	sts	0x159F, r24	; 0x80159f <xNumOfOverflows>
    2c8a:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    2c8e:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    2c92:	80 81       	ld	r24, Z
    2c94:	81 11       	cpse	r24, r1
    2c96:	05 c0       	rjmp	.+10     	; 0x2ca2 <xTaskResumeAll+0x13e>
    2c98:	d0 92 9d 15 	sts	0x159D, r13	; 0x80159d <xNextTaskUnblockTime+0x1>
    2c9c:	c0 92 9c 15 	sts	0x159C, r12	; 0x80159c <xNextTaskUnblockTime>
    2ca0:	10 c0       	rjmp	.+32     	; 0x2cc2 <xTaskResumeAll+0x15e>
    2ca2:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    2ca6:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    2caa:	05 80       	ldd	r0, Z+5	; 0x05
    2cac:	f6 81       	ldd	r31, Z+6	; 0x06
    2cae:	e0 2d       	mov	r30, r0
    2cb0:	06 80       	ldd	r0, Z+6	; 0x06
    2cb2:	f7 81       	ldd	r31, Z+7	; 0x07
    2cb4:	e0 2d       	mov	r30, r0
    2cb6:	82 81       	ldd	r24, Z+2	; 0x02
    2cb8:	93 81       	ldd	r25, Z+3	; 0x03
    2cba:	90 93 9d 15 	sts	0x159D, r25	; 0x80159d <xNextTaskUnblockTime+0x1>
    2cbe:	80 93 9c 15 	sts	0x159C, r24	; 0x80159c <xNextTaskUnblockTime>
    2cc2:	80 91 9c 15 	lds	r24, 0x159C	; 0x80159c <xNextTaskUnblockTime>
    2cc6:	90 91 9d 15 	lds	r25, 0x159D	; 0x80159d <xNextTaskUnblockTime+0x1>
    2cca:	e8 16       	cp	r14, r24
    2ccc:	f9 06       	cpc	r15, r25
    2cce:	10 f4       	brcc	.+4      	; 0x2cd4 <xTaskResumeAll+0x170>
    2cd0:	a9 2c       	mov	r10, r9
    2cd2:	4f c0       	rjmp	.+158    	; 0x2d72 <xTaskResumeAll+0x20e>
    2cd4:	a9 2c       	mov	r10, r9
    2cd6:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    2cda:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    2cde:	80 81       	ld	r24, Z
    2ce0:	81 11       	cpse	r24, r1
    2ce2:	05 c0       	rjmp	.+10     	; 0x2cee <xTaskResumeAll+0x18a>
    2ce4:	d0 92 9d 15 	sts	0x159D, r13	; 0x80159d <xNextTaskUnblockTime+0x1>
    2ce8:	c0 92 9c 15 	sts	0x159C, r12	; 0x80159c <xNextTaskUnblockTime>
    2cec:	42 c0       	rjmp	.+132    	; 0x2d72 <xTaskResumeAll+0x20e>
    2cee:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    2cf2:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    2cf6:	05 80       	ldd	r0, Z+5	; 0x05
    2cf8:	f6 81       	ldd	r31, Z+6	; 0x06
    2cfa:	e0 2d       	mov	r30, r0
    2cfc:	c6 81       	ldd	r28, Z+6	; 0x06
    2cfe:	d7 81       	ldd	r29, Z+7	; 0x07
    2d00:	8a 81       	ldd	r24, Y+2	; 0x02
    2d02:	9b 81       	ldd	r25, Y+3	; 0x03
    2d04:	e8 16       	cp	r14, r24
    2d06:	f9 06       	cpc	r15, r25
    2d08:	28 f4       	brcc	.+10     	; 0x2d14 <xTaskResumeAll+0x1b0>
    2d0a:	90 93 9d 15 	sts	0x159D, r25	; 0x80159d <xNextTaskUnblockTime+0x1>
    2d0e:	80 93 9c 15 	sts	0x159C, r24	; 0x80159c <xNextTaskUnblockTime>
    2d12:	2f c0       	rjmp	.+94     	; 0x2d72 <xTaskResumeAll+0x20e>
    2d14:	8e 01       	movw	r16, r28
    2d16:	0e 5f       	subi	r16, 0xFE	; 254
    2d18:	1f 4f       	sbci	r17, 0xFF	; 255
    2d1a:	c8 01       	movw	r24, r16
    2d1c:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    2d20:	8c 89       	ldd	r24, Y+20	; 0x14
    2d22:	9d 89       	ldd	r25, Y+21	; 0x15
    2d24:	89 2b       	or	r24, r25
    2d26:	21 f0       	breq	.+8      	; 0x2d30 <xTaskResumeAll+0x1cc>
    2d28:	ce 01       	movw	r24, r28
    2d2a:	0c 96       	adiw	r24, 0x0c	; 12
    2d2c:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    2d30:	8e 89       	ldd	r24, Y+22	; 0x16
    2d32:	90 91 a3 15 	lds	r25, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
    2d36:	98 17       	cp	r25, r24
    2d38:	10 f4       	brcc	.+4      	; 0x2d3e <xTaskResumeAll+0x1da>
    2d3a:	80 93 a3 15 	sts	0x15A3, r24	; 0x8015a3 <uxTopReadyPriority>
    2d3e:	90 e0       	ldi	r25, 0x00	; 0
    2d40:	9c 01       	movw	r18, r24
    2d42:	22 0f       	add	r18, r18
    2d44:	33 1f       	adc	r19, r19
    2d46:	22 0f       	add	r18, r18
    2d48:	33 1f       	adc	r19, r19
    2d4a:	22 0f       	add	r18, r18
    2d4c:	33 1f       	adc	r19, r19
    2d4e:	82 0f       	add	r24, r18
    2d50:	93 1f       	adc	r25, r19
    2d52:	b8 01       	movw	r22, r16
    2d54:	87 52       	subi	r24, 0x27	; 39
    2d56:	9a 4e       	sbci	r25, 0xEA	; 234
    2d58:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    2d5c:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    2d60:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    2d64:	9e 89       	ldd	r25, Y+22	; 0x16
    2d66:	86 89       	ldd	r24, Z+22	; 0x16
    2d68:	98 17       	cp	r25, r24
    2d6a:	08 f4       	brcc	.+2      	; 0x2d6e <xTaskResumeAll+0x20a>
    2d6c:	b4 cf       	rjmp	.-152    	; 0x2cd6 <xTaskResumeAll+0x172>
    2d6e:	ab 2c       	mov	r10, r11
    2d70:	b2 cf       	rjmp	.-156    	; 0x2cd6 <xTaskResumeAll+0x172>
    2d72:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    2d76:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    2d7a:	86 89       	ldd	r24, Z+22	; 0x16
    2d7c:	90 e0       	ldi	r25, 0x00	; 0
    2d7e:	fc 01       	movw	r30, r24
    2d80:	ee 0f       	add	r30, r30
    2d82:	ff 1f       	adc	r31, r31
    2d84:	ee 0f       	add	r30, r30
    2d86:	ff 1f       	adc	r31, r31
    2d88:	ee 0f       	add	r30, r30
    2d8a:	ff 1f       	adc	r31, r31
    2d8c:	8e 0f       	add	r24, r30
    2d8e:	9f 1f       	adc	r25, r31
    2d90:	fc 01       	movw	r30, r24
    2d92:	e7 52       	subi	r30, 0x27	; 39
    2d94:	fa 4e       	sbci	r31, 0xEA	; 234
    2d96:	80 81       	ld	r24, Z
    2d98:	82 30       	cpi	r24, 0x02	; 2
    2d9a:	48 f5       	brcc	.+82     	; 0x2dee <xTaskResumeAll+0x28a>
    2d9c:	0a c0       	rjmp	.+20     	; 0x2db2 <xTaskResumeAll+0x24e>
    2d9e:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
    2da2:	8f 5f       	subi	r24, 0xFF	; 255
    2da4:	80 93 a1 15 	sts	0x15A1, r24	; 0x8015a1 <uxPendedTicks>
    2da8:	80 91 a0 15 	lds	r24, 0x15A0	; 0x8015a0 <xYieldPending>
    2dac:	81 11       	cpse	r24, r1
    2dae:	06 c0       	rjmp	.+12     	; 0x2dbc <xTaskResumeAll+0x258>
    2db0:	07 c0       	rjmp	.+14     	; 0x2dc0 <xTaskResumeAll+0x25c>
    2db2:	80 91 a0 15 	lds	r24, 0x15A0	; 0x8015a0 <xYieldPending>
    2db6:	81 11       	cpse	r24, r1
    2db8:	01 c0       	rjmp	.+2      	; 0x2dbc <xTaskResumeAll+0x258>
    2dba:	a1 10       	cpse	r10, r1
    2dbc:	b0 92 a0 15 	sts	0x15A0, r11	; 0x8015a0 <xYieldPending>
    2dc0:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
    2dc4:	81 50       	subi	r24, 0x01	; 1
    2dc6:	80 93 a1 15 	sts	0x15A1, r24	; 0x8015a1 <uxPendedTicks>
    2dca:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
    2dce:	81 11       	cpse	r24, r1
    2dd0:	33 cf       	rjmp	.-410    	; 0x2c38 <xTaskResumeAll+0xd4>
    2dd2:	80 91 a0 15 	lds	r24, 0x15A0	; 0x8015a0 <xYieldPending>
    2dd6:	81 30       	cpi	r24, 0x01	; 1
    2dd8:	31 f4       	brne	.+12     	; 0x2de6 <xTaskResumeAll+0x282>
    2dda:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <vPortYield>
    2dde:	81 e0       	ldi	r24, 0x01	; 1
    2de0:	03 c0       	rjmp	.+6      	; 0x2de8 <xTaskResumeAll+0x284>
    2de2:	80 e0       	ldi	r24, 0x00	; 0
    2de4:	01 c0       	rjmp	.+2      	; 0x2de8 <xTaskResumeAll+0x284>
    2de6:	80 e0       	ldi	r24, 0x00	; 0
    2de8:	0f 90       	pop	r0
    2dea:	0f be       	out	0x3f, r0	; 63
    2dec:	03 c0       	rjmp	.+6      	; 0x2df4 <xTaskResumeAll+0x290>
    2dee:	80 91 a0 15 	lds	r24, 0x15A0	; 0x8015a0 <xYieldPending>
    2df2:	e4 cf       	rjmp	.-56     	; 0x2dbc <xTaskResumeAll+0x258>
    2df4:	df 91       	pop	r29
    2df6:	cf 91       	pop	r28
    2df8:	1f 91       	pop	r17
    2dfa:	0f 91       	pop	r16
    2dfc:	ff 90       	pop	r15
    2dfe:	ef 90       	pop	r14
    2e00:	df 90       	pop	r13
    2e02:	cf 90       	pop	r12
    2e04:	bf 90       	pop	r11
    2e06:	af 90       	pop	r10
    2e08:	9f 90       	pop	r9
    2e0a:	08 95       	ret

00002e0c <xTaskIncrementTick>:
    2e0c:	cf 92       	push	r12
    2e0e:	df 92       	push	r13
    2e10:	ef 92       	push	r14
    2e12:	ff 92       	push	r15
    2e14:	0f 93       	push	r16
    2e16:	1f 93       	push	r17
    2e18:	cf 93       	push	r28
    2e1a:	df 93       	push	r29
    2e1c:	80 91 9b 15 	lds	r24, 0x159B	; 0x80159b <uxSchedulerSuspended>
    2e20:	81 11       	cpse	r24, r1
    2e22:	b7 c0       	rjmp	.+366    	; 0x2f92 <xTaskIncrementTick+0x186>
    2e24:	80 91 a4 15 	lds	r24, 0x15A4	; 0x8015a4 <xTickCount>
    2e28:	90 91 a5 15 	lds	r25, 0x15A5	; 0x8015a5 <xTickCount+0x1>
    2e2c:	01 96       	adiw	r24, 0x01	; 1
    2e2e:	90 93 a5 15 	sts	0x15A5, r25	; 0x8015a5 <xTickCount+0x1>
    2e32:	80 93 a4 15 	sts	0x15A4, r24	; 0x8015a4 <xTickCount>
    2e36:	e0 90 a4 15 	lds	r14, 0x15A4	; 0x8015a4 <xTickCount>
    2e3a:	f0 90 a5 15 	lds	r15, 0x15A5	; 0x8015a5 <xTickCount+0x1>
    2e3e:	e1 14       	cp	r14, r1
    2e40:	f1 04       	cpc	r15, r1
    2e42:	99 f5       	brne	.+102    	; 0x2eaa <xTaskIncrementTick+0x9e>
    2e44:	80 91 c5 15 	lds	r24, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    2e48:	90 91 c6 15 	lds	r25, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    2e4c:	20 91 c3 15 	lds	r18, 0x15C3	; 0x8015c3 <pxOverflowDelayedTaskList>
    2e50:	30 91 c4 15 	lds	r19, 0x15C4	; 0x8015c4 <pxOverflowDelayedTaskList+0x1>
    2e54:	30 93 c6 15 	sts	0x15C6, r19	; 0x8015c6 <pxDelayedTaskList+0x1>
    2e58:	20 93 c5 15 	sts	0x15C5, r18	; 0x8015c5 <pxDelayedTaskList>
    2e5c:	90 93 c4 15 	sts	0x15C4, r25	; 0x8015c4 <pxOverflowDelayedTaskList+0x1>
    2e60:	80 93 c3 15 	sts	0x15C3, r24	; 0x8015c3 <pxOverflowDelayedTaskList>
    2e64:	80 91 9f 15 	lds	r24, 0x159F	; 0x80159f <xNumOfOverflows>
    2e68:	8f 5f       	subi	r24, 0xFF	; 255
    2e6a:	80 93 9f 15 	sts	0x159F, r24	; 0x80159f <xNumOfOverflows>
    2e6e:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    2e72:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    2e76:	80 81       	ld	r24, Z
    2e78:	81 11       	cpse	r24, r1
    2e7a:	07 c0       	rjmp	.+14     	; 0x2e8a <xTaskIncrementTick+0x7e>
    2e7c:	8f ef       	ldi	r24, 0xFF	; 255
    2e7e:	9f ef       	ldi	r25, 0xFF	; 255
    2e80:	90 93 9d 15 	sts	0x159D, r25	; 0x80159d <xNextTaskUnblockTime+0x1>
    2e84:	80 93 9c 15 	sts	0x159C, r24	; 0x80159c <xNextTaskUnblockTime>
    2e88:	10 c0       	rjmp	.+32     	; 0x2eaa <xTaskIncrementTick+0x9e>
    2e8a:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    2e8e:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    2e92:	05 80       	ldd	r0, Z+5	; 0x05
    2e94:	f6 81       	ldd	r31, Z+6	; 0x06
    2e96:	e0 2d       	mov	r30, r0
    2e98:	06 80       	ldd	r0, Z+6	; 0x06
    2e9a:	f7 81       	ldd	r31, Z+7	; 0x07
    2e9c:	e0 2d       	mov	r30, r0
    2e9e:	82 81       	ldd	r24, Z+2	; 0x02
    2ea0:	93 81       	ldd	r25, Z+3	; 0x03
    2ea2:	90 93 9d 15 	sts	0x159D, r25	; 0x80159d <xNextTaskUnblockTime+0x1>
    2ea6:	80 93 9c 15 	sts	0x159C, r24	; 0x80159c <xNextTaskUnblockTime>
    2eaa:	80 91 9c 15 	lds	r24, 0x159C	; 0x80159c <xNextTaskUnblockTime>
    2eae:	90 91 9d 15 	lds	r25, 0x159D	; 0x80159d <xNextTaskUnblockTime+0x1>
    2eb2:	e8 16       	cp	r14, r24
    2eb4:	f9 06       	cpc	r15, r25
    2eb6:	10 f4       	brcc	.+4      	; 0x2ebc <xTaskIncrementTick+0xb0>
    2eb8:	d1 2c       	mov	r13, r1
    2eba:	53 c0       	rjmp	.+166    	; 0x2f62 <xTaskIncrementTick+0x156>
    2ebc:	d1 2c       	mov	r13, r1
    2ebe:	cc 24       	eor	r12, r12
    2ec0:	c3 94       	inc	r12
    2ec2:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    2ec6:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    2eca:	80 81       	ld	r24, Z
    2ecc:	81 11       	cpse	r24, r1
    2ece:	07 c0       	rjmp	.+14     	; 0x2ede <xTaskIncrementTick+0xd2>
    2ed0:	8f ef       	ldi	r24, 0xFF	; 255
    2ed2:	9f ef       	ldi	r25, 0xFF	; 255
    2ed4:	90 93 9d 15 	sts	0x159D, r25	; 0x80159d <xNextTaskUnblockTime+0x1>
    2ed8:	80 93 9c 15 	sts	0x159C, r24	; 0x80159c <xNextTaskUnblockTime>
    2edc:	42 c0       	rjmp	.+132    	; 0x2f62 <xTaskIncrementTick+0x156>
    2ede:	e0 91 c5 15 	lds	r30, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    2ee2:	f0 91 c6 15 	lds	r31, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    2ee6:	05 80       	ldd	r0, Z+5	; 0x05
    2ee8:	f6 81       	ldd	r31, Z+6	; 0x06
    2eea:	e0 2d       	mov	r30, r0
    2eec:	c6 81       	ldd	r28, Z+6	; 0x06
    2eee:	d7 81       	ldd	r29, Z+7	; 0x07
    2ef0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ef2:	9b 81       	ldd	r25, Y+3	; 0x03
    2ef4:	e8 16       	cp	r14, r24
    2ef6:	f9 06       	cpc	r15, r25
    2ef8:	28 f4       	brcc	.+10     	; 0x2f04 <xTaskIncrementTick+0xf8>
    2efa:	90 93 9d 15 	sts	0x159D, r25	; 0x80159d <xNextTaskUnblockTime+0x1>
    2efe:	80 93 9c 15 	sts	0x159C, r24	; 0x80159c <xNextTaskUnblockTime>
    2f02:	2f c0       	rjmp	.+94     	; 0x2f62 <xTaskIncrementTick+0x156>
    2f04:	8e 01       	movw	r16, r28
    2f06:	0e 5f       	subi	r16, 0xFE	; 254
    2f08:	1f 4f       	sbci	r17, 0xFF	; 255
    2f0a:	c8 01       	movw	r24, r16
    2f0c:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    2f10:	8c 89       	ldd	r24, Y+20	; 0x14
    2f12:	9d 89       	ldd	r25, Y+21	; 0x15
    2f14:	89 2b       	or	r24, r25
    2f16:	21 f0       	breq	.+8      	; 0x2f20 <xTaskIncrementTick+0x114>
    2f18:	ce 01       	movw	r24, r28
    2f1a:	0c 96       	adiw	r24, 0x0c	; 12
    2f1c:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    2f20:	8e 89       	ldd	r24, Y+22	; 0x16
    2f22:	90 91 a3 15 	lds	r25, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
    2f26:	98 17       	cp	r25, r24
    2f28:	10 f4       	brcc	.+4      	; 0x2f2e <xTaskIncrementTick+0x122>
    2f2a:	80 93 a3 15 	sts	0x15A3, r24	; 0x8015a3 <uxTopReadyPriority>
    2f2e:	90 e0       	ldi	r25, 0x00	; 0
    2f30:	9c 01       	movw	r18, r24
    2f32:	22 0f       	add	r18, r18
    2f34:	33 1f       	adc	r19, r19
    2f36:	22 0f       	add	r18, r18
    2f38:	33 1f       	adc	r19, r19
    2f3a:	22 0f       	add	r18, r18
    2f3c:	33 1f       	adc	r19, r19
    2f3e:	82 0f       	add	r24, r18
    2f40:	93 1f       	adc	r25, r19
    2f42:	b8 01       	movw	r22, r16
    2f44:	87 52       	subi	r24, 0x27	; 39
    2f46:	9a 4e       	sbci	r25, 0xEA	; 234
    2f48:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    2f4c:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    2f50:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    2f54:	9e 89       	ldd	r25, Y+22	; 0x16
    2f56:	86 89       	ldd	r24, Z+22	; 0x16
    2f58:	98 17       	cp	r25, r24
    2f5a:	08 f4       	brcc	.+2      	; 0x2f5e <xTaskIncrementTick+0x152>
    2f5c:	b2 cf       	rjmp	.-156    	; 0x2ec2 <xTaskIncrementTick+0xb6>
    2f5e:	dc 2c       	mov	r13, r12
    2f60:	b0 cf       	rjmp	.-160    	; 0x2ec2 <xTaskIncrementTick+0xb6>
    2f62:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    2f66:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    2f6a:	86 89       	ldd	r24, Z+22	; 0x16
    2f6c:	90 e0       	ldi	r25, 0x00	; 0
    2f6e:	fc 01       	movw	r30, r24
    2f70:	ee 0f       	add	r30, r30
    2f72:	ff 1f       	adc	r31, r31
    2f74:	ee 0f       	add	r30, r30
    2f76:	ff 1f       	adc	r31, r31
    2f78:	ee 0f       	add	r30, r30
    2f7a:	ff 1f       	adc	r31, r31
    2f7c:	8e 0f       	add	r24, r30
    2f7e:	9f 1f       	adc	r25, r31
    2f80:	fc 01       	movw	r30, r24
    2f82:	e7 52       	subi	r30, 0x27	; 39
    2f84:	fa 4e       	sbci	r31, 0xEA	; 234
    2f86:	80 81       	ld	r24, Z
    2f88:	82 30       	cpi	r24, 0x02	; 2
    2f8a:	48 f0       	brcs	.+18     	; 0x2f9e <xTaskIncrementTick+0x192>
    2f8c:	dd 24       	eor	r13, r13
    2f8e:	d3 94       	inc	r13
    2f90:	06 c0       	rjmp	.+12     	; 0x2f9e <xTaskIncrementTick+0x192>
    2f92:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <uxPendedTicks>
    2f96:	8f 5f       	subi	r24, 0xFF	; 255
    2f98:	80 93 a1 15 	sts	0x15A1, r24	; 0x8015a1 <uxPendedTicks>
    2f9c:	d1 2c       	mov	r13, r1
    2f9e:	80 91 a0 15 	lds	r24, 0x15A0	; 0x8015a0 <xYieldPending>
    2fa2:	88 23       	and	r24, r24
    2fa4:	11 f0       	breq	.+4      	; 0x2faa <xTaskIncrementTick+0x19e>
    2fa6:	dd 24       	eor	r13, r13
    2fa8:	d3 94       	inc	r13
    2faa:	8d 2d       	mov	r24, r13
    2fac:	df 91       	pop	r29
    2fae:	cf 91       	pop	r28
    2fb0:	1f 91       	pop	r17
    2fb2:	0f 91       	pop	r16
    2fb4:	ff 90       	pop	r15
    2fb6:	ef 90       	pop	r14
    2fb8:	df 90       	pop	r13
    2fba:	cf 90       	pop	r12
    2fbc:	08 95       	ret

00002fbe <vTaskSwitchContext>:
    2fbe:	80 91 9b 15 	lds	r24, 0x159B	; 0x80159b <uxSchedulerSuspended>
    2fc2:	88 23       	and	r24, r24
    2fc4:	21 f0       	breq	.+8      	; 0x2fce <vTaskSwitchContext+0x10>
    2fc6:	81 e0       	ldi	r24, 0x01	; 1
    2fc8:	80 93 a0 15 	sts	0x15A0, r24	; 0x8015a0 <xYieldPending>
    2fcc:	08 95       	ret
    2fce:	10 92 a0 15 	sts	0x15A0, r1	; 0x8015a0 <xYieldPending>
    2fd2:	80 91 a3 15 	lds	r24, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
    2fd6:	90 e0       	ldi	r25, 0x00	; 0
    2fd8:	fc 01       	movw	r30, r24
    2fda:	ee 0f       	add	r30, r30
    2fdc:	ff 1f       	adc	r31, r31
    2fde:	ee 0f       	add	r30, r30
    2fe0:	ff 1f       	adc	r31, r31
    2fe2:	ee 0f       	add	r30, r30
    2fe4:	ff 1f       	adc	r31, r31
    2fe6:	8e 0f       	add	r24, r30
    2fe8:	9f 1f       	adc	r25, r31
    2fea:	fc 01       	movw	r30, r24
    2fec:	e7 52       	subi	r30, 0x27	; 39
    2fee:	fa 4e       	sbci	r31, 0xEA	; 234
    2ff0:	80 81       	ld	r24, Z
    2ff2:	81 11       	cpse	r24, r1
    2ff4:	17 c0       	rjmp	.+46     	; 0x3024 <vTaskSwitchContext+0x66>
    2ff6:	80 91 a3 15 	lds	r24, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
    2ffa:	81 50       	subi	r24, 0x01	; 1
    2ffc:	80 93 a3 15 	sts	0x15A3, r24	; 0x8015a3 <uxTopReadyPriority>
    3000:	80 91 a3 15 	lds	r24, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
    3004:	90 e0       	ldi	r25, 0x00	; 0
    3006:	fc 01       	movw	r30, r24
    3008:	ee 0f       	add	r30, r30
    300a:	ff 1f       	adc	r31, r31
    300c:	ee 0f       	add	r30, r30
    300e:	ff 1f       	adc	r31, r31
    3010:	ee 0f       	add	r30, r30
    3012:	ff 1f       	adc	r31, r31
    3014:	8e 0f       	add	r24, r30
    3016:	9f 1f       	adc	r25, r31
    3018:	fc 01       	movw	r30, r24
    301a:	e7 52       	subi	r30, 0x27	; 39
    301c:	fa 4e       	sbci	r31, 0xEA	; 234
    301e:	80 81       	ld	r24, Z
    3020:	88 23       	and	r24, r24
    3022:	49 f3       	breq	.-46     	; 0x2ff6 <vTaskSwitchContext+0x38>
    3024:	80 91 a3 15 	lds	r24, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
    3028:	90 e0       	ldi	r25, 0x00	; 0
    302a:	9c 01       	movw	r18, r24
    302c:	22 0f       	add	r18, r18
    302e:	33 1f       	adc	r19, r19
    3030:	22 0f       	add	r18, r18
    3032:	33 1f       	adc	r19, r19
    3034:	22 0f       	add	r18, r18
    3036:	33 1f       	adc	r19, r19
    3038:	28 0f       	add	r18, r24
    303a:	39 1f       	adc	r19, r25
    303c:	d9 01       	movw	r26, r18
    303e:	a7 52       	subi	r26, 0x27	; 39
    3040:	ba 4e       	sbci	r27, 0xEA	; 234
    3042:	11 96       	adiw	r26, 0x01	; 1
    3044:	ed 91       	ld	r30, X+
    3046:	fc 91       	ld	r31, X
    3048:	12 97       	sbiw	r26, 0x02	; 2
    304a:	02 80       	ldd	r0, Z+2	; 0x02
    304c:	f3 81       	ldd	r31, Z+3	; 0x03
    304e:	e0 2d       	mov	r30, r0
    3050:	12 96       	adiw	r26, 0x02	; 2
    3052:	fc 93       	st	X, r31
    3054:	ee 93       	st	-X, r30
    3056:	11 97       	sbiw	r26, 0x01	; 1
    3058:	24 52       	subi	r18, 0x24	; 36
    305a:	3a 4e       	sbci	r19, 0xEA	; 234
    305c:	e2 17       	cp	r30, r18
    305e:	f3 07       	cpc	r31, r19
    3060:	29 f4       	brne	.+10     	; 0x306c <vTaskSwitchContext+0xae>
    3062:	22 81       	ldd	r18, Z+2	; 0x02
    3064:	33 81       	ldd	r19, Z+3	; 0x03
    3066:	fd 01       	movw	r30, r26
    3068:	32 83       	std	Z+2, r19	; 0x02
    306a:	21 83       	std	Z+1, r18	; 0x01
    306c:	fc 01       	movw	r30, r24
    306e:	ee 0f       	add	r30, r30
    3070:	ff 1f       	adc	r31, r31
    3072:	ee 0f       	add	r30, r30
    3074:	ff 1f       	adc	r31, r31
    3076:	ee 0f       	add	r30, r30
    3078:	ff 1f       	adc	r31, r31
    307a:	8e 0f       	add	r24, r30
    307c:	9f 1f       	adc	r25, r31
    307e:	fc 01       	movw	r30, r24
    3080:	e7 52       	subi	r30, 0x27	; 39
    3082:	fa 4e       	sbci	r31, 0xEA	; 234
    3084:	01 80       	ldd	r0, Z+1	; 0x01
    3086:	f2 81       	ldd	r31, Z+2	; 0x02
    3088:	e0 2d       	mov	r30, r0
    308a:	86 81       	ldd	r24, Z+6	; 0x06
    308c:	97 81       	ldd	r25, Z+7	; 0x07
    308e:	90 93 fe 15 	sts	0x15FE, r25	; 0x8015fe <pxCurrentTCB+0x1>
    3092:	80 93 fd 15 	sts	0x15FD, r24	; 0x8015fd <pxCurrentTCB>
    3096:	08 95       	ret

00003098 <vTaskPlaceOnEventList>:
    3098:	cf 93       	push	r28
    309a:	df 93       	push	r29
    309c:	eb 01       	movw	r28, r22
    309e:	60 91 fd 15 	lds	r22, 0x15FD	; 0x8015fd <pxCurrentTCB>
    30a2:	70 91 fe 15 	lds	r23, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    30a6:	64 5f       	subi	r22, 0xF4	; 244
    30a8:	7f 4f       	sbci	r23, 0xFF	; 255
    30aa:	0e 94 e3 0a 	call	0x15c6	; 0x15c6 <vListInsert>
    30ae:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <pxCurrentTCB>
    30b2:	90 91 fe 15 	lds	r25, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    30b6:	02 96       	adiw	r24, 0x02	; 2
    30b8:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    30bc:	cf 3f       	cpi	r28, 0xFF	; 255
    30be:	8f ef       	ldi	r24, 0xFF	; 255
    30c0:	d8 07       	cpc	r29, r24
    30c2:	59 f4       	brne	.+22     	; 0x30da <vTaskPlaceOnEventList+0x42>
    30c4:	60 91 fd 15 	lds	r22, 0x15FD	; 0x8015fd <pxCurrentTCB>
    30c8:	70 91 fe 15 	lds	r23, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    30cc:	6e 5f       	subi	r22, 0xFE	; 254
    30ce:	7f 4f       	sbci	r23, 0xFF	; 255
    30d0:	87 ea       	ldi	r24, 0xA7	; 167
    30d2:	95 e1       	ldi	r25, 0x15	; 21
    30d4:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    30d8:	37 c0       	rjmp	.+110    	; 0x3148 <vTaskPlaceOnEventList+0xb0>
    30da:	80 91 a4 15 	lds	r24, 0x15A4	; 0x8015a4 <xTickCount>
    30de:	90 91 a5 15 	lds	r25, 0x15A5	; 0x8015a5 <xTickCount+0x1>
    30e2:	c8 0f       	add	r28, r24
    30e4:	d9 1f       	adc	r29, r25
    30e6:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    30ea:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    30ee:	d3 83       	std	Z+3, r29	; 0x03
    30f0:	c2 83       	std	Z+2, r28	; 0x02
    30f2:	80 91 a4 15 	lds	r24, 0x15A4	; 0x8015a4 <xTickCount>
    30f6:	90 91 a5 15 	lds	r25, 0x15A5	; 0x8015a5 <xTickCount+0x1>
    30fa:	c8 17       	cp	r28, r24
    30fc:	d9 07       	cpc	r29, r25
    30fe:	68 f4       	brcc	.+26     	; 0x311a <vTaskPlaceOnEventList+0x82>
    3100:	60 91 fd 15 	lds	r22, 0x15FD	; 0x8015fd <pxCurrentTCB>
    3104:	70 91 fe 15 	lds	r23, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    3108:	80 91 c3 15 	lds	r24, 0x15C3	; 0x8015c3 <pxOverflowDelayedTaskList>
    310c:	90 91 c4 15 	lds	r25, 0x15C4	; 0x8015c4 <pxOverflowDelayedTaskList+0x1>
    3110:	6e 5f       	subi	r22, 0xFE	; 254
    3112:	7f 4f       	sbci	r23, 0xFF	; 255
    3114:	0e 94 e3 0a 	call	0x15c6	; 0x15c6 <vListInsert>
    3118:	17 c0       	rjmp	.+46     	; 0x3148 <vTaskPlaceOnEventList+0xb0>
    311a:	60 91 fd 15 	lds	r22, 0x15FD	; 0x8015fd <pxCurrentTCB>
    311e:	70 91 fe 15 	lds	r23, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    3122:	80 91 c5 15 	lds	r24, 0x15C5	; 0x8015c5 <pxDelayedTaskList>
    3126:	90 91 c6 15 	lds	r25, 0x15C6	; 0x8015c6 <pxDelayedTaskList+0x1>
    312a:	6e 5f       	subi	r22, 0xFE	; 254
    312c:	7f 4f       	sbci	r23, 0xFF	; 255
    312e:	0e 94 e3 0a 	call	0x15c6	; 0x15c6 <vListInsert>
    3132:	80 91 9c 15 	lds	r24, 0x159C	; 0x80159c <xNextTaskUnblockTime>
    3136:	90 91 9d 15 	lds	r25, 0x159D	; 0x80159d <xNextTaskUnblockTime+0x1>
    313a:	c8 17       	cp	r28, r24
    313c:	d9 07       	cpc	r29, r25
    313e:	20 f4       	brcc	.+8      	; 0x3148 <vTaskPlaceOnEventList+0xb0>
    3140:	d0 93 9d 15 	sts	0x159D, r29	; 0x80159d <xNextTaskUnblockTime+0x1>
    3144:	c0 93 9c 15 	sts	0x159C, r28	; 0x80159c <xNextTaskUnblockTime>
    3148:	df 91       	pop	r29
    314a:	cf 91       	pop	r28
    314c:	08 95       	ret

0000314e <xTaskRemoveFromEventList>:
    314e:	0f 93       	push	r16
    3150:	1f 93       	push	r17
    3152:	cf 93       	push	r28
    3154:	df 93       	push	r29
    3156:	dc 01       	movw	r26, r24
    3158:	15 96       	adiw	r26, 0x05	; 5
    315a:	ed 91       	ld	r30, X+
    315c:	fc 91       	ld	r31, X
    315e:	16 97       	sbiw	r26, 0x06	; 6
    3160:	c6 81       	ldd	r28, Z+6	; 0x06
    3162:	d7 81       	ldd	r29, Z+7	; 0x07
    3164:	8e 01       	movw	r16, r28
    3166:	04 5f       	subi	r16, 0xF4	; 244
    3168:	1f 4f       	sbci	r17, 0xFF	; 255
    316a:	c8 01       	movw	r24, r16
    316c:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    3170:	80 91 9b 15 	lds	r24, 0x159B	; 0x80159b <uxSchedulerSuspended>
    3174:	81 11       	cpse	r24, r1
    3176:	1c c0       	rjmp	.+56     	; 0x31b0 <xTaskRemoveFromEventList+0x62>
    3178:	0a 50       	subi	r16, 0x0A	; 10
    317a:	11 09       	sbc	r17, r1
    317c:	c8 01       	movw	r24, r16
    317e:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    3182:	8e 89       	ldd	r24, Y+22	; 0x16
    3184:	90 91 a3 15 	lds	r25, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
    3188:	98 17       	cp	r25, r24
    318a:	10 f4       	brcc	.+4      	; 0x3190 <xTaskRemoveFromEventList+0x42>
    318c:	80 93 a3 15 	sts	0x15A3, r24	; 0x8015a3 <uxTopReadyPriority>
    3190:	90 e0       	ldi	r25, 0x00	; 0
    3192:	9c 01       	movw	r18, r24
    3194:	22 0f       	add	r18, r18
    3196:	33 1f       	adc	r19, r19
    3198:	22 0f       	add	r18, r18
    319a:	33 1f       	adc	r19, r19
    319c:	22 0f       	add	r18, r18
    319e:	33 1f       	adc	r19, r19
    31a0:	82 0f       	add	r24, r18
    31a2:	93 1f       	adc	r25, r19
    31a4:	b8 01       	movw	r22, r16
    31a6:	87 52       	subi	r24, 0x27	; 39
    31a8:	9a 4e       	sbci	r25, 0xEA	; 234
    31aa:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    31ae:	05 c0       	rjmp	.+10     	; 0x31ba <xTaskRemoveFromEventList+0x6c>
    31b0:	b8 01       	movw	r22, r16
    31b2:	8a eb       	ldi	r24, 0xBA	; 186
    31b4:	95 e1       	ldi	r25, 0x15	; 21
    31b6:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    31ba:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    31be:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    31c2:	9e 89       	ldd	r25, Y+22	; 0x16
    31c4:	86 89       	ldd	r24, Z+22	; 0x16
    31c6:	89 17       	cp	r24, r25
    31c8:	20 f4       	brcc	.+8      	; 0x31d2 <xTaskRemoveFromEventList+0x84>
    31ca:	81 e0       	ldi	r24, 0x01	; 1
    31cc:	80 93 a0 15 	sts	0x15A0, r24	; 0x8015a0 <xYieldPending>
    31d0:	01 c0       	rjmp	.+2      	; 0x31d4 <xTaskRemoveFromEventList+0x86>
    31d2:	80 e0       	ldi	r24, 0x00	; 0
    31d4:	df 91       	pop	r29
    31d6:	cf 91       	pop	r28
    31d8:	1f 91       	pop	r17
    31da:	0f 91       	pop	r16
    31dc:	08 95       	ret

000031de <vTaskSetTimeOutState>:
    31de:	20 91 9f 15 	lds	r18, 0x159F	; 0x80159f <xNumOfOverflows>
    31e2:	fc 01       	movw	r30, r24
    31e4:	20 83       	st	Z, r18
    31e6:	20 91 a4 15 	lds	r18, 0x15A4	; 0x8015a4 <xTickCount>
    31ea:	30 91 a5 15 	lds	r19, 0x15A5	; 0x8015a5 <xTickCount+0x1>
    31ee:	32 83       	std	Z+2, r19	; 0x02
    31f0:	21 83       	std	Z+1, r18	; 0x01
    31f2:	08 95       	ret

000031f4 <xTaskCheckForTimeOut>:
    31f4:	fc 01       	movw	r30, r24
    31f6:	0f b6       	in	r0, 0x3f	; 63
    31f8:	f8 94       	cli
    31fa:	0f 92       	push	r0
    31fc:	20 91 a4 15 	lds	r18, 0x15A4	; 0x8015a4 <xTickCount>
    3200:	30 91 a5 15 	lds	r19, 0x15A5	; 0x8015a5 <xTickCount+0x1>
    3204:	db 01       	movw	r26, r22
    3206:	8d 91       	ld	r24, X+
    3208:	9c 91       	ld	r25, X
    320a:	8f 3f       	cpi	r24, 0xFF	; 255
    320c:	bf ef       	ldi	r27, 0xFF	; 255
    320e:	9b 07       	cpc	r25, r27
    3210:	21 f1       	breq	.+72     	; 0x325a <xTaskCheckForTimeOut+0x66>
    3212:	40 91 9f 15 	lds	r20, 0x159F	; 0x80159f <xNumOfOverflows>
    3216:	50 81       	ld	r21, Z
    3218:	54 17       	cp	r21, r20
    321a:	29 f0       	breq	.+10     	; 0x3226 <xTaskCheckForTimeOut+0x32>
    321c:	41 81       	ldd	r20, Z+1	; 0x01
    321e:	52 81       	ldd	r21, Z+2	; 0x02
    3220:	24 17       	cp	r18, r20
    3222:	35 07       	cpc	r19, r21
    3224:	e0 f4       	brcc	.+56     	; 0x325e <xTaskCheckForTimeOut+0x6a>
    3226:	41 81       	ldd	r20, Z+1	; 0x01
    3228:	52 81       	ldd	r21, Z+2	; 0x02
    322a:	d9 01       	movw	r26, r18
    322c:	a4 1b       	sub	r26, r20
    322e:	b5 0b       	sbc	r27, r21
    3230:	a8 17       	cp	r26, r24
    3232:	b9 07       	cpc	r27, r25
    3234:	b0 f4       	brcc	.+44     	; 0x3262 <xTaskCheckForTimeOut+0x6e>
    3236:	42 1b       	sub	r20, r18
    3238:	53 0b       	sbc	r21, r19
    323a:	84 0f       	add	r24, r20
    323c:	95 1f       	adc	r25, r21
    323e:	db 01       	movw	r26, r22
    3240:	8d 93       	st	X+, r24
    3242:	9c 93       	st	X, r25
    3244:	80 91 9f 15 	lds	r24, 0x159F	; 0x80159f <xNumOfOverflows>
    3248:	80 83       	st	Z, r24
    324a:	80 91 a4 15 	lds	r24, 0x15A4	; 0x8015a4 <xTickCount>
    324e:	90 91 a5 15 	lds	r25, 0x15A5	; 0x8015a5 <xTickCount+0x1>
    3252:	92 83       	std	Z+2, r25	; 0x02
    3254:	81 83       	std	Z+1, r24	; 0x01
    3256:	80 e0       	ldi	r24, 0x00	; 0
    3258:	05 c0       	rjmp	.+10     	; 0x3264 <xTaskCheckForTimeOut+0x70>
    325a:	80 e0       	ldi	r24, 0x00	; 0
    325c:	03 c0       	rjmp	.+6      	; 0x3264 <xTaskCheckForTimeOut+0x70>
    325e:	81 e0       	ldi	r24, 0x01	; 1
    3260:	01 c0       	rjmp	.+2      	; 0x3264 <xTaskCheckForTimeOut+0x70>
    3262:	81 e0       	ldi	r24, 0x01	; 1
    3264:	0f 90       	pop	r0
    3266:	0f be       	out	0x3f, r0	; 63
    3268:	08 95       	ret

0000326a <vTaskMissedYield>:
    326a:	81 e0       	ldi	r24, 0x01	; 1
    326c:	80 93 a0 15 	sts	0x15A0, r24	; 0x8015a0 <xYieldPending>
    3270:	08 95       	ret

00003272 <vTaskPriorityInherit>:
    3272:	0f 93       	push	r16
    3274:	1f 93       	push	r17
    3276:	cf 93       	push	r28
    3278:	df 93       	push	r29
    327a:	fc 01       	movw	r30, r24
    327c:	89 2b       	or	r24, r25
    327e:	09 f4       	brne	.+2      	; 0x3282 <vTaskPriorityInherit+0x10>
    3280:	55 c0       	rjmp	.+170    	; 0x332c <vTaskPriorityInherit+0xba>
    3282:	26 89       	ldd	r18, Z+22	; 0x16
    3284:	a0 91 fd 15 	lds	r26, 0x15FD	; 0x8015fd <pxCurrentTCB>
    3288:	b0 91 fe 15 	lds	r27, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    328c:	56 96       	adiw	r26, 0x16	; 22
    328e:	8c 91       	ld	r24, X
    3290:	28 17       	cp	r18, r24
    3292:	08 f0       	brcs	.+2      	; 0x3296 <vTaskPriorityInherit+0x24>
    3294:	4b c0       	rjmp	.+150    	; 0x332c <vTaskPriorityInherit+0xba>
    3296:	84 85       	ldd	r24, Z+12	; 0x0c
    3298:	95 85       	ldd	r25, Z+13	; 0x0d
    329a:	99 23       	and	r25, r25
    329c:	64 f0       	brlt	.+24     	; 0x32b6 <vTaskPriorityInherit+0x44>
    329e:	a0 91 fd 15 	lds	r26, 0x15FD	; 0x8015fd <pxCurrentTCB>
    32a2:	b0 91 fe 15 	lds	r27, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    32a6:	56 96       	adiw	r26, 0x16	; 22
    32a8:	3c 91       	ld	r19, X
    32aa:	84 e0       	ldi	r24, 0x04	; 4
    32ac:	90 e0       	ldi	r25, 0x00	; 0
    32ae:	83 1b       	sub	r24, r19
    32b0:	91 09       	sbc	r25, r1
    32b2:	95 87       	std	Z+13, r25	; 0x0d
    32b4:	84 87       	std	Z+12, r24	; 0x0c
    32b6:	30 e0       	ldi	r19, 0x00	; 0
    32b8:	c9 01       	movw	r24, r18
    32ba:	88 0f       	add	r24, r24
    32bc:	99 1f       	adc	r25, r25
    32be:	88 0f       	add	r24, r24
    32c0:	99 1f       	adc	r25, r25
    32c2:	88 0f       	add	r24, r24
    32c4:	99 1f       	adc	r25, r25
    32c6:	28 0f       	add	r18, r24
    32c8:	39 1f       	adc	r19, r25
    32ca:	27 52       	subi	r18, 0x27	; 39
    32cc:	3a 4e       	sbci	r19, 0xEA	; 234
    32ce:	82 85       	ldd	r24, Z+10	; 0x0a
    32d0:	93 85       	ldd	r25, Z+11	; 0x0b
    32d2:	82 17       	cp	r24, r18
    32d4:	93 07       	cpc	r25, r19
    32d6:	19 f5       	brne	.+70     	; 0x331e <vTaskPriorityInherit+0xac>
    32d8:	8f 01       	movw	r16, r30
    32da:	ef 01       	movw	r28, r30
    32dc:	22 96       	adiw	r28, 0x02	; 2
    32de:	ce 01       	movw	r24, r28
    32e0:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    32e4:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    32e8:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    32ec:	86 89       	ldd	r24, Z+22	; 0x16
    32ee:	f8 01       	movw	r30, r16
    32f0:	86 8b       	std	Z+22, r24	; 0x16
    32f2:	90 91 a3 15 	lds	r25, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
    32f6:	98 17       	cp	r25, r24
    32f8:	10 f4       	brcc	.+4      	; 0x32fe <vTaskPriorityInherit+0x8c>
    32fa:	80 93 a3 15 	sts	0x15A3, r24	; 0x8015a3 <uxTopReadyPriority>
    32fe:	90 e0       	ldi	r25, 0x00	; 0
    3300:	9c 01       	movw	r18, r24
    3302:	22 0f       	add	r18, r18
    3304:	33 1f       	adc	r19, r19
    3306:	22 0f       	add	r18, r18
    3308:	33 1f       	adc	r19, r19
    330a:	22 0f       	add	r18, r18
    330c:	33 1f       	adc	r19, r19
    330e:	82 0f       	add	r24, r18
    3310:	93 1f       	adc	r25, r19
    3312:	be 01       	movw	r22, r28
    3314:	87 52       	subi	r24, 0x27	; 39
    3316:	9a 4e       	sbci	r25, 0xEA	; 234
    3318:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    331c:	07 c0       	rjmp	.+14     	; 0x332c <vTaskPriorityInherit+0xba>
    331e:	a0 91 fd 15 	lds	r26, 0x15FD	; 0x8015fd <pxCurrentTCB>
    3322:	b0 91 fe 15 	lds	r27, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    3326:	56 96       	adiw	r26, 0x16	; 22
    3328:	8c 91       	ld	r24, X
    332a:	86 8b       	std	Z+22, r24	; 0x16
    332c:	df 91       	pop	r29
    332e:	cf 91       	pop	r28
    3330:	1f 91       	pop	r17
    3332:	0f 91       	pop	r16
    3334:	08 95       	ret

00003336 <xTaskPriorityDisinherit>:
    3336:	0f 93       	push	r16
    3338:	1f 93       	push	r17
    333a:	cf 93       	push	r28
    333c:	df 93       	push	r29
    333e:	fc 01       	movw	r30, r24
    3340:	89 2b       	or	r24, r25
    3342:	79 f1       	breq	.+94     	; 0x33a2 <xTaskPriorityDisinherit+0x6c>
    3344:	82 a1       	ldd	r24, Z+34	; 0x22
    3346:	81 50       	subi	r24, 0x01	; 1
    3348:	82 a3       	std	Z+34, r24	; 0x22
    334a:	26 89       	ldd	r18, Z+22	; 0x16
    334c:	91 a1       	ldd	r25, Z+33	; 0x21
    334e:	29 17       	cp	r18, r25
    3350:	51 f1       	breq	.+84     	; 0x33a6 <xTaskPriorityDisinherit+0x70>
    3352:	81 11       	cpse	r24, r1
    3354:	2a c0       	rjmp	.+84     	; 0x33aa <xTaskPriorityDisinherit+0x74>
    3356:	ef 01       	movw	r28, r30
    3358:	8f 01       	movw	r16, r30
    335a:	0e 5f       	subi	r16, 0xFE	; 254
    335c:	1f 4f       	sbci	r17, 0xFF	; 255
    335e:	c8 01       	movw	r24, r16
    3360:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    3364:	89 a1       	ldd	r24, Y+33	; 0x21
    3366:	8e 8b       	std	Y+22, r24	; 0x16
    3368:	24 e0       	ldi	r18, 0x04	; 4
    336a:	30 e0       	ldi	r19, 0x00	; 0
    336c:	28 1b       	sub	r18, r24
    336e:	31 09       	sbc	r19, r1
    3370:	3d 87       	std	Y+13, r19	; 0x0d
    3372:	2c 87       	std	Y+12, r18	; 0x0c
    3374:	90 91 a3 15 	lds	r25, 0x15A3	; 0x8015a3 <uxTopReadyPriority>
    3378:	98 17       	cp	r25, r24
    337a:	10 f4       	brcc	.+4      	; 0x3380 <xTaskPriorityDisinherit+0x4a>
    337c:	80 93 a3 15 	sts	0x15A3, r24	; 0x8015a3 <uxTopReadyPriority>
    3380:	90 e0       	ldi	r25, 0x00	; 0
    3382:	9c 01       	movw	r18, r24
    3384:	22 0f       	add	r18, r18
    3386:	33 1f       	adc	r19, r19
    3388:	22 0f       	add	r18, r18
    338a:	33 1f       	adc	r19, r19
    338c:	22 0f       	add	r18, r18
    338e:	33 1f       	adc	r19, r19
    3390:	82 0f       	add	r24, r18
    3392:	93 1f       	adc	r25, r19
    3394:	b8 01       	movw	r22, r16
    3396:	87 52       	subi	r24, 0x27	; 39
    3398:	9a 4e       	sbci	r25, 0xEA	; 234
    339a:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    339e:	81 e0       	ldi	r24, 0x01	; 1
    33a0:	05 c0       	rjmp	.+10     	; 0x33ac <xTaskPriorityDisinherit+0x76>
    33a2:	80 e0       	ldi	r24, 0x00	; 0
    33a4:	03 c0       	rjmp	.+6      	; 0x33ac <xTaskPriorityDisinherit+0x76>
    33a6:	80 e0       	ldi	r24, 0x00	; 0
    33a8:	01 c0       	rjmp	.+2      	; 0x33ac <xTaskPriorityDisinherit+0x76>
    33aa:	80 e0       	ldi	r24, 0x00	; 0
    33ac:	df 91       	pop	r29
    33ae:	cf 91       	pop	r28
    33b0:	1f 91       	pop	r17
    33b2:	0f 91       	pop	r16
    33b4:	08 95       	ret

000033b6 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    33b6:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <pxCurrentTCB>
    33ba:	90 91 fe 15 	lds	r25, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    33be:	89 2b       	or	r24, r25
    33c0:	39 f0       	breq	.+14     	; 0x33d0 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    33c2:	e0 91 fd 15 	lds	r30, 0x15FD	; 0x8015fd <pxCurrentTCB>
    33c6:	f0 91 fe 15 	lds	r31, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
    33ca:	82 a1       	ldd	r24, Z+34	; 0x22
    33cc:	8f 5f       	subi	r24, 0xFF	; 255
    33ce:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    33d0:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <pxCurrentTCB>
    33d4:	90 91 fe 15 	lds	r25, 0x15FE	; 0x8015fe <pxCurrentTCB+0x1>
	}
    33d8:	08 95       	ret

000033da <xSerialxPrint>:

		default:
			break;
	}
	return 0;
}
    33da:	4f 92       	push	r4
    33dc:	5f 92       	push	r5
    33de:	6f 92       	push	r6
    33e0:	7f 92       	push	r7
    33e2:	8f 92       	push	r8
    33e4:	9f 92       	push	r9
    33e6:	af 92       	push	r10
    33e8:	bf 92       	push	r11
    33ea:	cf 92       	push	r12
    33ec:	df 92       	push	r13
    33ee:	ef 92       	push	r14
    33f0:	ff 92       	push	r15
    33f2:	0f 93       	push	r16
    33f4:	1f 93       	push	r17
    33f6:	cf 93       	push	r28
    33f8:	df 93       	push	r29
    33fa:	ec 01       	movw	r28, r24
    33fc:	fb 01       	movw	r30, r22
    33fe:	01 90       	ld	r0, Z+
    3400:	00 20       	and	r0, r0
    3402:	e9 f7       	brne	.-6      	; 0x33fe <xSerialxPrint+0x24>
    3404:	4b 01       	movw	r8, r22
    3406:	9f 01       	movw	r18, r30
    3408:	21 50       	subi	r18, 0x01	; 1
    340a:	31 09       	sbc	r19, r1
    340c:	0f 2e       	mov	r0, r31
    340e:	f1 e3       	ldi	r31, 0x31	; 49
    3410:	ef 2e       	mov	r14, r31
    3412:	ff 24       	eor	r15, r15
    3414:	f3 94       	inc	r15
    3416:	f0 2d       	mov	r31, r0
    3418:	01 ed       	ldi	r16, 0xD1	; 209
    341a:	10 e0       	ldi	r17, 0x00	; 0
    341c:	69 ec       	ldi	r22, 0xC9	; 201
    341e:	70 e0       	ldi	r23, 0x00	; 0
    3420:	41 ec       	ldi	r20, 0xC1	; 193
    3422:	50 e0       	ldi	r21, 0x00	; 0
    3424:	5c 01       	movw	r10, r24
    3426:	8d e0       	ldi	r24, 0x0D	; 13
    3428:	a8 0e       	add	r10, r24
    342a:	b1 1c       	adc	r11, r1
    342c:	7f c0       	rjmp	.+254    	; 0x352c <xSerialxPrint+0x152>
    342e:	d4 01       	movw	r26, r8
    3430:	dd 90       	ld	r13, X+
    3432:	4d 01       	movw	r8, r26
    3434:	0f b6       	in	r0, 0x3f	; 63
    3436:	f8 94       	cli
    3438:	0f 92       	push	r0
    343a:	ed 85       	ldd	r30, Y+13	; 0x0d
    343c:	fe 85       	ldd	r31, Y+14	; 0x0e
    343e:	0f 90       	pop	r0
    3440:	0f be       	out	0x3f, r0	; 63
    3442:	8f 89       	ldd	r24, Y+23	; 0x17
    3444:	98 8d       	ldd	r25, Y+24	; 0x18
    3446:	e8 17       	cp	r30, r24
    3448:	f9 07       	cpc	r31, r25
    344a:	f1 f0       	breq	.+60     	; 0x3488 <xSerialxPrint+0xae>
    344c:	f5 01       	movw	r30, r10
    344e:	82 81       	ldd	r24, Z+2	; 0x02
    3450:	93 81       	ldd	r25, Z+3	; 0x03
    3452:	dc 01       	movw	r26, r24
    3454:	dc 92       	st	X, r13
    3456:	82 81       	ldd	r24, Z+2	; 0x02
    3458:	93 81       	ldd	r25, Z+3	; 0x03
    345a:	01 96       	adiw	r24, 0x01	; 1
    345c:	93 83       	std	Z+3, r25	; 0x03
    345e:	82 83       	std	Z+2, r24	; 0x02
    3460:	c0 84       	ldd	r12, Z+8	; 0x08
    3462:	d1 84       	ldd	r13, Z+9	; 0x09
    3464:	8c 15       	cp	r24, r12
    3466:	9d 05       	cpc	r25, r13
    3468:	21 f4       	brne	.+8      	; 0x3472 <xSerialxPrint+0x98>
    346a:	86 81       	ldd	r24, Z+6	; 0x06
    346c:	97 81       	ldd	r25, Z+7	; 0x07
    346e:	93 83       	std	Z+3, r25	; 0x03
    3470:	82 83       	std	Z+2, r24	; 0x02
    3472:	0f b6       	in	r0, 0x3f	; 63
    3474:	f8 94       	cli
    3476:	0f 92       	push	r0
    3478:	80 81       	ld	r24, Z
    347a:	91 81       	ldd	r25, Z+1	; 0x01
    347c:	01 96       	adiw	r24, 0x01	; 1
    347e:	91 83       	std	Z+1, r25	; 0x01
    3480:	80 83       	st	Z, r24
    3482:	0f 90       	pop	r0
    3484:	0f be       	out	0x3f, r0	; 63
    3486:	33 c0       	rjmp	.+102    	; 0x34ee <xSerialxPrint+0x114>
    3488:	bf ef       	ldi	r27, 0xFF	; 255
    348a:	ef e8       	ldi	r30, 0x8F	; 143
    348c:	f1 e0       	ldi	r31, 0x01	; 1
    348e:	b1 50       	subi	r27, 0x01	; 1
    3490:	e0 40       	sbci	r30, 0x00	; 0
    3492:	f0 40       	sbci	r31, 0x00	; 0
    3494:	e1 f7       	brne	.-8      	; 0x348e <xSerialxPrint+0xb4>
    3496:	00 c0       	rjmp	.+0      	; 0x3498 <xSerialxPrint+0xbe>
    3498:	00 00       	nop
    349a:	0f b6       	in	r0, 0x3f	; 63
    349c:	f8 94       	cli
    349e:	0f 92       	push	r0
    34a0:	ed 85       	ldd	r30, Y+13	; 0x0d
    34a2:	fe 85       	ldd	r31, Y+14	; 0x0e
    34a4:	0f 90       	pop	r0
    34a6:	0f be       	out	0x3f, r0	; 63
    34a8:	8f 89       	ldd	r24, Y+23	; 0x17
    34aa:	98 8d       	ldd	r25, Y+24	; 0x18
    34ac:	e8 17       	cp	r30, r24
    34ae:	f9 07       	cpc	r31, r25
    34b0:	09 f4       	brne	.+2      	; 0x34b4 <xSerialxPrint+0xda>
    34b2:	3c c0       	rjmp	.+120    	; 0x352c <xSerialxPrint+0x152>
    34b4:	f5 01       	movw	r30, r10
    34b6:	82 81       	ldd	r24, Z+2	; 0x02
    34b8:	93 81       	ldd	r25, Z+3	; 0x03
    34ba:	dc 01       	movw	r26, r24
    34bc:	dc 92       	st	X, r13
    34be:	82 81       	ldd	r24, Z+2	; 0x02
    34c0:	93 81       	ldd	r25, Z+3	; 0x03
    34c2:	01 96       	adiw	r24, 0x01	; 1
    34c4:	93 83       	std	Z+3, r25	; 0x03
    34c6:	82 83       	std	Z+2, r24	; 0x02
    34c8:	c0 84       	ldd	r12, Z+8	; 0x08
    34ca:	d1 84       	ldd	r13, Z+9	; 0x09
    34cc:	8c 15       	cp	r24, r12
    34ce:	9d 05       	cpc	r25, r13
    34d0:	21 f4       	brne	.+8      	; 0x34da <xSerialxPrint+0x100>
    34d2:	86 81       	ldd	r24, Z+6	; 0x06
    34d4:	97 81       	ldd	r25, Z+7	; 0x07
    34d6:	93 83       	std	Z+3, r25	; 0x03
    34d8:	82 83       	std	Z+2, r24	; 0x02
    34da:	0f b6       	in	r0, 0x3f	; 63
    34dc:	f8 94       	cli
    34de:	0f 92       	push	r0
    34e0:	80 81       	ld	r24, Z
    34e2:	91 81       	ldd	r25, Z+1	; 0x01
    34e4:	01 96       	adiw	r24, 0x01	; 1
    34e6:	91 83       	std	Z+1, r25	; 0x01
    34e8:	80 83       	st	Z, r24
    34ea:	0f 90       	pop	r0
    34ec:	0f be       	out	0x3f, r0	; 63
    34ee:	48 80       	ld	r4, Y
    34f0:	51 2c       	mov	r5, r1
    34f2:	b8 e0       	ldi	r27, 0x08	; 8
    34f4:	4b 16       	cp	r4, r27
    34f6:	51 04       	cpc	r5, r1
    34f8:	c8 f4       	brcc	.+50     	; 0x352c <xSerialxPrint+0x152>
    34fa:	f2 01       	movw	r30, r4
    34fc:	88 27       	eor	r24, r24
    34fe:	ee 58       	subi	r30, 0x8E	; 142
    3500:	ff 4f       	sbci	r31, 0xFF	; 255
    3502:	8f 4f       	sbci	r24, 0xFF	; 255
    3504:	8b c5       	rjmp	.+2838   	; 0x401c <__tablejump2__>
    3506:	fa 01       	movw	r30, r20
    3508:	80 81       	ld	r24, Z
    350a:	80 62       	ori	r24, 0x20	; 32
    350c:	80 83       	st	Z, r24
    350e:	0e c0       	rjmp	.+28     	; 0x352c <xSerialxPrint+0x152>
    3510:	db 01       	movw	r26, r22
    3512:	8c 91       	ld	r24, X
    3514:	80 62       	ori	r24, 0x20	; 32
    3516:	8c 93       	st	X, r24
    3518:	09 c0       	rjmp	.+18     	; 0x352c <xSerialxPrint+0x152>
    351a:	f8 01       	movw	r30, r16
    351c:	80 81       	ld	r24, Z
    351e:	80 62       	ori	r24, 0x20	; 32
    3520:	80 83       	st	Z, r24
    3522:	04 c0       	rjmp	.+8      	; 0x352c <xSerialxPrint+0x152>
    3524:	d7 01       	movw	r26, r14
    3526:	8c 91       	ld	r24, X
    3528:	80 62       	ori	r24, 0x20	; 32
    352a:	8c 93       	st	X, r24
    352c:	82 16       	cp	r8, r18
    352e:	93 06       	cpc	r9, r19
    3530:	09 f0       	breq	.+2      	; 0x3534 <xSerialxPrint+0x15a>
    3532:	7d cf       	rjmp	.-262    	; 0x342e <xSerialxPrint+0x54>
    3534:	df 91       	pop	r29
    3536:	cf 91       	pop	r28
    3538:	1f 91       	pop	r17
    353a:	0f 91       	pop	r16
    353c:	ff 90       	pop	r15
    353e:	ef 90       	pop	r14
    3540:	df 90       	pop	r13
    3542:	cf 90       	pop	r12
    3544:	bf 90       	pop	r11
    3546:	af 90       	pop	r10
    3548:	9f 90       	pop	r9
    354a:	8f 90       	pop	r8
    354c:	7f 90       	pop	r7
    354e:	6f 90       	pop	r6
    3550:	5f 90       	pop	r5
    3552:	4f 90       	pop	r4
    3554:	08 95       	ret

00003556 <xSerialxPrintf>:
    3556:	0f 93       	push	r16
    3558:	1f 93       	push	r17
    355a:	cf 93       	push	r28
    355c:	df 93       	push	r29
    355e:	cd b7       	in	r28, 0x3d	; 61
    3560:	de b7       	in	r29, 0x3e	; 62
    3562:	08 85       	ldd	r16, Y+8	; 0x08
    3564:	19 85       	ldd	r17, Y+9	; 0x09
    3566:	f8 01       	movw	r30, r16
    3568:	85 8d       	ldd	r24, Z+29	; 0x1d
    356a:	81 30       	cpi	r24, 0x01	; 1
    356c:	31 f4       	brne	.+12     	; 0x357a <xSerialxPrintf+0x24>
    356e:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <vPortYield>
    3572:	f8 01       	movw	r30, r16
    3574:	85 8d       	ldd	r24, Z+29	; 0x1d
    3576:	81 30       	cpi	r24, 0x01	; 1
    3578:	d1 f3       	breq	.-12     	; 0x356e <xSerialxPrintf+0x18>
    357a:	81 e0       	ldi	r24, 0x01	; 1
    357c:	f8 01       	movw	r30, r16
    357e:	85 8f       	std	Z+29, r24	; 0x1d
    3580:	63 8d       	ldd	r22, Z+27	; 0x1b
    3582:	74 8d       	ldd	r23, Z+28	; 0x1c
    3584:	9e 01       	movw	r18, r28
    3586:	24 5f       	subi	r18, 0xF4	; 244
    3588:	3f 4f       	sbci	r19, 0xFF	; 255
    358a:	4a 85       	ldd	r20, Y+10	; 0x0a
    358c:	5b 85       	ldd	r21, Y+11	; 0x0b
    358e:	81 8d       	ldd	r24, Z+25	; 0x19
    3590:	92 8d       	ldd	r25, Z+26	; 0x1a
    3592:	a1 d5       	rcall	.+2882   	; 0x40d6 <vsnprintf>
    3594:	f8 01       	movw	r30, r16
    3596:	61 8d       	ldd	r22, Z+25	; 0x19
    3598:	72 8d       	ldd	r23, Z+26	; 0x1a
    359a:	c8 01       	movw	r24, r16
    359c:	1e df       	rcall	.-452    	; 0x33da <xSerialxPrint>
    359e:	f8 01       	movw	r30, r16
    35a0:	15 8e       	std	Z+29, r1	; 0x1d
    35a2:	df 91       	pop	r29
    35a4:	cf 91       	pop	r28
    35a6:	1f 91       	pop	r17
    35a8:	0f 91       	pop	r16
    35aa:	08 95       	ret

000035ac <xSerialPortInitMinimal>:
    35ac:	7f 92       	push	r7
    35ae:	8f 92       	push	r8
    35b0:	9f 92       	push	r9
    35b2:	af 92       	push	r10
    35b4:	bf 92       	push	r11
    35b6:	cf 92       	push	r12
    35b8:	df 92       	push	r13
    35ba:	ef 92       	push	r14
    35bc:	ff 92       	push	r15
    35be:	0f 93       	push	r16
    35c0:	1f 93       	push	r17
    35c2:	cf 93       	push	r28
    35c4:	df 93       	push	r29
    35c6:	cd b7       	in	r28, 0x3d	; 61
    35c8:	de b7       	in	r29, 0x3e	; 62
    35ca:	a2 97       	sbiw	r28, 0x22	; 34
    35cc:	0f b6       	in	r0, 0x3f	; 63
    35ce:	f8 94       	cli
    35d0:	de bf       	out	0x3e, r29	; 62
    35d2:	0f be       	out	0x3f, r0	; 63
    35d4:	cd bf       	out	0x3d, r28	; 61
    35d6:	6c 01       	movw	r12, r24
    35d8:	76 2e       	mov	r7, r22
    35da:	49 01       	movw	r8, r18
    35dc:	5a 01       	movw	r10, r20
    35de:	c7 01       	movw	r24, r14
    35e0:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <pvPortMalloc>
    35e4:	00 97       	sbiw	r24, 0x00	; 0
    35e6:	a9 f0       	breq	.+42     	; 0x3612 <xSerialPortInitMinimal+0x66>
    35e8:	fe 01       	movw	r30, r28
    35ea:	32 96       	adiw	r30, 0x02	; 2
    35ec:	0f b6       	in	r0, 0x3f	; 63
    35ee:	f8 94       	cli
    35f0:	0f 92       	push	r0
    35f2:	11 82       	std	Z+1, r1	; 0x01
    35f4:	10 82       	st	Z, r1
    35f6:	93 83       	std	Z+3, r25	; 0x03
    35f8:	82 83       	std	Z+2, r24	; 0x02
    35fa:	95 83       	std	Z+5, r25	; 0x05
    35fc:	84 83       	std	Z+4, r24	; 0x04
    35fe:	97 83       	std	Z+7, r25	; 0x07
    3600:	86 83       	std	Z+6, r24	; 0x06
    3602:	8e 0d       	add	r24, r14
    3604:	9f 1d       	adc	r25, r15
    3606:	91 87       	std	Z+9, r25	; 0x09
    3608:	80 87       	std	Z+8, r24	; 0x08
    360a:	f3 86       	std	Z+11, r15	; 0x0b
    360c:	e2 86       	std	Z+10, r14	; 0x0a
    360e:	0f 90       	pop	r0
    3610:	0f be       	out	0x3f, r0	; 63
    3612:	c8 01       	movw	r24, r16
    3614:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <pvPortMalloc>
    3618:	00 97       	sbiw	r24, 0x00	; 0
    361a:	a9 f0       	breq	.+42     	; 0x3646 <xSerialPortInitMinimal+0x9a>
    361c:	fe 01       	movw	r30, r28
    361e:	3e 96       	adiw	r30, 0x0e	; 14
    3620:	0f b6       	in	r0, 0x3f	; 63
    3622:	f8 94       	cli
    3624:	0f 92       	push	r0
    3626:	11 82       	std	Z+1, r1	; 0x01
    3628:	10 82       	st	Z, r1
    362a:	93 83       	std	Z+3, r25	; 0x03
    362c:	82 83       	std	Z+2, r24	; 0x02
    362e:	95 83       	std	Z+5, r25	; 0x05
    3630:	84 83       	std	Z+4, r24	; 0x04
    3632:	97 83       	std	Z+7, r25	; 0x07
    3634:	86 83       	std	Z+6, r24	; 0x06
    3636:	80 0f       	add	r24, r16
    3638:	91 1f       	adc	r25, r17
    363a:	91 87       	std	Z+9, r25	; 0x09
    363c:	80 87       	std	Z+8, r24	; 0x08
    363e:	13 87       	std	Z+11, r17	; 0x0b
    3640:	02 87       	std	Z+10, r16	; 0x0a
    3642:	0f 90       	pop	r0
    3644:	0f be       	out	0x3f, r0	; 63
    3646:	c8 01       	movw	r24, r16
    3648:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <pvPortMalloc>
    364c:	9b 8f       	std	Y+27, r25	; 0x1b
    364e:	8a 8f       	std	Y+26, r24	; 0x1a
    3650:	79 82       	std	Y+1, r7	; 0x01
    3652:	1d 8f       	std	Y+29, r17	; 0x1d
    3654:	0c 8f       	std	Y+28, r16	; 0x1c
    3656:	1e 8e       	std	Y+30, r1	; 0x1e
    3658:	8f 8e       	std	Y+31, r8	; 0x1f
    365a:	98 a2       	std	Y+32, r9	; 0x20
    365c:	a9 a2       	std	Y+33, r10	; 0x21
    365e:	ba a2       	std	Y+34, r11	; 0x22
    3660:	0f b6       	in	r0, 0x3f	; 63
    3662:	f8 94       	cli
    3664:	0f 92       	push	r0
    3666:	89 81       	ldd	r24, Y+1	; 0x01
    3668:	90 e0       	ldi	r25, 0x00	; 0
    366a:	88 30       	cpi	r24, 0x08	; 8
    366c:	91 05       	cpc	r25, r1
    366e:	08 f0       	brcs	.+2      	; 0x3672 <xSerialPortInitMinimal+0xc6>
    3670:	b1 c1       	rjmp	.+866    	; 0x39d4 <xSerialPortInitMinimal+0x428>
    3672:	fc 01       	movw	r30, r24
    3674:	88 27       	eor	r24, r24
    3676:	e6 58       	subi	r30, 0x86	; 134
    3678:	ff 4f       	sbci	r31, 0xFF	; 255
    367a:	8f 4f       	sbci	r24, 0xFF	; 255
    367c:	cf c4       	rjmp	.+2462   	; 0x401c <__tablejump2__>
    367e:	d5 01       	movw	r26, r10
    3680:	c4 01       	movw	r24, r8
    3682:	97 5f       	subi	r25, 0xF7	; 247
    3684:	a2 4c       	sbci	r26, 0xC2	; 194
    3686:	bf 4f       	sbci	r27, 0xFF	; 255
    3688:	bc 01       	movw	r22, r24
    368a:	cd 01       	movw	r24, r26
    368c:	66 0f       	add	r22, r22
    368e:	77 1f       	adc	r23, r23
    3690:	88 1f       	adc	r24, r24
    3692:	99 1f       	adc	r25, r25
    3694:	66 0f       	add	r22, r22
    3696:	77 1f       	adc	r23, r23
    3698:	88 1f       	adc	r24, r24
    369a:	99 1f       	adc	r25, r25
    369c:	95 01       	movw	r18, r10
    369e:	84 01       	movw	r16, r8
    36a0:	00 0f       	add	r16, r16
    36a2:	11 1f       	adc	r17, r17
    36a4:	22 1f       	adc	r18, r18
    36a6:	33 1f       	adc	r19, r19
    36a8:	00 0f       	add	r16, r16
    36aa:	11 1f       	adc	r17, r17
    36ac:	22 1f       	adc	r18, r18
    36ae:	33 1f       	adc	r19, r19
    36b0:	a9 01       	movw	r20, r18
    36b2:	98 01       	movw	r18, r16
    36b4:	22 0f       	add	r18, r18
    36b6:	33 1f       	adc	r19, r19
    36b8:	44 1f       	adc	r20, r20
    36ba:	55 1f       	adc	r21, r21
    36bc:	71 d4       	rcall	.+2274   	; 0x3fa0 <__udivmodsi4>
    36be:	21 50       	subi	r18, 0x01	; 1
    36c0:	31 09       	sbc	r19, r1
    36c2:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    36c6:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    36ca:	82 e0       	ldi	r24, 0x02	; 2
    36cc:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    36d0:	88 e9       	ldi	r24, 0x98	; 152
    36d2:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    36d6:	8e e0       	ldi	r24, 0x0E	; 14
    36d8:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    36dc:	7b c1       	rjmp	.+758    	; 0x39d4 <xSerialPortInitMinimal+0x428>
    36de:	04 ec       	ldi	r16, 0xC4	; 196
    36e0:	10 e0       	ldi	r17, 0x00	; 0
    36e2:	f8 01       	movw	r30, r16
    36e4:	11 82       	std	Z+1, r1	; 0x01
    36e6:	10 82       	st	Z, r1
    36e8:	6a 9a       	sbi	0x0d, 2	; 13
    36ea:	80 ec       	ldi	r24, 0xC0	; 192
    36ec:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    36f0:	88 e9       	ldi	r24, 0x98	; 152
    36f2:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    36f6:	d5 01       	movw	r26, r10
    36f8:	c4 01       	movw	r24, r8
    36fa:	80 58       	subi	r24, 0x80	; 128
    36fc:	9b 47       	sbci	r25, 0x7B	; 123
    36fe:	a1 4e       	sbci	r26, 0xE1	; 225
    3700:	bf 4f       	sbci	r27, 0xFF	; 255
    3702:	88 0f       	add	r24, r24
    3704:	99 1f       	adc	r25, r25
    3706:	aa 1f       	adc	r26, r26
    3708:	bb 1f       	adc	r27, r27
    370a:	88 0f       	add	r24, r24
    370c:	99 1f       	adc	r25, r25
    370e:	aa 1f       	adc	r26, r26
    3710:	bb 1f       	adc	r27, r27
    3712:	bc 01       	movw	r22, r24
    3714:	cd 01       	movw	r24, r26
    3716:	66 0f       	add	r22, r22
    3718:	77 1f       	adc	r23, r23
    371a:	88 1f       	adc	r24, r24
    371c:	99 1f       	adc	r25, r25
    371e:	88 0c       	add	r8, r8
    3720:	99 1c       	adc	r9, r9
    3722:	aa 1c       	adc	r10, r10
    3724:	bb 1c       	adc	r11, r11
    3726:	88 0c       	add	r8, r8
    3728:	99 1c       	adc	r9, r9
    372a:	aa 1c       	adc	r10, r10
    372c:	bb 1c       	adc	r11, r11
    372e:	a5 01       	movw	r20, r10
    3730:	94 01       	movw	r18, r8
    3732:	22 0f       	add	r18, r18
    3734:	33 1f       	adc	r19, r19
    3736:	44 1f       	adc	r20, r20
    3738:	55 1f       	adc	r21, r21
    373a:	22 0f       	add	r18, r18
    373c:	33 1f       	adc	r19, r19
    373e:	44 1f       	adc	r20, r20
    3740:	55 1f       	adc	r21, r21
    3742:	2e d4       	rcall	.+2140   	; 0x3fa0 <__udivmodsi4>
    3744:	21 50       	subi	r18, 0x01	; 1
    3746:	31 09       	sbc	r19, r1
    3748:	f8 01       	movw	r30, r16
    374a:	31 83       	std	Z+1, r19	; 0x01
    374c:	20 83       	st	Z, r18
    374e:	42 c1       	rjmp	.+644    	; 0x39d4 <xSerialPortInitMinimal+0x428>
    3750:	d5 01       	movw	r26, r10
    3752:	c4 01       	movw	r24, r8
    3754:	97 5f       	subi	r25, 0xF7	; 247
    3756:	a2 4c       	sbci	r26, 0xC2	; 194
    3758:	bf 4f       	sbci	r27, 0xFF	; 255
    375a:	bc 01       	movw	r22, r24
    375c:	cd 01       	movw	r24, r26
    375e:	66 0f       	add	r22, r22
    3760:	77 1f       	adc	r23, r23
    3762:	88 1f       	adc	r24, r24
    3764:	99 1f       	adc	r25, r25
    3766:	66 0f       	add	r22, r22
    3768:	77 1f       	adc	r23, r23
    376a:	88 1f       	adc	r24, r24
    376c:	99 1f       	adc	r25, r25
    376e:	95 01       	movw	r18, r10
    3770:	84 01       	movw	r16, r8
    3772:	00 0f       	add	r16, r16
    3774:	11 1f       	adc	r17, r17
    3776:	22 1f       	adc	r18, r18
    3778:	33 1f       	adc	r19, r19
    377a:	00 0f       	add	r16, r16
    377c:	11 1f       	adc	r17, r17
    377e:	22 1f       	adc	r18, r18
    3780:	33 1f       	adc	r19, r19
    3782:	a9 01       	movw	r20, r18
    3784:	98 01       	movw	r18, r16
    3786:	22 0f       	add	r18, r18
    3788:	33 1f       	adc	r19, r19
    378a:	44 1f       	adc	r20, r20
    378c:	55 1f       	adc	r21, r21
    378e:	08 d4       	rcall	.+2064   	; 0x3fa0 <__udivmodsi4>
    3790:	21 50       	subi	r18, 0x01	; 1
    3792:	31 09       	sbc	r19, r1
    3794:	30 93 cd 00 	sts	0x00CD, r19	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    3798:	20 93 cc 00 	sts	0x00CC, r18	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    379c:	82 e0       	ldi	r24, 0x02	; 2
    379e:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    37a2:	88 e9       	ldi	r24, 0x98	; 152
    37a4:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    37a8:	8e e0       	ldi	r24, 0x0E	; 14
    37aa:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    37ae:	12 c1       	rjmp	.+548    	; 0x39d4 <xSerialPortInitMinimal+0x428>
    37b0:	0c ec       	ldi	r16, 0xCC	; 204
    37b2:	10 e0       	ldi	r17, 0x00	; 0
    37b4:	f8 01       	movw	r30, r16
    37b6:	11 82       	std	Z+1, r1	; 0x01
    37b8:	10 82       	st	Z, r1
    37ba:	55 9a       	sbi	0x0a, 5	; 10
    37bc:	80 ec       	ldi	r24, 0xC0	; 192
    37be:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    37c2:	88 e9       	ldi	r24, 0x98	; 152
    37c4:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    37c8:	d5 01       	movw	r26, r10
    37ca:	c4 01       	movw	r24, r8
    37cc:	80 58       	subi	r24, 0x80	; 128
    37ce:	9b 47       	sbci	r25, 0x7B	; 123
    37d0:	a1 4e       	sbci	r26, 0xE1	; 225
    37d2:	bf 4f       	sbci	r27, 0xFF	; 255
    37d4:	88 0f       	add	r24, r24
    37d6:	99 1f       	adc	r25, r25
    37d8:	aa 1f       	adc	r26, r26
    37da:	bb 1f       	adc	r27, r27
    37dc:	88 0f       	add	r24, r24
    37de:	99 1f       	adc	r25, r25
    37e0:	aa 1f       	adc	r26, r26
    37e2:	bb 1f       	adc	r27, r27
    37e4:	bc 01       	movw	r22, r24
    37e6:	cd 01       	movw	r24, r26
    37e8:	66 0f       	add	r22, r22
    37ea:	77 1f       	adc	r23, r23
    37ec:	88 1f       	adc	r24, r24
    37ee:	99 1f       	adc	r25, r25
    37f0:	88 0c       	add	r8, r8
    37f2:	99 1c       	adc	r9, r9
    37f4:	aa 1c       	adc	r10, r10
    37f6:	bb 1c       	adc	r11, r11
    37f8:	88 0c       	add	r8, r8
    37fa:	99 1c       	adc	r9, r9
    37fc:	aa 1c       	adc	r10, r10
    37fe:	bb 1c       	adc	r11, r11
    3800:	a5 01       	movw	r20, r10
    3802:	94 01       	movw	r18, r8
    3804:	22 0f       	add	r18, r18
    3806:	33 1f       	adc	r19, r19
    3808:	44 1f       	adc	r20, r20
    380a:	55 1f       	adc	r21, r21
    380c:	22 0f       	add	r18, r18
    380e:	33 1f       	adc	r19, r19
    3810:	44 1f       	adc	r20, r20
    3812:	55 1f       	adc	r21, r21
    3814:	c5 d3       	rcall	.+1930   	; 0x3fa0 <__udivmodsi4>
    3816:	21 50       	subi	r18, 0x01	; 1
    3818:	31 09       	sbc	r19, r1
    381a:	f8 01       	movw	r30, r16
    381c:	31 83       	std	Z+1, r19	; 0x01
    381e:	20 83       	st	Z, r18
    3820:	d9 c0       	rjmp	.+434    	; 0x39d4 <xSerialPortInitMinimal+0x428>
    3822:	d5 01       	movw	r26, r10
    3824:	c4 01       	movw	r24, r8
    3826:	97 5f       	subi	r25, 0xF7	; 247
    3828:	a2 4c       	sbci	r26, 0xC2	; 194
    382a:	bf 4f       	sbci	r27, 0xFF	; 255
    382c:	bc 01       	movw	r22, r24
    382e:	cd 01       	movw	r24, r26
    3830:	66 0f       	add	r22, r22
    3832:	77 1f       	adc	r23, r23
    3834:	88 1f       	adc	r24, r24
    3836:	99 1f       	adc	r25, r25
    3838:	66 0f       	add	r22, r22
    383a:	77 1f       	adc	r23, r23
    383c:	88 1f       	adc	r24, r24
    383e:	99 1f       	adc	r25, r25
    3840:	95 01       	movw	r18, r10
    3842:	84 01       	movw	r16, r8
    3844:	00 0f       	add	r16, r16
    3846:	11 1f       	adc	r17, r17
    3848:	22 1f       	adc	r18, r18
    384a:	33 1f       	adc	r19, r19
    384c:	00 0f       	add	r16, r16
    384e:	11 1f       	adc	r17, r17
    3850:	22 1f       	adc	r18, r18
    3852:	33 1f       	adc	r19, r19
    3854:	a9 01       	movw	r20, r18
    3856:	98 01       	movw	r18, r16
    3858:	22 0f       	add	r18, r18
    385a:	33 1f       	adc	r19, r19
    385c:	44 1f       	adc	r20, r20
    385e:	55 1f       	adc	r21, r21
    3860:	9f d3       	rcall	.+1854   	; 0x3fa0 <__udivmodsi4>
    3862:	21 50       	subi	r18, 0x01	; 1
    3864:	31 09       	sbc	r19, r1
    3866:	30 93 d5 00 	sts	0x00D5, r19	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    386a:	20 93 d4 00 	sts	0x00D4, r18	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    386e:	82 e0       	ldi	r24, 0x02	; 2
    3870:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    3874:	88 e9       	ldi	r24, 0x98	; 152
    3876:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    387a:	8e e0       	ldi	r24, 0x0E	; 14
    387c:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    3880:	a9 c0       	rjmp	.+338    	; 0x39d4 <xSerialPortInitMinimal+0x428>
    3882:	04 ed       	ldi	r16, 0xD4	; 212
    3884:	10 e0       	ldi	r17, 0x00	; 0
    3886:	f8 01       	movw	r30, r16
    3888:	11 82       	std	Z+1, r1	; 0x01
    388a:	10 82       	st	Z, r1
    388c:	e1 e0       	ldi	r30, 0x01	; 1
    388e:	f1 e0       	ldi	r31, 0x01	; 1
    3890:	80 81       	ld	r24, Z
    3892:	84 60       	ori	r24, 0x04	; 4
    3894:	80 83       	st	Z, r24
    3896:	80 ec       	ldi	r24, 0xC0	; 192
    3898:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    389c:	88 e9       	ldi	r24, 0x98	; 152
    389e:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    38a2:	d5 01       	movw	r26, r10
    38a4:	c4 01       	movw	r24, r8
    38a6:	80 58       	subi	r24, 0x80	; 128
    38a8:	9b 47       	sbci	r25, 0x7B	; 123
    38aa:	a1 4e       	sbci	r26, 0xE1	; 225
    38ac:	bf 4f       	sbci	r27, 0xFF	; 255
    38ae:	88 0f       	add	r24, r24
    38b0:	99 1f       	adc	r25, r25
    38b2:	aa 1f       	adc	r26, r26
    38b4:	bb 1f       	adc	r27, r27
    38b6:	88 0f       	add	r24, r24
    38b8:	99 1f       	adc	r25, r25
    38ba:	aa 1f       	adc	r26, r26
    38bc:	bb 1f       	adc	r27, r27
    38be:	bc 01       	movw	r22, r24
    38c0:	cd 01       	movw	r24, r26
    38c2:	66 0f       	add	r22, r22
    38c4:	77 1f       	adc	r23, r23
    38c6:	88 1f       	adc	r24, r24
    38c8:	99 1f       	adc	r25, r25
    38ca:	88 0c       	add	r8, r8
    38cc:	99 1c       	adc	r9, r9
    38ce:	aa 1c       	adc	r10, r10
    38d0:	bb 1c       	adc	r11, r11
    38d2:	88 0c       	add	r8, r8
    38d4:	99 1c       	adc	r9, r9
    38d6:	aa 1c       	adc	r10, r10
    38d8:	bb 1c       	adc	r11, r11
    38da:	a5 01       	movw	r20, r10
    38dc:	94 01       	movw	r18, r8
    38de:	22 0f       	add	r18, r18
    38e0:	33 1f       	adc	r19, r19
    38e2:	44 1f       	adc	r20, r20
    38e4:	55 1f       	adc	r21, r21
    38e6:	22 0f       	add	r18, r18
    38e8:	33 1f       	adc	r19, r19
    38ea:	44 1f       	adc	r20, r20
    38ec:	55 1f       	adc	r21, r21
    38ee:	58 d3       	rcall	.+1712   	; 0x3fa0 <__udivmodsi4>
    38f0:	21 50       	subi	r18, 0x01	; 1
    38f2:	31 09       	sbc	r19, r1
    38f4:	f8 01       	movw	r30, r16
    38f6:	31 83       	std	Z+1, r19	; 0x01
    38f8:	20 83       	st	Z, r18
    38fa:	6c c0       	rjmp	.+216    	; 0x39d4 <xSerialPortInitMinimal+0x428>
    38fc:	d5 01       	movw	r26, r10
    38fe:	c4 01       	movw	r24, r8
    3900:	97 5f       	subi	r25, 0xF7	; 247
    3902:	a2 4c       	sbci	r26, 0xC2	; 194
    3904:	bf 4f       	sbci	r27, 0xFF	; 255
    3906:	bc 01       	movw	r22, r24
    3908:	cd 01       	movw	r24, r26
    390a:	66 0f       	add	r22, r22
    390c:	77 1f       	adc	r23, r23
    390e:	88 1f       	adc	r24, r24
    3910:	99 1f       	adc	r25, r25
    3912:	66 0f       	add	r22, r22
    3914:	77 1f       	adc	r23, r23
    3916:	88 1f       	adc	r24, r24
    3918:	99 1f       	adc	r25, r25
    391a:	95 01       	movw	r18, r10
    391c:	84 01       	movw	r16, r8
    391e:	00 0f       	add	r16, r16
    3920:	11 1f       	adc	r17, r17
    3922:	22 1f       	adc	r18, r18
    3924:	33 1f       	adc	r19, r19
    3926:	00 0f       	add	r16, r16
    3928:	11 1f       	adc	r17, r17
    392a:	22 1f       	adc	r18, r18
    392c:	33 1f       	adc	r19, r19
    392e:	a9 01       	movw	r20, r18
    3930:	98 01       	movw	r18, r16
    3932:	22 0f       	add	r18, r18
    3934:	33 1f       	adc	r19, r19
    3936:	44 1f       	adc	r20, r20
    3938:	55 1f       	adc	r21, r21
    393a:	32 d3       	rcall	.+1636   	; 0x3fa0 <__udivmodsi4>
    393c:	21 50       	subi	r18, 0x01	; 1
    393e:	31 09       	sbc	r19, r1
    3940:	30 93 35 01 	sts	0x0135, r19	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    3944:	20 93 34 01 	sts	0x0134, r18	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    3948:	82 e0       	ldi	r24, 0x02	; 2
    394a:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    394e:	88 e9       	ldi	r24, 0x98	; 152
    3950:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    3954:	8e e0       	ldi	r24, 0x0E	; 14
    3956:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    395a:	3c c0       	rjmp	.+120    	; 0x39d4 <xSerialPortInitMinimal+0x428>
    395c:	04 e3       	ldi	r16, 0x34	; 52
    395e:	11 e0       	ldi	r17, 0x01	; 1
    3960:	f8 01       	movw	r30, r16
    3962:	11 82       	std	Z+1, r1	; 0x01
    3964:	10 82       	st	Z, r1
    3966:	e4 e0       	ldi	r30, 0x04	; 4
    3968:	f1 e0       	ldi	r31, 0x01	; 1
    396a:	80 81       	ld	r24, Z
    396c:	84 60       	ori	r24, 0x04	; 4
    396e:	80 83       	st	Z, r24
    3970:	80 ec       	ldi	r24, 0xC0	; 192
    3972:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    3976:	88 e9       	ldi	r24, 0x98	; 152
    3978:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    397c:	d5 01       	movw	r26, r10
    397e:	c4 01       	movw	r24, r8
    3980:	80 58       	subi	r24, 0x80	; 128
    3982:	9b 47       	sbci	r25, 0x7B	; 123
    3984:	a1 4e       	sbci	r26, 0xE1	; 225
    3986:	bf 4f       	sbci	r27, 0xFF	; 255
    3988:	88 0f       	add	r24, r24
    398a:	99 1f       	adc	r25, r25
    398c:	aa 1f       	adc	r26, r26
    398e:	bb 1f       	adc	r27, r27
    3990:	88 0f       	add	r24, r24
    3992:	99 1f       	adc	r25, r25
    3994:	aa 1f       	adc	r26, r26
    3996:	bb 1f       	adc	r27, r27
    3998:	bc 01       	movw	r22, r24
    399a:	cd 01       	movw	r24, r26
    399c:	66 0f       	add	r22, r22
    399e:	77 1f       	adc	r23, r23
    39a0:	88 1f       	adc	r24, r24
    39a2:	99 1f       	adc	r25, r25
    39a4:	88 0c       	add	r8, r8
    39a6:	99 1c       	adc	r9, r9
    39a8:	aa 1c       	adc	r10, r10
    39aa:	bb 1c       	adc	r11, r11
    39ac:	88 0c       	add	r8, r8
    39ae:	99 1c       	adc	r9, r9
    39b0:	aa 1c       	adc	r10, r10
    39b2:	bb 1c       	adc	r11, r11
    39b4:	a5 01       	movw	r20, r10
    39b6:	94 01       	movw	r18, r8
    39b8:	22 0f       	add	r18, r18
    39ba:	33 1f       	adc	r19, r19
    39bc:	44 1f       	adc	r20, r20
    39be:	55 1f       	adc	r21, r21
    39c0:	22 0f       	add	r18, r18
    39c2:	33 1f       	adc	r19, r19
    39c4:	44 1f       	adc	r20, r20
    39c6:	55 1f       	adc	r21, r21
    39c8:	eb d2       	rcall	.+1494   	; 0x3fa0 <__udivmodsi4>
    39ca:	21 50       	subi	r18, 0x01	; 1
    39cc:	31 09       	sbc	r19, r1
    39ce:	f8 01       	movw	r30, r16
    39d0:	31 83       	std	Z+1, r19	; 0x01
    39d2:	20 83       	st	Z, r18
    39d4:	0f 90       	pop	r0
    39d6:	0f be       	out	0x3f, r0	; 63
    39d8:	82 e2       	ldi	r24, 0x22	; 34
    39da:	fe 01       	movw	r30, r28
    39dc:	31 96       	adiw	r30, 0x01	; 1
    39de:	d6 01       	movw	r26, r12
    39e0:	01 90       	ld	r0, Z+
    39e2:	0d 92       	st	X+, r0
    39e4:	8a 95       	dec	r24
    39e6:	e1 f7       	brne	.-8      	; 0x39e0 <xSerialPortInitMinimal+0x434>
    39e8:	c6 01       	movw	r24, r12
    39ea:	a2 96       	adiw	r28, 0x22	; 34
    39ec:	0f b6       	in	r0, 0x3f	; 63
    39ee:	f8 94       	cli
    39f0:	de bf       	out	0x3e, r29	; 62
    39f2:	0f be       	out	0x3f, r0	; 63
    39f4:	cd bf       	out	0x3d, r28	; 61
    39f6:	df 91       	pop	r29
    39f8:	cf 91       	pop	r28
    39fa:	1f 91       	pop	r17
    39fc:	0f 91       	pop	r16
    39fe:	ff 90       	pop	r15
    3a00:	ef 90       	pop	r14
    3a02:	df 90       	pop	r13
    3a04:	cf 90       	pop	r12
    3a06:	bf 90       	pop	r11
    3a08:	af 90       	pop	r10
    3a0a:	9f 90       	pop	r9
    3a0c:	8f 90       	pop	r8
    3a0e:	7f 90       	pop	r7
    3a10:	08 95       	ret

00003a12 <__vector_25>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART0_RX_vect )

#endif
{
    3a12:	1f 92       	push	r1
    3a14:	0f 92       	push	r0
    3a16:	0f b6       	in	r0, 0x3f	; 63
    3a18:	0f 92       	push	r0
    3a1a:	11 24       	eor	r1, r1
    3a1c:	0b b6       	in	r0, 0x3b	; 59
    3a1e:	0f 92       	push	r0
    3a20:	2f 93       	push	r18
    3a22:	3f 93       	push	r19
    3a24:	4f 93       	push	r20
    3a26:	8f 93       	push	r24
    3a28:	9f 93       	push	r25
    3a2a:	af 93       	push	r26
    3a2c:	bf 93       	push	r27
    3a2e:	ef 93       	push	r30
    3a30:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR0A & (_BV(FE0)|_BV(DOR0)|_BV(UPE0)) ) )
    3a32:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    3a36:	8c 71       	andi	r24, 0x1C	; 28
    3a38:	71 f0       	breq	.+28     	; 0x3a56 <__vector_25+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR0A & (1<<RXC0) ) erroredByte = UDR0;
    3a3a:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    3a3e:	88 23       	and	r24, r24
    3a40:	0c f0       	brlt	.+2      	; 0x3a44 <__vector_25+0x32>
    3a42:	36 c0       	rjmp	.+108    	; 0x3ab0 <__vector_25+0x9e>
    3a44:	a6 ec       	ldi	r26, 0xC6	; 198
    3a46:	b0 e0       	ldi	r27, 0x00	; 0
    3a48:	e0 ec       	ldi	r30, 0xC0	; 192
    3a4a:	f0 e0       	ldi	r31, 0x00	; 0
    3a4c:	8c 91       	ld	r24, X
    3a4e:	80 81       	ld	r24, Z
    3a50:	88 23       	and	r24, r24
    3a52:	e4 f3       	brlt	.-8      	; 0x3a4c <__vector_25+0x3a>
    3a54:	2d c0       	rjmp	.+90     	; 0x3ab0 <__vector_25+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR0;
    3a56:	40 91 c6 00 	lds	r20, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3a5a:	0f b6       	in	r0, 0x3f	; 63
    3a5c:	f8 94       	cli
    3a5e:	0f 92       	push	r0
	{
	    count = buffer->count;
    3a60:	ef ef       	ldi	r30, 0xFF	; 255
    3a62:	f5 e1       	ldi	r31, 0x15	; 21
    3a64:	21 81       	ldd	r18, Z+1	; 0x01
    3a66:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    3a68:	0f 90       	pop	r0
    3a6a:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerialPort.xRxedChars) ) )
    3a6c:	83 85       	ldd	r24, Z+11	; 0x0b
    3a6e:	94 85       	ldd	r25, Z+12	; 0x0c
    3a70:	28 17       	cp	r18, r24
    3a72:	39 07       	cpc	r19, r25
    3a74:	e9 f0       	breq	.+58     	; 0x3ab0 <__vector_25+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3a76:	e0 e0       	ldi	r30, 0x00	; 0
    3a78:	f6 e1       	ldi	r31, 0x16	; 22

	*buffer->in = data;
    3a7a:	a2 81       	ldd	r26, Z+2	; 0x02
    3a7c:	b3 81       	ldd	r27, Z+3	; 0x03
    3a7e:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    3a80:	82 81       	ldd	r24, Z+2	; 0x02
    3a82:	93 81       	ldd	r25, Z+3	; 0x03
    3a84:	01 96       	adiw	r24, 0x01	; 1
    3a86:	93 83       	std	Z+3, r25	; 0x03
    3a88:	82 83       	std	Z+2, r24	; 0x02
    3a8a:	20 85       	ldd	r18, Z+8	; 0x08
    3a8c:	31 85       	ldd	r19, Z+9	; 0x09
    3a8e:	82 17       	cp	r24, r18
    3a90:	93 07       	cpc	r25, r19
    3a92:	21 f4       	brne	.+8      	; 0x3a9c <__vector_25+0x8a>
	  buffer->in = buffer->start;
    3a94:	86 81       	ldd	r24, Z+6	; 0x06
    3a96:	97 81       	ldd	r25, Z+7	; 0x07
    3a98:	93 83       	std	Z+3, r25	; 0x03
    3a9a:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    3a9c:	0f b6       	in	r0, 0x3f	; 63
    3a9e:	f8 94       	cli
    3aa0:	0f 92       	push	r0
	{
	    buffer->count++;
    3aa2:	80 81       	ld	r24, Z
    3aa4:	91 81       	ldd	r25, Z+1	; 0x01
    3aa6:	01 96       	adiw	r24, 0x01	; 1
    3aa8:	91 83       	std	Z+1, r25	; 0x01
    3aaa:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3aac:	0f 90       	pop	r0
    3aae:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerialPort.xRxedChars), cChar);
	}
}
    3ab0:	ff 91       	pop	r31
    3ab2:	ef 91       	pop	r30
    3ab4:	bf 91       	pop	r27
    3ab6:	af 91       	pop	r26
    3ab8:	9f 91       	pop	r25
    3aba:	8f 91       	pop	r24
    3abc:	4f 91       	pop	r20
    3abe:	3f 91       	pop	r19
    3ac0:	2f 91       	pop	r18
    3ac2:	0f 90       	pop	r0
    3ac4:	0b be       	out	0x3b, r0	; 59
    3ac6:	0f 90       	pop	r0
    3ac8:	0f be       	out	0x3f, r0	; 63
    3aca:	0f 90       	pop	r0
    3acc:	1f 90       	pop	r1
    3ace:	18 95       	reti

00003ad0 <__vector_26>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
    3ad0:	1f 92       	push	r1
    3ad2:	0f 92       	push	r0
    3ad4:	0f b6       	in	r0, 0x3f	; 63
    3ad6:	0f 92       	push	r0
    3ad8:	11 24       	eor	r1, r1
    3ada:	0b b6       	in	r0, 0x3b	; 59
    3adc:	0f 92       	push	r0
    3ade:	2f 93       	push	r18
    3ae0:	8f 93       	push	r24
    3ae2:	9f 93       	push	r25
    3ae4:	af 93       	push	r26
    3ae6:	bf 93       	push	r27
    3ae8:	ef 93       	push	r30
    3aea:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3aec:	0f b6       	in	r0, 0x3f	; 63
    3aee:	f8 94       	cli
    3af0:	0f 92       	push	r0
	{
	    count = buffer->count;
    3af2:	80 91 0c 16 	lds	r24, 0x160C	; 0x80160c <xSerialPort+0xd>
    3af6:	90 91 0d 16 	lds	r25, 0x160D	; 0x80160d <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
    3afa:	0f 90       	pop	r0
    3afc:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
    3afe:	89 2b       	or	r24, r25
    3b00:	31 f4       	brne	.+12     	; 0x3b0e <__vector_26+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
    3b02:	e1 ec       	ldi	r30, 0xC1	; 193
    3b04:	f0 e0       	ldi	r31, 0x00	; 0
    3b06:	80 81       	ld	r24, Z
    3b08:	8f 7d       	andi	r24, 0xDF	; 223
    3b0a:	80 83       	st	Z, r24
    3b0c:	1c c0       	rjmp	.+56     	; 0x3b46 <__vector_26+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3b0e:	ec e0       	ldi	r30, 0x0C	; 12
    3b10:	f6 e1       	ldi	r31, 0x16	; 22

	uint8_t data = *buffer->out;
    3b12:	a4 81       	ldd	r26, Z+4	; 0x04
    3b14:	b5 81       	ldd	r27, Z+5	; 0x05
    3b16:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    3b18:	b5 83       	std	Z+5, r27	; 0x05
    3b1a:	a4 83       	std	Z+4, r26	; 0x04
    3b1c:	80 85       	ldd	r24, Z+8	; 0x08
    3b1e:	91 85       	ldd	r25, Z+9	; 0x09
    3b20:	a8 17       	cp	r26, r24
    3b22:	b9 07       	cpc	r27, r25
    3b24:	21 f4       	brne	.+8      	; 0x3b2e <__vector_26+0x5e>
	  buffer->out = buffer->start;
    3b26:	86 81       	ldd	r24, Z+6	; 0x06
    3b28:	97 81       	ldd	r25, Z+7	; 0x07
    3b2a:	95 83       	std	Z+5, r25	; 0x05
    3b2c:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    3b2e:	0f b6       	in	r0, 0x3f	; 63
    3b30:	f8 94       	cli
    3b32:	0f 92       	push	r0
	{
	    buffer->count--;
    3b34:	80 81       	ld	r24, Z
    3b36:	91 81       	ldd	r25, Z+1	; 0x01
    3b38:	01 97       	sbiw	r24, 0x01	; 1
    3b3a:	91 83       	std	Z+1, r25	; 0x01
    3b3c:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3b3e:	0f 90       	pop	r0
    3b40:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
    3b42:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	}
}
    3b46:	ff 91       	pop	r31
    3b48:	ef 91       	pop	r30
    3b4a:	bf 91       	pop	r27
    3b4c:	af 91       	pop	r26
    3b4e:	9f 91       	pop	r25
    3b50:	8f 91       	pop	r24
    3b52:	2f 91       	pop	r18
    3b54:	0f 90       	pop	r0
    3b56:	0b be       	out	0x3b, r0	; 59
    3b58:	0f 90       	pop	r0
    3b5a:	0f be       	out	0x3f, r0	; 63
    3b5c:	0f 90       	pop	r0
    3b5e:	1f 90       	pop	r1
    3b60:	18 95       	reti

00003b62 <__vector_36>:

#if defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART1_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART1_RX_vect )
{
    3b62:	1f 92       	push	r1
    3b64:	0f 92       	push	r0
    3b66:	0f b6       	in	r0, 0x3f	; 63
    3b68:	0f 92       	push	r0
    3b6a:	11 24       	eor	r1, r1
    3b6c:	0b b6       	in	r0, 0x3b	; 59
    3b6e:	0f 92       	push	r0
    3b70:	2f 93       	push	r18
    3b72:	3f 93       	push	r19
    3b74:	4f 93       	push	r20
    3b76:	8f 93       	push	r24
    3b78:	9f 93       	push	r25
    3b7a:	af 93       	push	r26
    3b7c:	bf 93       	push	r27
    3b7e:	ef 93       	push	r30
    3b80:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR1A &  (_BV(FE1)|_BV(DOR1)|_BV(UPE1)) ) )
    3b82:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    3b86:	8c 71       	andi	r24, 0x1C	; 28
    3b88:	71 f0       	breq	.+28     	; 0x3ba6 <__vector_36+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR1A & (1<<RXC1) ) erroredByte = UDR1;
    3b8a:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    3b8e:	88 23       	and	r24, r24
    3b90:	0c f0       	brlt	.+2      	; 0x3b94 <__vector_36+0x32>
    3b92:	36 c0       	rjmp	.+108    	; 0x3c00 <__vector_36+0x9e>
    3b94:	ae ec       	ldi	r26, 0xCE	; 206
    3b96:	b0 e0       	ldi	r27, 0x00	; 0
    3b98:	e8 ec       	ldi	r30, 0xC8	; 200
    3b9a:	f0 e0       	ldi	r31, 0x00	; 0
    3b9c:	8c 91       	ld	r24, X
    3b9e:	80 81       	ld	r24, Z
    3ba0:	88 23       	and	r24, r24
    3ba2:	e4 f3       	brlt	.-8      	; 0x3b9c <__vector_36+0x3a>
    3ba4:	2d c0       	rjmp	.+90     	; 0x3c00 <__vector_36+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR1;
    3ba6:	40 91 ce 00 	lds	r20, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3baa:	0f b6       	in	r0, 0x3f	; 63
    3bac:	f8 94       	cli
    3bae:	0f 92       	push	r0
	{
	    count = buffer->count;
    3bb0:	e9 ea       	ldi	r30, 0xA9	; 169
    3bb2:	f6 e1       	ldi	r31, 0x16	; 22
    3bb4:	21 81       	ldd	r18, Z+1	; 0x01
    3bb6:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    3bb8:	0f 90       	pop	r0
    3bba:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial1Port.xRxedChars) ) )
    3bbc:	83 85       	ldd	r24, Z+11	; 0x0b
    3bbe:	94 85       	ldd	r25, Z+12	; 0x0c
    3bc0:	28 17       	cp	r18, r24
    3bc2:	39 07       	cpc	r19, r25
    3bc4:	e9 f0       	breq	.+58     	; 0x3c00 <__vector_36+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3bc6:	ea ea       	ldi	r30, 0xAA	; 170
    3bc8:	f6 e1       	ldi	r31, 0x16	; 22

	*buffer->in = data;
    3bca:	a2 81       	ldd	r26, Z+2	; 0x02
    3bcc:	b3 81       	ldd	r27, Z+3	; 0x03
    3bce:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    3bd0:	82 81       	ldd	r24, Z+2	; 0x02
    3bd2:	93 81       	ldd	r25, Z+3	; 0x03
    3bd4:	01 96       	adiw	r24, 0x01	; 1
    3bd6:	93 83       	std	Z+3, r25	; 0x03
    3bd8:	82 83       	std	Z+2, r24	; 0x02
    3bda:	20 85       	ldd	r18, Z+8	; 0x08
    3bdc:	31 85       	ldd	r19, Z+9	; 0x09
    3bde:	82 17       	cp	r24, r18
    3be0:	93 07       	cpc	r25, r19
    3be2:	21 f4       	brne	.+8      	; 0x3bec <__vector_36+0x8a>
	  buffer->in = buffer->start;
    3be4:	86 81       	ldd	r24, Z+6	; 0x06
    3be6:	97 81       	ldd	r25, Z+7	; 0x07
    3be8:	93 83       	std	Z+3, r25	; 0x03
    3bea:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    3bec:	0f b6       	in	r0, 0x3f	; 63
    3bee:	f8 94       	cli
    3bf0:	0f 92       	push	r0
	{
	    buffer->count++;
    3bf2:	80 81       	ld	r24, Z
    3bf4:	91 81       	ldd	r25, Z+1	; 0x01
    3bf6:	01 96       	adiw	r24, 0x01	; 1
    3bf8:	91 83       	std	Z+1, r25	; 0x01
    3bfa:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3bfc:	0f 90       	pop	r0
    3bfe:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial1Port.xRxedChars), cChar);
	}
}
    3c00:	ff 91       	pop	r31
    3c02:	ef 91       	pop	r30
    3c04:	bf 91       	pop	r27
    3c06:	af 91       	pop	r26
    3c08:	9f 91       	pop	r25
    3c0a:	8f 91       	pop	r24
    3c0c:	4f 91       	pop	r20
    3c0e:	3f 91       	pop	r19
    3c10:	2f 91       	pop	r18
    3c12:	0f 90       	pop	r0
    3c14:	0b be       	out	0x3b, r0	; 59
    3c16:	0f 90       	pop	r0
    3c18:	0f be       	out	0x3f, r0	; 63
    3c1a:	0f 90       	pop	r0
    3c1c:	1f 90       	pop	r1
    3c1e:	18 95       	reti

00003c20 <__vector_37>:
/*-----------------------------------------------------------*/

ISR( USART1_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART1_UDRE_vect )
{
    3c20:	1f 92       	push	r1
    3c22:	0f 92       	push	r0
    3c24:	0f b6       	in	r0, 0x3f	; 63
    3c26:	0f 92       	push	r0
    3c28:	11 24       	eor	r1, r1
    3c2a:	0b b6       	in	r0, 0x3b	; 59
    3c2c:	0f 92       	push	r0
    3c2e:	2f 93       	push	r18
    3c30:	8f 93       	push	r24
    3c32:	9f 93       	push	r25
    3c34:	af 93       	push	r26
    3c36:	bf 93       	push	r27
    3c38:	ef 93       	push	r30
    3c3a:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3c3c:	0f b6       	in	r0, 0x3f	; 63
    3c3e:	f8 94       	cli
    3c40:	0f 92       	push	r0
	{
	    count = buffer->count;
    3c42:	80 91 b6 16 	lds	r24, 0x16B6	; 0x8016b6 <xSerial1Port+0xd>
    3c46:	90 91 b7 16 	lds	r25, 0x16B7	; 0x8016b7 <xSerial1Port+0xe>
	}
	portEXIT_CRITICAL();
    3c4a:	0f 90       	pop	r0
    3c4c:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) ) )
    3c4e:	89 2b       	or	r24, r25
    3c50:	31 f4       	brne	.+12     	; 0x3c5e <__vector_37+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt1_Off();
    3c52:	e9 ec       	ldi	r30, 0xC9	; 201
    3c54:	f0 e0       	ldi	r31, 0x00	; 0
    3c56:	80 81       	ld	r24, Z
    3c58:	8f 7d       	andi	r24, 0xDF	; 223
    3c5a:	80 83       	st	Z, r24
    3c5c:	1c c0       	rjmp	.+56     	; 0x3c96 <__vector_37+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3c5e:	e6 eb       	ldi	r30, 0xB6	; 182
    3c60:	f6 e1       	ldi	r31, 0x16	; 22

	uint8_t data = *buffer->out;
    3c62:	a4 81       	ldd	r26, Z+4	; 0x04
    3c64:	b5 81       	ldd	r27, Z+5	; 0x05
    3c66:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    3c68:	b5 83       	std	Z+5, r27	; 0x05
    3c6a:	a4 83       	std	Z+4, r26	; 0x04
    3c6c:	80 85       	ldd	r24, Z+8	; 0x08
    3c6e:	91 85       	ldd	r25, Z+9	; 0x09
    3c70:	a8 17       	cp	r26, r24
    3c72:	b9 07       	cpc	r27, r25
    3c74:	21 f4       	brne	.+8      	; 0x3c7e <__vector_37+0x5e>
	  buffer->out = buffer->start;
    3c76:	86 81       	ldd	r24, Z+6	; 0x06
    3c78:	97 81       	ldd	r25, Z+7	; 0x07
    3c7a:	95 83       	std	Z+5, r25	; 0x05
    3c7c:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    3c7e:	0f b6       	in	r0, 0x3f	; 63
    3c80:	f8 94       	cli
    3c82:	0f 92       	push	r0
	{
	    buffer->count--;
    3c84:	80 81       	ld	r24, Z
    3c86:	91 81       	ldd	r25, Z+1	; 0x01
    3c88:	01 97       	sbiw	r24, 0x01	; 1
    3c8a:	91 83       	std	Z+1, r25	; 0x01
    3c8c:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3c8e:	0f 90       	pop	r0
    3c90:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR1 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) );
    3c92:	20 93 ce 00 	sts	0x00CE, r18	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
	}
}
    3c96:	ff 91       	pop	r31
    3c98:	ef 91       	pop	r30
    3c9a:	bf 91       	pop	r27
    3c9c:	af 91       	pop	r26
    3c9e:	9f 91       	pop	r25
    3ca0:	8f 91       	pop	r24
    3ca2:	2f 91       	pop	r18
    3ca4:	0f 90       	pop	r0
    3ca6:	0b be       	out	0x3b, r0	; 59
    3ca8:	0f 90       	pop	r0
    3caa:	0f be       	out	0x3f, r0	; 63
    3cac:	0f 90       	pop	r0
    3cae:	1f 90       	pop	r1
    3cb0:	18 95       	reti

00003cb2 <__vector_51>:

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART2_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART2_RX_vect )
{
    3cb2:	1f 92       	push	r1
    3cb4:	0f 92       	push	r0
    3cb6:	0f b6       	in	r0, 0x3f	; 63
    3cb8:	0f 92       	push	r0
    3cba:	11 24       	eor	r1, r1
    3cbc:	0b b6       	in	r0, 0x3b	; 59
    3cbe:	0f 92       	push	r0
    3cc0:	2f 93       	push	r18
    3cc2:	3f 93       	push	r19
    3cc4:	4f 93       	push	r20
    3cc6:	8f 93       	push	r24
    3cc8:	9f 93       	push	r25
    3cca:	af 93       	push	r26
    3ccc:	bf 93       	push	r27
    3cce:	ef 93       	push	r30
    3cd0:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR2A & (_BV(FE2)|_BV(DOR2)|_BV(UPE2)) ) )
    3cd2:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    3cd6:	8c 71       	andi	r24, 0x1C	; 28
    3cd8:	71 f0       	breq	.+28     	; 0x3cf6 <__vector_51+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR2A & (1<<RXC2) ) erroredByte = UDR2;
    3cda:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    3cde:	88 23       	and	r24, r24
    3ce0:	0c f0       	brlt	.+2      	; 0x3ce4 <__vector_51+0x32>
    3ce2:	36 c0       	rjmp	.+108    	; 0x3d50 <__vector_51+0x9e>
    3ce4:	a6 ed       	ldi	r26, 0xD6	; 214
    3ce6:	b0 e0       	ldi	r27, 0x00	; 0
    3ce8:	e0 ed       	ldi	r30, 0xD0	; 208
    3cea:	f0 e0       	ldi	r31, 0x00	; 0
    3cec:	8c 91       	ld	r24, X
    3cee:	80 81       	ld	r24, Z
    3cf0:	88 23       	and	r24, r24
    3cf2:	e4 f3       	brlt	.-8      	; 0x3cec <__vector_51+0x3a>
    3cf4:	2d c0       	rjmp	.+90     	; 0x3d50 <__vector_51+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR2;
    3cf6:	40 91 d6 00 	lds	r20, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3cfa:	0f b6       	in	r0, 0x3f	; 63
    3cfc:	f8 94       	cli
    3cfe:	0f 92       	push	r0
	{
	    count = buffer->count;
    3d00:	e5 e6       	ldi	r30, 0x65	; 101
    3d02:	f6 e1       	ldi	r31, 0x16	; 22
    3d04:	21 81       	ldd	r18, Z+1	; 0x01
    3d06:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    3d08:	0f 90       	pop	r0
    3d0a:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial2Port.xRxedChars) ) )
    3d0c:	83 85       	ldd	r24, Z+11	; 0x0b
    3d0e:	94 85       	ldd	r25, Z+12	; 0x0c
    3d10:	28 17       	cp	r18, r24
    3d12:	39 07       	cpc	r19, r25
    3d14:	e9 f0       	breq	.+58     	; 0x3d50 <__vector_51+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3d16:	e6 e6       	ldi	r30, 0x66	; 102
    3d18:	f6 e1       	ldi	r31, 0x16	; 22

	*buffer->in = data;
    3d1a:	a2 81       	ldd	r26, Z+2	; 0x02
    3d1c:	b3 81       	ldd	r27, Z+3	; 0x03
    3d1e:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    3d20:	82 81       	ldd	r24, Z+2	; 0x02
    3d22:	93 81       	ldd	r25, Z+3	; 0x03
    3d24:	01 96       	adiw	r24, 0x01	; 1
    3d26:	93 83       	std	Z+3, r25	; 0x03
    3d28:	82 83       	std	Z+2, r24	; 0x02
    3d2a:	20 85       	ldd	r18, Z+8	; 0x08
    3d2c:	31 85       	ldd	r19, Z+9	; 0x09
    3d2e:	82 17       	cp	r24, r18
    3d30:	93 07       	cpc	r25, r19
    3d32:	21 f4       	brne	.+8      	; 0x3d3c <__vector_51+0x8a>
	  buffer->in = buffer->start;
    3d34:	86 81       	ldd	r24, Z+6	; 0x06
    3d36:	97 81       	ldd	r25, Z+7	; 0x07
    3d38:	93 83       	std	Z+3, r25	; 0x03
    3d3a:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    3d3c:	0f b6       	in	r0, 0x3f	; 63
    3d3e:	f8 94       	cli
    3d40:	0f 92       	push	r0
	{
	    buffer->count++;
    3d42:	80 81       	ld	r24, Z
    3d44:	91 81       	ldd	r25, Z+1	; 0x01
    3d46:	01 96       	adiw	r24, 0x01	; 1
    3d48:	91 83       	std	Z+1, r25	; 0x01
    3d4a:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3d4c:	0f 90       	pop	r0
    3d4e:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial2Port.xRxedChars), cChar);
	}
}
    3d50:	ff 91       	pop	r31
    3d52:	ef 91       	pop	r30
    3d54:	bf 91       	pop	r27
    3d56:	af 91       	pop	r26
    3d58:	9f 91       	pop	r25
    3d5a:	8f 91       	pop	r24
    3d5c:	4f 91       	pop	r20
    3d5e:	3f 91       	pop	r19
    3d60:	2f 91       	pop	r18
    3d62:	0f 90       	pop	r0
    3d64:	0b be       	out	0x3b, r0	; 59
    3d66:	0f 90       	pop	r0
    3d68:	0f be       	out	0x3f, r0	; 63
    3d6a:	0f 90       	pop	r0
    3d6c:	1f 90       	pop	r1
    3d6e:	18 95       	reti

00003d70 <__vector_52>:
/*-----------------------------------------------------------*/

ISR( USART2_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART2_UDRE_vect )
{
    3d70:	1f 92       	push	r1
    3d72:	0f 92       	push	r0
    3d74:	0f b6       	in	r0, 0x3f	; 63
    3d76:	0f 92       	push	r0
    3d78:	11 24       	eor	r1, r1
    3d7a:	0b b6       	in	r0, 0x3b	; 59
    3d7c:	0f 92       	push	r0
    3d7e:	2f 93       	push	r18
    3d80:	8f 93       	push	r24
    3d82:	9f 93       	push	r25
    3d84:	af 93       	push	r26
    3d86:	bf 93       	push	r27
    3d88:	ef 93       	push	r30
    3d8a:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3d8c:	0f b6       	in	r0, 0x3f	; 63
    3d8e:	f8 94       	cli
    3d90:	0f 92       	push	r0
	{
	    count = buffer->count;
    3d92:	80 91 72 16 	lds	r24, 0x1672	; 0x801672 <xSerial2Port+0xd>
    3d96:	90 91 73 16 	lds	r25, 0x1673	; 0x801673 <xSerial2Port+0xe>
	}
	portEXIT_CRITICAL();
    3d9a:	0f 90       	pop	r0
    3d9c:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) ) )
    3d9e:	89 2b       	or	r24, r25
    3da0:	31 f4       	brne	.+12     	; 0x3dae <__vector_52+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt2_Off();
    3da2:	e1 ed       	ldi	r30, 0xD1	; 209
    3da4:	f0 e0       	ldi	r31, 0x00	; 0
    3da6:	80 81       	ld	r24, Z
    3da8:	8f 7d       	andi	r24, 0xDF	; 223
    3daa:	80 83       	st	Z, r24
    3dac:	1c c0       	rjmp	.+56     	; 0x3de6 <__vector_52+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3dae:	e2 e7       	ldi	r30, 0x72	; 114
    3db0:	f6 e1       	ldi	r31, 0x16	; 22

	uint8_t data = *buffer->out;
    3db2:	a4 81       	ldd	r26, Z+4	; 0x04
    3db4:	b5 81       	ldd	r27, Z+5	; 0x05
    3db6:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    3db8:	b5 83       	std	Z+5, r27	; 0x05
    3dba:	a4 83       	std	Z+4, r26	; 0x04
    3dbc:	80 85       	ldd	r24, Z+8	; 0x08
    3dbe:	91 85       	ldd	r25, Z+9	; 0x09
    3dc0:	a8 17       	cp	r26, r24
    3dc2:	b9 07       	cpc	r27, r25
    3dc4:	21 f4       	brne	.+8      	; 0x3dce <__vector_52+0x5e>
	  buffer->out = buffer->start;
    3dc6:	86 81       	ldd	r24, Z+6	; 0x06
    3dc8:	97 81       	ldd	r25, Z+7	; 0x07
    3dca:	95 83       	std	Z+5, r25	; 0x05
    3dcc:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    3dce:	0f b6       	in	r0, 0x3f	; 63
    3dd0:	f8 94       	cli
    3dd2:	0f 92       	push	r0
	{
	    buffer->count--;
    3dd4:	80 81       	ld	r24, Z
    3dd6:	91 81       	ldd	r25, Z+1	; 0x01
    3dd8:	01 97       	sbiw	r24, 0x01	; 1
    3dda:	91 83       	std	Z+1, r25	; 0x01
    3ddc:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3dde:	0f 90       	pop	r0
    3de0:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR2 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) );
    3de2:	20 93 d6 00 	sts	0x00D6, r18	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
	}
}
    3de6:	ff 91       	pop	r31
    3de8:	ef 91       	pop	r30
    3dea:	bf 91       	pop	r27
    3dec:	af 91       	pop	r26
    3dee:	9f 91       	pop	r25
    3df0:	8f 91       	pop	r24
    3df2:	2f 91       	pop	r18
    3df4:	0f 90       	pop	r0
    3df6:	0b be       	out	0x3b, r0	; 59
    3df8:	0f 90       	pop	r0
    3dfa:	0f be       	out	0x3f, r0	; 63
    3dfc:	0f 90       	pop	r0
    3dfe:	1f 90       	pop	r1
    3e00:	18 95       	reti

00003e02 <__vector_54>:
/*-----------------------------------------------------------*/

ISR( USART3_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART3_RX_vect )
{
    3e02:	1f 92       	push	r1
    3e04:	0f 92       	push	r0
    3e06:	0f b6       	in	r0, 0x3f	; 63
    3e08:	0f 92       	push	r0
    3e0a:	11 24       	eor	r1, r1
    3e0c:	0b b6       	in	r0, 0x3b	; 59
    3e0e:	0f 92       	push	r0
    3e10:	2f 93       	push	r18
    3e12:	3f 93       	push	r19
    3e14:	4f 93       	push	r20
    3e16:	8f 93       	push	r24
    3e18:	9f 93       	push	r25
    3e1a:	af 93       	push	r26
    3e1c:	bf 93       	push	r27
    3e1e:	ef 93       	push	r30
    3e20:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR3A & (_BV(FE3)|_BV(DOR3)|_BV(UPE3)) ) )
    3e22:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    3e26:	8c 71       	andi	r24, 0x1C	; 28
    3e28:	71 f0       	breq	.+28     	; 0x3e46 <__vector_54+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR3A & (1<<RXC3) ) erroredByte = UDR3;
    3e2a:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    3e2e:	88 23       	and	r24, r24
    3e30:	0c f0       	brlt	.+2      	; 0x3e34 <__vector_54+0x32>
    3e32:	36 c0       	rjmp	.+108    	; 0x3ea0 <__vector_54+0x9e>
    3e34:	a6 e3       	ldi	r26, 0x36	; 54
    3e36:	b1 e0       	ldi	r27, 0x01	; 1
    3e38:	e0 e3       	ldi	r30, 0x30	; 48
    3e3a:	f1 e0       	ldi	r31, 0x01	; 1
    3e3c:	8c 91       	ld	r24, X
    3e3e:	80 81       	ld	r24, Z
    3e40:	88 23       	and	r24, r24
    3e42:	e4 f3       	brlt	.-8      	; 0x3e3c <__vector_54+0x3a>
    3e44:	2d c0       	rjmp	.+90     	; 0x3ea0 <__vector_54+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR3;
    3e46:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3e4a:	0f b6       	in	r0, 0x3f	; 63
    3e4c:	f8 94       	cli
    3e4e:	0f 92       	push	r0
	{
	    count = buffer->count;
    3e50:	e7 e8       	ldi	r30, 0x87	; 135
    3e52:	f6 e1       	ldi	r31, 0x16	; 22
    3e54:	21 81       	ldd	r18, Z+1	; 0x01
    3e56:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    3e58:	0f 90       	pop	r0
    3e5a:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial3Port.xRxedChars) ) )
    3e5c:	83 85       	ldd	r24, Z+11	; 0x0b
    3e5e:	94 85       	ldd	r25, Z+12	; 0x0c
    3e60:	28 17       	cp	r18, r24
    3e62:	39 07       	cpc	r19, r25
    3e64:	e9 f0       	breq	.+58     	; 0x3ea0 <__vector_54+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3e66:	e8 e8       	ldi	r30, 0x88	; 136
    3e68:	f6 e1       	ldi	r31, 0x16	; 22

	*buffer->in = data;
    3e6a:	a2 81       	ldd	r26, Z+2	; 0x02
    3e6c:	b3 81       	ldd	r27, Z+3	; 0x03
    3e6e:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    3e70:	82 81       	ldd	r24, Z+2	; 0x02
    3e72:	93 81       	ldd	r25, Z+3	; 0x03
    3e74:	01 96       	adiw	r24, 0x01	; 1
    3e76:	93 83       	std	Z+3, r25	; 0x03
    3e78:	82 83       	std	Z+2, r24	; 0x02
    3e7a:	20 85       	ldd	r18, Z+8	; 0x08
    3e7c:	31 85       	ldd	r19, Z+9	; 0x09
    3e7e:	82 17       	cp	r24, r18
    3e80:	93 07       	cpc	r25, r19
    3e82:	21 f4       	brne	.+8      	; 0x3e8c <__vector_54+0x8a>
	  buffer->in = buffer->start;
    3e84:	86 81       	ldd	r24, Z+6	; 0x06
    3e86:	97 81       	ldd	r25, Z+7	; 0x07
    3e88:	93 83       	std	Z+3, r25	; 0x03
    3e8a:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    3e8c:	0f b6       	in	r0, 0x3f	; 63
    3e8e:	f8 94       	cli
    3e90:	0f 92       	push	r0
	{
	    buffer->count++;
    3e92:	80 81       	ld	r24, Z
    3e94:	91 81       	ldd	r25, Z+1	; 0x01
    3e96:	01 96       	adiw	r24, 0x01	; 1
    3e98:	91 83       	std	Z+1, r25	; 0x01
    3e9a:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3e9c:	0f 90       	pop	r0
    3e9e:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial3Port.xRxedChars), cChar);
	}
}
    3ea0:	ff 91       	pop	r31
    3ea2:	ef 91       	pop	r30
    3ea4:	bf 91       	pop	r27
    3ea6:	af 91       	pop	r26
    3ea8:	9f 91       	pop	r25
    3eaa:	8f 91       	pop	r24
    3eac:	4f 91       	pop	r20
    3eae:	3f 91       	pop	r19
    3eb0:	2f 91       	pop	r18
    3eb2:	0f 90       	pop	r0
    3eb4:	0b be       	out	0x3b, r0	; 59
    3eb6:	0f 90       	pop	r0
    3eb8:	0f be       	out	0x3f, r0	; 63
    3eba:	0f 90       	pop	r0
    3ebc:	1f 90       	pop	r1
    3ebe:	18 95       	reti

00003ec0 <__vector_55>:
/*-----------------------------------------------------------*/

ISR( USART3_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART3_UDRE_vect )
{
    3ec0:	1f 92       	push	r1
    3ec2:	0f 92       	push	r0
    3ec4:	0f b6       	in	r0, 0x3f	; 63
    3ec6:	0f 92       	push	r0
    3ec8:	11 24       	eor	r1, r1
    3eca:	0b b6       	in	r0, 0x3b	; 59
    3ecc:	0f 92       	push	r0
    3ece:	2f 93       	push	r18
    3ed0:	8f 93       	push	r24
    3ed2:	9f 93       	push	r25
    3ed4:	af 93       	push	r26
    3ed6:	bf 93       	push	r27
    3ed8:	ef 93       	push	r30
    3eda:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3edc:	0f b6       	in	r0, 0x3f	; 63
    3ede:	f8 94       	cli
    3ee0:	0f 92       	push	r0
	{
	    count = buffer->count;
    3ee2:	80 91 94 16 	lds	r24, 0x1694	; 0x801694 <xSerial3Port+0xd>
    3ee6:	90 91 95 16 	lds	r25, 0x1695	; 0x801695 <xSerial3Port+0xe>
	}
	portEXIT_CRITICAL();
    3eea:	0f 90       	pop	r0
    3eec:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) ) )
    3eee:	89 2b       	or	r24, r25
    3ef0:	31 f4       	brne	.+12     	; 0x3efe <__vector_55+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt3_Off();
    3ef2:	e1 e3       	ldi	r30, 0x31	; 49
    3ef4:	f1 e0       	ldi	r31, 0x01	; 1
    3ef6:	80 81       	ld	r24, Z
    3ef8:	8f 7d       	andi	r24, 0xDF	; 223
    3efa:	80 83       	st	Z, r24
    3efc:	1c c0       	rjmp	.+56     	; 0x3f36 <__vector_55+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3efe:	e4 e9       	ldi	r30, 0x94	; 148
    3f00:	f6 e1       	ldi	r31, 0x16	; 22

	uint8_t data = *buffer->out;
    3f02:	a4 81       	ldd	r26, Z+4	; 0x04
    3f04:	b5 81       	ldd	r27, Z+5	; 0x05
    3f06:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    3f08:	b5 83       	std	Z+5, r27	; 0x05
    3f0a:	a4 83       	std	Z+4, r26	; 0x04
    3f0c:	80 85       	ldd	r24, Z+8	; 0x08
    3f0e:	91 85       	ldd	r25, Z+9	; 0x09
    3f10:	a8 17       	cp	r26, r24
    3f12:	b9 07       	cpc	r27, r25
    3f14:	21 f4       	brne	.+8      	; 0x3f1e <__vector_55+0x5e>
	  buffer->out = buffer->start;
    3f16:	86 81       	ldd	r24, Z+6	; 0x06
    3f18:	97 81       	ldd	r25, Z+7	; 0x07
    3f1a:	95 83       	std	Z+5, r25	; 0x05
    3f1c:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    3f1e:	0f b6       	in	r0, 0x3f	; 63
    3f20:	f8 94       	cli
    3f22:	0f 92       	push	r0
	{
	    buffer->count--;
    3f24:	80 81       	ld	r24, Z
    3f26:	91 81       	ldd	r25, Z+1	; 0x01
    3f28:	01 97       	sbiw	r24, 0x01	; 1
    3f2a:	91 83       	std	Z+1, r25	; 0x01
    3f2c:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3f2e:	0f 90       	pop	r0
    3f30:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR3 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) );
    3f32:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	}
}
    3f36:	ff 91       	pop	r31
    3f38:	ef 91       	pop	r30
    3f3a:	bf 91       	pop	r27
    3f3c:	af 91       	pop	r26
    3f3e:	9f 91       	pop	r25
    3f40:	8f 91       	pop	r24
    3f42:	2f 91       	pop	r18
    3f44:	0f 90       	pop	r0
    3f46:	0b be       	out	0x3b, r0	; 59
    3f48:	0f 90       	pop	r0
    3f4a:	0f be       	out	0x3f, r0	; 63
    3f4c:	0f 90       	pop	r0
    3f4e:	1f 90       	pop	r1
    3f50:	18 95       	reti

00003f52 <__udivmodhi4>:
    3f52:	aa 1b       	sub	r26, r26
    3f54:	bb 1b       	sub	r27, r27
    3f56:	51 e1       	ldi	r21, 0x11	; 17
    3f58:	07 c0       	rjmp	.+14     	; 0x3f68 <__udivmodhi4_ep>

00003f5a <__udivmodhi4_loop>:
    3f5a:	aa 1f       	adc	r26, r26
    3f5c:	bb 1f       	adc	r27, r27
    3f5e:	a6 17       	cp	r26, r22
    3f60:	b7 07       	cpc	r27, r23
    3f62:	10 f0       	brcs	.+4      	; 0x3f68 <__udivmodhi4_ep>
    3f64:	a6 1b       	sub	r26, r22
    3f66:	b7 0b       	sbc	r27, r23

00003f68 <__udivmodhi4_ep>:
    3f68:	88 1f       	adc	r24, r24
    3f6a:	99 1f       	adc	r25, r25
    3f6c:	5a 95       	dec	r21
    3f6e:	a9 f7       	brne	.-22     	; 0x3f5a <__udivmodhi4_loop>
    3f70:	80 95       	com	r24
    3f72:	90 95       	com	r25
    3f74:	bc 01       	movw	r22, r24
    3f76:	cd 01       	movw	r24, r26
    3f78:	08 95       	ret

00003f7a <__divmodhi4>:
    3f7a:	97 fb       	bst	r25, 7
    3f7c:	07 2e       	mov	r0, r23
    3f7e:	16 f4       	brtc	.+4      	; 0x3f84 <__divmodhi4+0xa>
    3f80:	00 94       	com	r0
    3f82:	06 d0       	rcall	.+12     	; 0x3f90 <__divmodhi4_neg1>
    3f84:	77 fd       	sbrc	r23, 7
    3f86:	08 d0       	rcall	.+16     	; 0x3f98 <__divmodhi4_neg2>
    3f88:	e4 df       	rcall	.-56     	; 0x3f52 <__udivmodhi4>
    3f8a:	07 fc       	sbrc	r0, 7
    3f8c:	05 d0       	rcall	.+10     	; 0x3f98 <__divmodhi4_neg2>
    3f8e:	3e f4       	brtc	.+14     	; 0x3f9e <__divmodhi4_exit>

00003f90 <__divmodhi4_neg1>:
    3f90:	90 95       	com	r25
    3f92:	81 95       	neg	r24
    3f94:	9f 4f       	sbci	r25, 0xFF	; 255
    3f96:	08 95       	ret

00003f98 <__divmodhi4_neg2>:
    3f98:	70 95       	com	r23
    3f9a:	61 95       	neg	r22
    3f9c:	7f 4f       	sbci	r23, 0xFF	; 255

00003f9e <__divmodhi4_exit>:
    3f9e:	08 95       	ret

00003fa0 <__udivmodsi4>:
    3fa0:	a1 e2       	ldi	r26, 0x21	; 33
    3fa2:	1a 2e       	mov	r1, r26
    3fa4:	aa 1b       	sub	r26, r26
    3fa6:	bb 1b       	sub	r27, r27
    3fa8:	fd 01       	movw	r30, r26
    3faa:	0d c0       	rjmp	.+26     	; 0x3fc6 <__udivmodsi4_ep>

00003fac <__udivmodsi4_loop>:
    3fac:	aa 1f       	adc	r26, r26
    3fae:	bb 1f       	adc	r27, r27
    3fb0:	ee 1f       	adc	r30, r30
    3fb2:	ff 1f       	adc	r31, r31
    3fb4:	a2 17       	cp	r26, r18
    3fb6:	b3 07       	cpc	r27, r19
    3fb8:	e4 07       	cpc	r30, r20
    3fba:	f5 07       	cpc	r31, r21
    3fbc:	20 f0       	brcs	.+8      	; 0x3fc6 <__udivmodsi4_ep>
    3fbe:	a2 1b       	sub	r26, r18
    3fc0:	b3 0b       	sbc	r27, r19
    3fc2:	e4 0b       	sbc	r30, r20
    3fc4:	f5 0b       	sbc	r31, r21

00003fc6 <__udivmodsi4_ep>:
    3fc6:	66 1f       	adc	r22, r22
    3fc8:	77 1f       	adc	r23, r23
    3fca:	88 1f       	adc	r24, r24
    3fcc:	99 1f       	adc	r25, r25
    3fce:	1a 94       	dec	r1
    3fd0:	69 f7       	brne	.-38     	; 0x3fac <__udivmodsi4_loop>
    3fd2:	60 95       	com	r22
    3fd4:	70 95       	com	r23
    3fd6:	80 95       	com	r24
    3fd8:	90 95       	com	r25
    3fda:	9b 01       	movw	r18, r22
    3fdc:	ac 01       	movw	r20, r24
    3fde:	bd 01       	movw	r22, r26
    3fe0:	cf 01       	movw	r24, r30
    3fe2:	08 95       	ret

00003fe4 <__divmodsi4>:
    3fe4:	05 2e       	mov	r0, r21
    3fe6:	97 fb       	bst	r25, 7
    3fe8:	16 f4       	brtc	.+4      	; 0x3fee <__divmodsi4+0xa>
    3fea:	00 94       	com	r0
    3fec:	0f d0       	rcall	.+30     	; 0x400c <__negsi2>
    3fee:	57 fd       	sbrc	r21, 7
    3ff0:	05 d0       	rcall	.+10     	; 0x3ffc <__divmodsi4_neg2>
    3ff2:	d6 df       	rcall	.-84     	; 0x3fa0 <__udivmodsi4>
    3ff4:	07 fc       	sbrc	r0, 7
    3ff6:	02 d0       	rcall	.+4      	; 0x3ffc <__divmodsi4_neg2>
    3ff8:	46 f4       	brtc	.+16     	; 0x400a <__divmodsi4_exit>
    3ffa:	08 c0       	rjmp	.+16     	; 0x400c <__negsi2>

00003ffc <__divmodsi4_neg2>:
    3ffc:	50 95       	com	r21
    3ffe:	40 95       	com	r20
    4000:	30 95       	com	r19
    4002:	21 95       	neg	r18
    4004:	3f 4f       	sbci	r19, 0xFF	; 255
    4006:	4f 4f       	sbci	r20, 0xFF	; 255
    4008:	5f 4f       	sbci	r21, 0xFF	; 255

0000400a <__divmodsi4_exit>:
    400a:	08 95       	ret

0000400c <__negsi2>:
    400c:	90 95       	com	r25
    400e:	80 95       	com	r24
    4010:	70 95       	com	r23
    4012:	61 95       	neg	r22
    4014:	7f 4f       	sbci	r23, 0xFF	; 255
    4016:	8f 4f       	sbci	r24, 0xFF	; 255
    4018:	9f 4f       	sbci	r25, 0xFF	; 255
    401a:	08 95       	ret

0000401c <__tablejump2__>:
    401c:	ee 0f       	add	r30, r30
    401e:	ff 1f       	adc	r31, r31
    4020:	88 1f       	adc	r24, r24
    4022:	8b bf       	out	0x3b, r24	; 59
    4024:	07 90       	elpm	r0, Z+
    4026:	f6 91       	elpm	r31, Z
    4028:	e0 2d       	mov	r30, r0
    402a:	19 94       	eijmp

0000402c <__umulhisi3>:
    402c:	a2 9f       	mul	r26, r18
    402e:	b0 01       	movw	r22, r0
    4030:	b3 9f       	mul	r27, r19
    4032:	c0 01       	movw	r24, r0
    4034:	a3 9f       	mul	r26, r19
    4036:	70 0d       	add	r23, r0
    4038:	81 1d       	adc	r24, r1
    403a:	11 24       	eor	r1, r1
    403c:	91 1d       	adc	r25, r1
    403e:	b2 9f       	mul	r27, r18
    4040:	70 0d       	add	r23, r0
    4042:	81 1d       	adc	r24, r1
    4044:	11 24       	eor	r1, r1
    4046:	91 1d       	adc	r25, r1
    4048:	08 95       	ret

0000404a <memcpy>:
    404a:	fb 01       	movw	r30, r22
    404c:	dc 01       	movw	r26, r24
    404e:	02 c0       	rjmp	.+4      	; 0x4054 <memcpy+0xa>
    4050:	01 90       	ld	r0, Z+
    4052:	0d 92       	st	X+, r0
    4054:	41 50       	subi	r20, 0x01	; 1
    4056:	50 40       	sbci	r21, 0x00	; 0
    4058:	d8 f7       	brcc	.-10     	; 0x4050 <memcpy+0x6>
    405a:	08 95       	ret

0000405c <memset>:
    405c:	dc 01       	movw	r26, r24
    405e:	01 c0       	rjmp	.+2      	; 0x4062 <memset+0x6>
    4060:	6d 93       	st	X+, r22
    4062:	41 50       	subi	r20, 0x01	; 1
    4064:	50 40       	sbci	r21, 0x00	; 0
    4066:	e0 f7       	brcc	.-8      	; 0x4060 <memset+0x4>
    4068:	08 95       	ret

0000406a <__itoa_ncheck>:
    406a:	bb 27       	eor	r27, r27
    406c:	4a 30       	cpi	r20, 0x0A	; 10
    406e:	31 f4       	brne	.+12     	; 0x407c <__itoa_ncheck+0x12>
    4070:	99 23       	and	r25, r25
    4072:	22 f4       	brpl	.+8      	; 0x407c <__itoa_ncheck+0x12>
    4074:	bd e2       	ldi	r27, 0x2D	; 45
    4076:	90 95       	com	r25
    4078:	81 95       	neg	r24
    407a:	9f 4f       	sbci	r25, 0xFF	; 255
    407c:	01 c0       	rjmp	.+2      	; 0x4080 <__utoa_common>

0000407e <__utoa_ncheck>:
    407e:	bb 27       	eor	r27, r27

00004080 <__utoa_common>:
    4080:	fb 01       	movw	r30, r22
    4082:	55 27       	eor	r21, r21
    4084:	aa 27       	eor	r26, r26
    4086:	88 0f       	add	r24, r24
    4088:	99 1f       	adc	r25, r25
    408a:	aa 1f       	adc	r26, r26
    408c:	a4 17       	cp	r26, r20
    408e:	10 f0       	brcs	.+4      	; 0x4094 <__utoa_common+0x14>
    4090:	a4 1b       	sub	r26, r20
    4092:	83 95       	inc	r24
    4094:	50 51       	subi	r21, 0x10	; 16
    4096:	b9 f7       	brne	.-18     	; 0x4086 <__utoa_common+0x6>
    4098:	a0 5d       	subi	r26, 0xD0	; 208
    409a:	aa 33       	cpi	r26, 0x3A	; 58
    409c:	08 f0       	brcs	.+2      	; 0x40a0 <__utoa_common+0x20>
    409e:	a9 5d       	subi	r26, 0xD9	; 217
    40a0:	a1 93       	st	Z+, r26
    40a2:	00 97       	sbiw	r24, 0x00	; 0
    40a4:	79 f7       	brne	.-34     	; 0x4084 <__utoa_common+0x4>
    40a6:	b1 11       	cpse	r27, r1
    40a8:	b1 93       	st	Z+, r27
    40aa:	11 92       	st	Z+, r1
    40ac:	cb 01       	movw	r24, r22
    40ae:	5e c2       	rjmp	.+1212   	; 0x456c <strrev>

000040b0 <printf>:
    40b0:	cf 93       	push	r28
    40b2:	df 93       	push	r29
    40b4:	cd b7       	in	r28, 0x3d	; 61
    40b6:	de b7       	in	r29, 0x3e	; 62
    40b8:	ae 01       	movw	r20, r28
    40ba:	4a 5f       	subi	r20, 0xFA	; 250
    40bc:	5f 4f       	sbci	r21, 0xFF	; 255
    40be:	fa 01       	movw	r30, r20
    40c0:	61 91       	ld	r22, Z+
    40c2:	71 91       	ld	r23, Z+
    40c4:	af 01       	movw	r20, r30
    40c6:	80 91 cd 16 	lds	r24, 0x16CD	; 0x8016cd <__iob+0x2>
    40ca:	90 91 ce 16 	lds	r25, 0x16CE	; 0x8016ce <__iob+0x3>
    40ce:	3b d0       	rcall	.+118    	; 0x4146 <vfprintf>
    40d0:	df 91       	pop	r29
    40d2:	cf 91       	pop	r28
    40d4:	08 95       	ret

000040d6 <vsnprintf>:
    40d6:	0f 93       	push	r16
    40d8:	1f 93       	push	r17
    40da:	cf 93       	push	r28
    40dc:	df 93       	push	r29
    40de:	cd b7       	in	r28, 0x3d	; 61
    40e0:	de b7       	in	r29, 0x3e	; 62
    40e2:	2e 97       	sbiw	r28, 0x0e	; 14
    40e4:	0f b6       	in	r0, 0x3f	; 63
    40e6:	f8 94       	cli
    40e8:	de bf       	out	0x3e, r29	; 62
    40ea:	0f be       	out	0x3f, r0	; 63
    40ec:	cd bf       	out	0x3d, r28	; 61
    40ee:	8c 01       	movw	r16, r24
    40f0:	fa 01       	movw	r30, r20
    40f2:	86 e0       	ldi	r24, 0x06	; 6
    40f4:	8c 83       	std	Y+4, r24	; 0x04
    40f6:	1a 83       	std	Y+2, r17	; 0x02
    40f8:	09 83       	std	Y+1, r16	; 0x01
    40fa:	77 ff       	sbrs	r23, 7
    40fc:	02 c0       	rjmp	.+4      	; 0x4102 <vsnprintf+0x2c>
    40fe:	60 e0       	ldi	r22, 0x00	; 0
    4100:	70 e8       	ldi	r23, 0x80	; 128
    4102:	cb 01       	movw	r24, r22
    4104:	01 97       	sbiw	r24, 0x01	; 1
    4106:	9e 83       	std	Y+6, r25	; 0x06
    4108:	8d 83       	std	Y+5, r24	; 0x05
    410a:	a9 01       	movw	r20, r18
    410c:	bf 01       	movw	r22, r30
    410e:	ce 01       	movw	r24, r28
    4110:	01 96       	adiw	r24, 0x01	; 1
    4112:	19 d0       	rcall	.+50     	; 0x4146 <vfprintf>
    4114:	4d 81       	ldd	r20, Y+5	; 0x05
    4116:	5e 81       	ldd	r21, Y+6	; 0x06
    4118:	57 fd       	sbrc	r21, 7
    411a:	0a c0       	rjmp	.+20     	; 0x4130 <vsnprintf+0x5a>
    411c:	2f 81       	ldd	r18, Y+7	; 0x07
    411e:	38 85       	ldd	r19, Y+8	; 0x08
    4120:	42 17       	cp	r20, r18
    4122:	53 07       	cpc	r21, r19
    4124:	0c f4       	brge	.+2      	; 0x4128 <vsnprintf+0x52>
    4126:	9a 01       	movw	r18, r20
    4128:	f8 01       	movw	r30, r16
    412a:	e2 0f       	add	r30, r18
    412c:	f3 1f       	adc	r31, r19
    412e:	10 82       	st	Z, r1
    4130:	2e 96       	adiw	r28, 0x0e	; 14
    4132:	0f b6       	in	r0, 0x3f	; 63
    4134:	f8 94       	cli
    4136:	de bf       	out	0x3e, r29	; 62
    4138:	0f be       	out	0x3f, r0	; 63
    413a:	cd bf       	out	0x3d, r28	; 61
    413c:	df 91       	pop	r29
    413e:	cf 91       	pop	r28
    4140:	1f 91       	pop	r17
    4142:	0f 91       	pop	r16
    4144:	08 95       	ret

00004146 <vfprintf>:
    4146:	2f 92       	push	r2
    4148:	3f 92       	push	r3
    414a:	4f 92       	push	r4
    414c:	5f 92       	push	r5
    414e:	6f 92       	push	r6
    4150:	7f 92       	push	r7
    4152:	8f 92       	push	r8
    4154:	9f 92       	push	r9
    4156:	af 92       	push	r10
    4158:	bf 92       	push	r11
    415a:	cf 92       	push	r12
    415c:	df 92       	push	r13
    415e:	ef 92       	push	r14
    4160:	ff 92       	push	r15
    4162:	0f 93       	push	r16
    4164:	1f 93       	push	r17
    4166:	cf 93       	push	r28
    4168:	df 93       	push	r29
    416a:	cd b7       	in	r28, 0x3d	; 61
    416c:	de b7       	in	r29, 0x3e	; 62
    416e:	2b 97       	sbiw	r28, 0x0b	; 11
    4170:	0f b6       	in	r0, 0x3f	; 63
    4172:	f8 94       	cli
    4174:	de bf       	out	0x3e, r29	; 62
    4176:	0f be       	out	0x3f, r0	; 63
    4178:	cd bf       	out	0x3d, r28	; 61
    417a:	6c 01       	movw	r12, r24
    417c:	7b 01       	movw	r14, r22
    417e:	8a 01       	movw	r16, r20
    4180:	fc 01       	movw	r30, r24
    4182:	17 82       	std	Z+7, r1	; 0x07
    4184:	16 82       	std	Z+6, r1	; 0x06
    4186:	83 81       	ldd	r24, Z+3	; 0x03
    4188:	81 ff       	sbrs	r24, 1
    418a:	bf c1       	rjmp	.+894    	; 0x450a <vfprintf+0x3c4>
    418c:	ce 01       	movw	r24, r28
    418e:	01 96       	adiw	r24, 0x01	; 1
    4190:	3c 01       	movw	r6, r24
    4192:	f6 01       	movw	r30, r12
    4194:	93 81       	ldd	r25, Z+3	; 0x03
    4196:	f7 01       	movw	r30, r14
    4198:	93 fd       	sbrc	r25, 3
    419a:	85 91       	lpm	r24, Z+
    419c:	93 ff       	sbrs	r25, 3
    419e:	81 91       	ld	r24, Z+
    41a0:	7f 01       	movw	r14, r30
    41a2:	88 23       	and	r24, r24
    41a4:	09 f4       	brne	.+2      	; 0x41a8 <vfprintf+0x62>
    41a6:	ad c1       	rjmp	.+858    	; 0x4502 <vfprintf+0x3bc>
    41a8:	85 32       	cpi	r24, 0x25	; 37
    41aa:	39 f4       	brne	.+14     	; 0x41ba <vfprintf+0x74>
    41ac:	93 fd       	sbrc	r25, 3
    41ae:	85 91       	lpm	r24, Z+
    41b0:	93 ff       	sbrs	r25, 3
    41b2:	81 91       	ld	r24, Z+
    41b4:	7f 01       	movw	r14, r30
    41b6:	85 32       	cpi	r24, 0x25	; 37
    41b8:	21 f4       	brne	.+8      	; 0x41c2 <vfprintf+0x7c>
    41ba:	b6 01       	movw	r22, r12
    41bc:	90 e0       	ldi	r25, 0x00	; 0
    41be:	e6 d1       	rcall	.+972    	; 0x458c <fputc>
    41c0:	e8 cf       	rjmp	.-48     	; 0x4192 <vfprintf+0x4c>
    41c2:	91 2c       	mov	r9, r1
    41c4:	21 2c       	mov	r2, r1
    41c6:	31 2c       	mov	r3, r1
    41c8:	ff e1       	ldi	r31, 0x1F	; 31
    41ca:	f3 15       	cp	r31, r3
    41cc:	d8 f0       	brcs	.+54     	; 0x4204 <vfprintf+0xbe>
    41ce:	8b 32       	cpi	r24, 0x2B	; 43
    41d0:	79 f0       	breq	.+30     	; 0x41f0 <vfprintf+0xaa>
    41d2:	38 f4       	brcc	.+14     	; 0x41e2 <vfprintf+0x9c>
    41d4:	80 32       	cpi	r24, 0x20	; 32
    41d6:	79 f0       	breq	.+30     	; 0x41f6 <vfprintf+0xb0>
    41d8:	83 32       	cpi	r24, 0x23	; 35
    41da:	a1 f4       	brne	.+40     	; 0x4204 <vfprintf+0xbe>
    41dc:	23 2d       	mov	r18, r3
    41de:	20 61       	ori	r18, 0x10	; 16
    41e0:	1d c0       	rjmp	.+58     	; 0x421c <vfprintf+0xd6>
    41e2:	8d 32       	cpi	r24, 0x2D	; 45
    41e4:	61 f0       	breq	.+24     	; 0x41fe <vfprintf+0xb8>
    41e6:	80 33       	cpi	r24, 0x30	; 48
    41e8:	69 f4       	brne	.+26     	; 0x4204 <vfprintf+0xbe>
    41ea:	23 2d       	mov	r18, r3
    41ec:	21 60       	ori	r18, 0x01	; 1
    41ee:	16 c0       	rjmp	.+44     	; 0x421c <vfprintf+0xd6>
    41f0:	83 2d       	mov	r24, r3
    41f2:	82 60       	ori	r24, 0x02	; 2
    41f4:	38 2e       	mov	r3, r24
    41f6:	e3 2d       	mov	r30, r3
    41f8:	e4 60       	ori	r30, 0x04	; 4
    41fa:	3e 2e       	mov	r3, r30
    41fc:	2a c0       	rjmp	.+84     	; 0x4252 <vfprintf+0x10c>
    41fe:	f3 2d       	mov	r31, r3
    4200:	f8 60       	ori	r31, 0x08	; 8
    4202:	1d c0       	rjmp	.+58     	; 0x423e <vfprintf+0xf8>
    4204:	37 fc       	sbrc	r3, 7
    4206:	2d c0       	rjmp	.+90     	; 0x4262 <vfprintf+0x11c>
    4208:	20 ed       	ldi	r18, 0xD0	; 208
    420a:	28 0f       	add	r18, r24
    420c:	2a 30       	cpi	r18, 0x0A	; 10
    420e:	40 f0       	brcs	.+16     	; 0x4220 <vfprintf+0xda>
    4210:	8e 32       	cpi	r24, 0x2E	; 46
    4212:	b9 f4       	brne	.+46     	; 0x4242 <vfprintf+0xfc>
    4214:	36 fc       	sbrc	r3, 6
    4216:	75 c1       	rjmp	.+746    	; 0x4502 <vfprintf+0x3bc>
    4218:	23 2d       	mov	r18, r3
    421a:	20 64       	ori	r18, 0x40	; 64
    421c:	32 2e       	mov	r3, r18
    421e:	19 c0       	rjmp	.+50     	; 0x4252 <vfprintf+0x10c>
    4220:	36 fe       	sbrs	r3, 6
    4222:	06 c0       	rjmp	.+12     	; 0x4230 <vfprintf+0xea>
    4224:	8a e0       	ldi	r24, 0x0A	; 10
    4226:	98 9e       	mul	r9, r24
    4228:	20 0d       	add	r18, r0
    422a:	11 24       	eor	r1, r1
    422c:	92 2e       	mov	r9, r18
    422e:	11 c0       	rjmp	.+34     	; 0x4252 <vfprintf+0x10c>
    4230:	ea e0       	ldi	r30, 0x0A	; 10
    4232:	2e 9e       	mul	r2, r30
    4234:	20 0d       	add	r18, r0
    4236:	11 24       	eor	r1, r1
    4238:	22 2e       	mov	r2, r18
    423a:	f3 2d       	mov	r31, r3
    423c:	f0 62       	ori	r31, 0x20	; 32
    423e:	3f 2e       	mov	r3, r31
    4240:	08 c0       	rjmp	.+16     	; 0x4252 <vfprintf+0x10c>
    4242:	8c 36       	cpi	r24, 0x6C	; 108
    4244:	21 f4       	brne	.+8      	; 0x424e <vfprintf+0x108>
    4246:	83 2d       	mov	r24, r3
    4248:	80 68       	ori	r24, 0x80	; 128
    424a:	38 2e       	mov	r3, r24
    424c:	02 c0       	rjmp	.+4      	; 0x4252 <vfprintf+0x10c>
    424e:	88 36       	cpi	r24, 0x68	; 104
    4250:	41 f4       	brne	.+16     	; 0x4262 <vfprintf+0x11c>
    4252:	f7 01       	movw	r30, r14
    4254:	93 fd       	sbrc	r25, 3
    4256:	85 91       	lpm	r24, Z+
    4258:	93 ff       	sbrs	r25, 3
    425a:	81 91       	ld	r24, Z+
    425c:	7f 01       	movw	r14, r30
    425e:	81 11       	cpse	r24, r1
    4260:	b3 cf       	rjmp	.-154    	; 0x41c8 <vfprintf+0x82>
    4262:	98 2f       	mov	r25, r24
    4264:	9f 7d       	andi	r25, 0xDF	; 223
    4266:	95 54       	subi	r25, 0x45	; 69
    4268:	93 30       	cpi	r25, 0x03	; 3
    426a:	28 f4       	brcc	.+10     	; 0x4276 <vfprintf+0x130>
    426c:	0c 5f       	subi	r16, 0xFC	; 252
    426e:	1f 4f       	sbci	r17, 0xFF	; 255
    4270:	9f e3       	ldi	r25, 0x3F	; 63
    4272:	99 83       	std	Y+1, r25	; 0x01
    4274:	0d c0       	rjmp	.+26     	; 0x4290 <vfprintf+0x14a>
    4276:	83 36       	cpi	r24, 0x63	; 99
    4278:	31 f0       	breq	.+12     	; 0x4286 <vfprintf+0x140>
    427a:	83 37       	cpi	r24, 0x73	; 115
    427c:	71 f0       	breq	.+28     	; 0x429a <vfprintf+0x154>
    427e:	83 35       	cpi	r24, 0x53	; 83
    4280:	09 f0       	breq	.+2      	; 0x4284 <vfprintf+0x13e>
    4282:	55 c0       	rjmp	.+170    	; 0x432e <vfprintf+0x1e8>
    4284:	20 c0       	rjmp	.+64     	; 0x42c6 <vfprintf+0x180>
    4286:	f8 01       	movw	r30, r16
    4288:	80 81       	ld	r24, Z
    428a:	89 83       	std	Y+1, r24	; 0x01
    428c:	0e 5f       	subi	r16, 0xFE	; 254
    428e:	1f 4f       	sbci	r17, 0xFF	; 255
    4290:	88 24       	eor	r8, r8
    4292:	83 94       	inc	r8
    4294:	91 2c       	mov	r9, r1
    4296:	53 01       	movw	r10, r6
    4298:	12 c0       	rjmp	.+36     	; 0x42be <vfprintf+0x178>
    429a:	28 01       	movw	r4, r16
    429c:	f2 e0       	ldi	r31, 0x02	; 2
    429e:	4f 0e       	add	r4, r31
    42a0:	51 1c       	adc	r5, r1
    42a2:	f8 01       	movw	r30, r16
    42a4:	a0 80       	ld	r10, Z
    42a6:	b1 80       	ldd	r11, Z+1	; 0x01
    42a8:	36 fe       	sbrs	r3, 6
    42aa:	03 c0       	rjmp	.+6      	; 0x42b2 <vfprintf+0x16c>
    42ac:	69 2d       	mov	r22, r9
    42ae:	70 e0       	ldi	r23, 0x00	; 0
    42b0:	02 c0       	rjmp	.+4      	; 0x42b6 <vfprintf+0x170>
    42b2:	6f ef       	ldi	r22, 0xFF	; 255
    42b4:	7f ef       	ldi	r23, 0xFF	; 255
    42b6:	c5 01       	movw	r24, r10
    42b8:	4e d1       	rcall	.+668    	; 0x4556 <strnlen>
    42ba:	4c 01       	movw	r8, r24
    42bc:	82 01       	movw	r16, r4
    42be:	f3 2d       	mov	r31, r3
    42c0:	ff 77       	andi	r31, 0x7F	; 127
    42c2:	3f 2e       	mov	r3, r31
    42c4:	15 c0       	rjmp	.+42     	; 0x42f0 <vfprintf+0x1aa>
    42c6:	28 01       	movw	r4, r16
    42c8:	22 e0       	ldi	r18, 0x02	; 2
    42ca:	42 0e       	add	r4, r18
    42cc:	51 1c       	adc	r5, r1
    42ce:	f8 01       	movw	r30, r16
    42d0:	a0 80       	ld	r10, Z
    42d2:	b1 80       	ldd	r11, Z+1	; 0x01
    42d4:	36 fe       	sbrs	r3, 6
    42d6:	03 c0       	rjmp	.+6      	; 0x42de <vfprintf+0x198>
    42d8:	69 2d       	mov	r22, r9
    42da:	70 e0       	ldi	r23, 0x00	; 0
    42dc:	02 c0       	rjmp	.+4      	; 0x42e2 <vfprintf+0x19c>
    42de:	6f ef       	ldi	r22, 0xFF	; 255
    42e0:	7f ef       	ldi	r23, 0xFF	; 255
    42e2:	c5 01       	movw	r24, r10
    42e4:	2d d1       	rcall	.+602    	; 0x4540 <strnlen_P>
    42e6:	4c 01       	movw	r8, r24
    42e8:	f3 2d       	mov	r31, r3
    42ea:	f0 68       	ori	r31, 0x80	; 128
    42ec:	3f 2e       	mov	r3, r31
    42ee:	82 01       	movw	r16, r4
    42f0:	33 fc       	sbrc	r3, 3
    42f2:	19 c0       	rjmp	.+50     	; 0x4326 <vfprintf+0x1e0>
    42f4:	82 2d       	mov	r24, r2
    42f6:	90 e0       	ldi	r25, 0x00	; 0
    42f8:	88 16       	cp	r8, r24
    42fa:	99 06       	cpc	r9, r25
    42fc:	a0 f4       	brcc	.+40     	; 0x4326 <vfprintf+0x1e0>
    42fe:	b6 01       	movw	r22, r12
    4300:	80 e2       	ldi	r24, 0x20	; 32
    4302:	90 e0       	ldi	r25, 0x00	; 0
    4304:	43 d1       	rcall	.+646    	; 0x458c <fputc>
    4306:	2a 94       	dec	r2
    4308:	f5 cf       	rjmp	.-22     	; 0x42f4 <vfprintf+0x1ae>
    430a:	f5 01       	movw	r30, r10
    430c:	37 fc       	sbrc	r3, 7
    430e:	85 91       	lpm	r24, Z+
    4310:	37 fe       	sbrs	r3, 7
    4312:	81 91       	ld	r24, Z+
    4314:	5f 01       	movw	r10, r30
    4316:	b6 01       	movw	r22, r12
    4318:	90 e0       	ldi	r25, 0x00	; 0
    431a:	38 d1       	rcall	.+624    	; 0x458c <fputc>
    431c:	21 10       	cpse	r2, r1
    431e:	2a 94       	dec	r2
    4320:	21 e0       	ldi	r18, 0x01	; 1
    4322:	82 1a       	sub	r8, r18
    4324:	91 08       	sbc	r9, r1
    4326:	81 14       	cp	r8, r1
    4328:	91 04       	cpc	r9, r1
    432a:	79 f7       	brne	.-34     	; 0x430a <vfprintf+0x1c4>
    432c:	e1 c0       	rjmp	.+450    	; 0x44f0 <vfprintf+0x3aa>
    432e:	84 36       	cpi	r24, 0x64	; 100
    4330:	11 f0       	breq	.+4      	; 0x4336 <vfprintf+0x1f0>
    4332:	89 36       	cpi	r24, 0x69	; 105
    4334:	39 f5       	brne	.+78     	; 0x4384 <vfprintf+0x23e>
    4336:	f8 01       	movw	r30, r16
    4338:	37 fe       	sbrs	r3, 7
    433a:	07 c0       	rjmp	.+14     	; 0x434a <vfprintf+0x204>
    433c:	60 81       	ld	r22, Z
    433e:	71 81       	ldd	r23, Z+1	; 0x01
    4340:	82 81       	ldd	r24, Z+2	; 0x02
    4342:	93 81       	ldd	r25, Z+3	; 0x03
    4344:	0c 5f       	subi	r16, 0xFC	; 252
    4346:	1f 4f       	sbci	r17, 0xFF	; 255
    4348:	08 c0       	rjmp	.+16     	; 0x435a <vfprintf+0x214>
    434a:	60 81       	ld	r22, Z
    434c:	71 81       	ldd	r23, Z+1	; 0x01
    434e:	07 2e       	mov	r0, r23
    4350:	00 0c       	add	r0, r0
    4352:	88 0b       	sbc	r24, r24
    4354:	99 0b       	sbc	r25, r25
    4356:	0e 5f       	subi	r16, 0xFE	; 254
    4358:	1f 4f       	sbci	r17, 0xFF	; 255
    435a:	f3 2d       	mov	r31, r3
    435c:	ff 76       	andi	r31, 0x6F	; 111
    435e:	3f 2e       	mov	r3, r31
    4360:	97 ff       	sbrs	r25, 7
    4362:	09 c0       	rjmp	.+18     	; 0x4376 <vfprintf+0x230>
    4364:	90 95       	com	r25
    4366:	80 95       	com	r24
    4368:	70 95       	com	r23
    436a:	61 95       	neg	r22
    436c:	7f 4f       	sbci	r23, 0xFF	; 255
    436e:	8f 4f       	sbci	r24, 0xFF	; 255
    4370:	9f 4f       	sbci	r25, 0xFF	; 255
    4372:	f0 68       	ori	r31, 0x80	; 128
    4374:	3f 2e       	mov	r3, r31
    4376:	2a e0       	ldi	r18, 0x0A	; 10
    4378:	30 e0       	ldi	r19, 0x00	; 0
    437a:	a3 01       	movw	r20, r6
    437c:	43 d1       	rcall	.+646    	; 0x4604 <__ultoa_invert>
    437e:	88 2e       	mov	r8, r24
    4380:	86 18       	sub	r8, r6
    4382:	44 c0       	rjmp	.+136    	; 0x440c <vfprintf+0x2c6>
    4384:	85 37       	cpi	r24, 0x75	; 117
    4386:	31 f4       	brne	.+12     	; 0x4394 <vfprintf+0x24e>
    4388:	23 2d       	mov	r18, r3
    438a:	2f 7e       	andi	r18, 0xEF	; 239
    438c:	b2 2e       	mov	r11, r18
    438e:	2a e0       	ldi	r18, 0x0A	; 10
    4390:	30 e0       	ldi	r19, 0x00	; 0
    4392:	25 c0       	rjmp	.+74     	; 0x43de <vfprintf+0x298>
    4394:	93 2d       	mov	r25, r3
    4396:	99 7f       	andi	r25, 0xF9	; 249
    4398:	b9 2e       	mov	r11, r25
    439a:	8f 36       	cpi	r24, 0x6F	; 111
    439c:	c1 f0       	breq	.+48     	; 0x43ce <vfprintf+0x288>
    439e:	18 f4       	brcc	.+6      	; 0x43a6 <vfprintf+0x260>
    43a0:	88 35       	cpi	r24, 0x58	; 88
    43a2:	79 f0       	breq	.+30     	; 0x43c2 <vfprintf+0x27c>
    43a4:	ae c0       	rjmp	.+348    	; 0x4502 <vfprintf+0x3bc>
    43a6:	80 37       	cpi	r24, 0x70	; 112
    43a8:	19 f0       	breq	.+6      	; 0x43b0 <vfprintf+0x26a>
    43aa:	88 37       	cpi	r24, 0x78	; 120
    43ac:	21 f0       	breq	.+8      	; 0x43b6 <vfprintf+0x270>
    43ae:	a9 c0       	rjmp	.+338    	; 0x4502 <vfprintf+0x3bc>
    43b0:	e9 2f       	mov	r30, r25
    43b2:	e0 61       	ori	r30, 0x10	; 16
    43b4:	be 2e       	mov	r11, r30
    43b6:	b4 fe       	sbrs	r11, 4
    43b8:	0d c0       	rjmp	.+26     	; 0x43d4 <vfprintf+0x28e>
    43ba:	fb 2d       	mov	r31, r11
    43bc:	f4 60       	ori	r31, 0x04	; 4
    43be:	bf 2e       	mov	r11, r31
    43c0:	09 c0       	rjmp	.+18     	; 0x43d4 <vfprintf+0x28e>
    43c2:	34 fe       	sbrs	r3, 4
    43c4:	0a c0       	rjmp	.+20     	; 0x43da <vfprintf+0x294>
    43c6:	29 2f       	mov	r18, r25
    43c8:	26 60       	ori	r18, 0x06	; 6
    43ca:	b2 2e       	mov	r11, r18
    43cc:	06 c0       	rjmp	.+12     	; 0x43da <vfprintf+0x294>
    43ce:	28 e0       	ldi	r18, 0x08	; 8
    43d0:	30 e0       	ldi	r19, 0x00	; 0
    43d2:	05 c0       	rjmp	.+10     	; 0x43de <vfprintf+0x298>
    43d4:	20 e1       	ldi	r18, 0x10	; 16
    43d6:	30 e0       	ldi	r19, 0x00	; 0
    43d8:	02 c0       	rjmp	.+4      	; 0x43de <vfprintf+0x298>
    43da:	20 e1       	ldi	r18, 0x10	; 16
    43dc:	32 e0       	ldi	r19, 0x02	; 2
    43de:	f8 01       	movw	r30, r16
    43e0:	b7 fe       	sbrs	r11, 7
    43e2:	07 c0       	rjmp	.+14     	; 0x43f2 <vfprintf+0x2ac>
    43e4:	60 81       	ld	r22, Z
    43e6:	71 81       	ldd	r23, Z+1	; 0x01
    43e8:	82 81       	ldd	r24, Z+2	; 0x02
    43ea:	93 81       	ldd	r25, Z+3	; 0x03
    43ec:	0c 5f       	subi	r16, 0xFC	; 252
    43ee:	1f 4f       	sbci	r17, 0xFF	; 255
    43f0:	06 c0       	rjmp	.+12     	; 0x43fe <vfprintf+0x2b8>
    43f2:	60 81       	ld	r22, Z
    43f4:	71 81       	ldd	r23, Z+1	; 0x01
    43f6:	80 e0       	ldi	r24, 0x00	; 0
    43f8:	90 e0       	ldi	r25, 0x00	; 0
    43fa:	0e 5f       	subi	r16, 0xFE	; 254
    43fc:	1f 4f       	sbci	r17, 0xFF	; 255
    43fe:	a3 01       	movw	r20, r6
    4400:	01 d1       	rcall	.+514    	; 0x4604 <__ultoa_invert>
    4402:	88 2e       	mov	r8, r24
    4404:	86 18       	sub	r8, r6
    4406:	fb 2d       	mov	r31, r11
    4408:	ff 77       	andi	r31, 0x7F	; 127
    440a:	3f 2e       	mov	r3, r31
    440c:	36 fe       	sbrs	r3, 6
    440e:	0d c0       	rjmp	.+26     	; 0x442a <vfprintf+0x2e4>
    4410:	23 2d       	mov	r18, r3
    4412:	2e 7f       	andi	r18, 0xFE	; 254
    4414:	a2 2e       	mov	r10, r18
    4416:	89 14       	cp	r8, r9
    4418:	58 f4       	brcc	.+22     	; 0x4430 <vfprintf+0x2ea>
    441a:	34 fe       	sbrs	r3, 4
    441c:	0b c0       	rjmp	.+22     	; 0x4434 <vfprintf+0x2ee>
    441e:	32 fc       	sbrc	r3, 2
    4420:	09 c0       	rjmp	.+18     	; 0x4434 <vfprintf+0x2ee>
    4422:	83 2d       	mov	r24, r3
    4424:	8e 7e       	andi	r24, 0xEE	; 238
    4426:	a8 2e       	mov	r10, r24
    4428:	05 c0       	rjmp	.+10     	; 0x4434 <vfprintf+0x2ee>
    442a:	b8 2c       	mov	r11, r8
    442c:	a3 2c       	mov	r10, r3
    442e:	03 c0       	rjmp	.+6      	; 0x4436 <vfprintf+0x2f0>
    4430:	b8 2c       	mov	r11, r8
    4432:	01 c0       	rjmp	.+2      	; 0x4436 <vfprintf+0x2f0>
    4434:	b9 2c       	mov	r11, r9
    4436:	a4 fe       	sbrs	r10, 4
    4438:	0f c0       	rjmp	.+30     	; 0x4458 <vfprintf+0x312>
    443a:	fe 01       	movw	r30, r28
    443c:	e8 0d       	add	r30, r8
    443e:	f1 1d       	adc	r31, r1
    4440:	80 81       	ld	r24, Z
    4442:	80 33       	cpi	r24, 0x30	; 48
    4444:	21 f4       	brne	.+8      	; 0x444e <vfprintf+0x308>
    4446:	9a 2d       	mov	r25, r10
    4448:	99 7e       	andi	r25, 0xE9	; 233
    444a:	a9 2e       	mov	r10, r25
    444c:	09 c0       	rjmp	.+18     	; 0x4460 <vfprintf+0x31a>
    444e:	a2 fe       	sbrs	r10, 2
    4450:	06 c0       	rjmp	.+12     	; 0x445e <vfprintf+0x318>
    4452:	b3 94       	inc	r11
    4454:	b3 94       	inc	r11
    4456:	04 c0       	rjmp	.+8      	; 0x4460 <vfprintf+0x31a>
    4458:	8a 2d       	mov	r24, r10
    445a:	86 78       	andi	r24, 0x86	; 134
    445c:	09 f0       	breq	.+2      	; 0x4460 <vfprintf+0x31a>
    445e:	b3 94       	inc	r11
    4460:	a3 fc       	sbrc	r10, 3
    4462:	10 c0       	rjmp	.+32     	; 0x4484 <vfprintf+0x33e>
    4464:	a0 fe       	sbrs	r10, 0
    4466:	06 c0       	rjmp	.+12     	; 0x4474 <vfprintf+0x32e>
    4468:	b2 14       	cp	r11, r2
    446a:	80 f4       	brcc	.+32     	; 0x448c <vfprintf+0x346>
    446c:	28 0c       	add	r2, r8
    446e:	92 2c       	mov	r9, r2
    4470:	9b 18       	sub	r9, r11
    4472:	0d c0       	rjmp	.+26     	; 0x448e <vfprintf+0x348>
    4474:	b2 14       	cp	r11, r2
    4476:	58 f4       	brcc	.+22     	; 0x448e <vfprintf+0x348>
    4478:	b6 01       	movw	r22, r12
    447a:	80 e2       	ldi	r24, 0x20	; 32
    447c:	90 e0       	ldi	r25, 0x00	; 0
    447e:	86 d0       	rcall	.+268    	; 0x458c <fputc>
    4480:	b3 94       	inc	r11
    4482:	f8 cf       	rjmp	.-16     	; 0x4474 <vfprintf+0x32e>
    4484:	b2 14       	cp	r11, r2
    4486:	18 f4       	brcc	.+6      	; 0x448e <vfprintf+0x348>
    4488:	2b 18       	sub	r2, r11
    448a:	02 c0       	rjmp	.+4      	; 0x4490 <vfprintf+0x34a>
    448c:	98 2c       	mov	r9, r8
    448e:	21 2c       	mov	r2, r1
    4490:	a4 fe       	sbrs	r10, 4
    4492:	0f c0       	rjmp	.+30     	; 0x44b2 <vfprintf+0x36c>
    4494:	b6 01       	movw	r22, r12
    4496:	80 e3       	ldi	r24, 0x30	; 48
    4498:	90 e0       	ldi	r25, 0x00	; 0
    449a:	78 d0       	rcall	.+240    	; 0x458c <fputc>
    449c:	a2 fe       	sbrs	r10, 2
    449e:	16 c0       	rjmp	.+44     	; 0x44cc <vfprintf+0x386>
    44a0:	a1 fc       	sbrc	r10, 1
    44a2:	03 c0       	rjmp	.+6      	; 0x44aa <vfprintf+0x364>
    44a4:	88 e7       	ldi	r24, 0x78	; 120
    44a6:	90 e0       	ldi	r25, 0x00	; 0
    44a8:	02 c0       	rjmp	.+4      	; 0x44ae <vfprintf+0x368>
    44aa:	88 e5       	ldi	r24, 0x58	; 88
    44ac:	90 e0       	ldi	r25, 0x00	; 0
    44ae:	b6 01       	movw	r22, r12
    44b0:	0c c0       	rjmp	.+24     	; 0x44ca <vfprintf+0x384>
    44b2:	8a 2d       	mov	r24, r10
    44b4:	86 78       	andi	r24, 0x86	; 134
    44b6:	51 f0       	breq	.+20     	; 0x44cc <vfprintf+0x386>
    44b8:	a1 fe       	sbrs	r10, 1
    44ba:	02 c0       	rjmp	.+4      	; 0x44c0 <vfprintf+0x37a>
    44bc:	8b e2       	ldi	r24, 0x2B	; 43
    44be:	01 c0       	rjmp	.+2      	; 0x44c2 <vfprintf+0x37c>
    44c0:	80 e2       	ldi	r24, 0x20	; 32
    44c2:	a7 fc       	sbrc	r10, 7
    44c4:	8d e2       	ldi	r24, 0x2D	; 45
    44c6:	b6 01       	movw	r22, r12
    44c8:	90 e0       	ldi	r25, 0x00	; 0
    44ca:	60 d0       	rcall	.+192    	; 0x458c <fputc>
    44cc:	89 14       	cp	r8, r9
    44ce:	30 f4       	brcc	.+12     	; 0x44dc <vfprintf+0x396>
    44d0:	b6 01       	movw	r22, r12
    44d2:	80 e3       	ldi	r24, 0x30	; 48
    44d4:	90 e0       	ldi	r25, 0x00	; 0
    44d6:	5a d0       	rcall	.+180    	; 0x458c <fputc>
    44d8:	9a 94       	dec	r9
    44da:	f8 cf       	rjmp	.-16     	; 0x44cc <vfprintf+0x386>
    44dc:	8a 94       	dec	r8
    44de:	f3 01       	movw	r30, r6
    44e0:	e8 0d       	add	r30, r8
    44e2:	f1 1d       	adc	r31, r1
    44e4:	80 81       	ld	r24, Z
    44e6:	b6 01       	movw	r22, r12
    44e8:	90 e0       	ldi	r25, 0x00	; 0
    44ea:	50 d0       	rcall	.+160    	; 0x458c <fputc>
    44ec:	81 10       	cpse	r8, r1
    44ee:	f6 cf       	rjmp	.-20     	; 0x44dc <vfprintf+0x396>
    44f0:	22 20       	and	r2, r2
    44f2:	09 f4       	brne	.+2      	; 0x44f6 <vfprintf+0x3b0>
    44f4:	4e ce       	rjmp	.-868    	; 0x4192 <vfprintf+0x4c>
    44f6:	b6 01       	movw	r22, r12
    44f8:	80 e2       	ldi	r24, 0x20	; 32
    44fa:	90 e0       	ldi	r25, 0x00	; 0
    44fc:	47 d0       	rcall	.+142    	; 0x458c <fputc>
    44fe:	2a 94       	dec	r2
    4500:	f7 cf       	rjmp	.-18     	; 0x44f0 <vfprintf+0x3aa>
    4502:	f6 01       	movw	r30, r12
    4504:	86 81       	ldd	r24, Z+6	; 0x06
    4506:	97 81       	ldd	r25, Z+7	; 0x07
    4508:	02 c0       	rjmp	.+4      	; 0x450e <vfprintf+0x3c8>
    450a:	8f ef       	ldi	r24, 0xFF	; 255
    450c:	9f ef       	ldi	r25, 0xFF	; 255
    450e:	2b 96       	adiw	r28, 0x0b	; 11
    4510:	0f b6       	in	r0, 0x3f	; 63
    4512:	f8 94       	cli
    4514:	de bf       	out	0x3e, r29	; 62
    4516:	0f be       	out	0x3f, r0	; 63
    4518:	cd bf       	out	0x3d, r28	; 61
    451a:	df 91       	pop	r29
    451c:	cf 91       	pop	r28
    451e:	1f 91       	pop	r17
    4520:	0f 91       	pop	r16
    4522:	ff 90       	pop	r15
    4524:	ef 90       	pop	r14
    4526:	df 90       	pop	r13
    4528:	cf 90       	pop	r12
    452a:	bf 90       	pop	r11
    452c:	af 90       	pop	r10
    452e:	9f 90       	pop	r9
    4530:	8f 90       	pop	r8
    4532:	7f 90       	pop	r7
    4534:	6f 90       	pop	r6
    4536:	5f 90       	pop	r5
    4538:	4f 90       	pop	r4
    453a:	3f 90       	pop	r3
    453c:	2f 90       	pop	r2
    453e:	08 95       	ret

00004540 <strnlen_P>:
    4540:	fc 01       	movw	r30, r24
    4542:	05 90       	lpm	r0, Z+
    4544:	61 50       	subi	r22, 0x01	; 1
    4546:	70 40       	sbci	r23, 0x00	; 0
    4548:	01 10       	cpse	r0, r1
    454a:	d8 f7       	brcc	.-10     	; 0x4542 <strnlen_P+0x2>
    454c:	80 95       	com	r24
    454e:	90 95       	com	r25
    4550:	8e 0f       	add	r24, r30
    4552:	9f 1f       	adc	r25, r31
    4554:	08 95       	ret

00004556 <strnlen>:
    4556:	fc 01       	movw	r30, r24
    4558:	61 50       	subi	r22, 0x01	; 1
    455a:	70 40       	sbci	r23, 0x00	; 0
    455c:	01 90       	ld	r0, Z+
    455e:	01 10       	cpse	r0, r1
    4560:	d8 f7       	brcc	.-10     	; 0x4558 <strnlen+0x2>
    4562:	80 95       	com	r24
    4564:	90 95       	com	r25
    4566:	8e 0f       	add	r24, r30
    4568:	9f 1f       	adc	r25, r31
    456a:	08 95       	ret

0000456c <strrev>:
    456c:	dc 01       	movw	r26, r24
    456e:	fc 01       	movw	r30, r24
    4570:	67 2f       	mov	r22, r23
    4572:	71 91       	ld	r23, Z+
    4574:	77 23       	and	r23, r23
    4576:	e1 f7       	brne	.-8      	; 0x4570 <strrev+0x4>
    4578:	32 97       	sbiw	r30, 0x02	; 2
    457a:	04 c0       	rjmp	.+8      	; 0x4584 <strrev+0x18>
    457c:	7c 91       	ld	r23, X
    457e:	6d 93       	st	X+, r22
    4580:	70 83       	st	Z, r23
    4582:	62 91       	ld	r22, -Z
    4584:	ae 17       	cp	r26, r30
    4586:	bf 07       	cpc	r27, r31
    4588:	c8 f3       	brcs	.-14     	; 0x457c <strrev+0x10>
    458a:	08 95       	ret

0000458c <fputc>:
    458c:	0f 93       	push	r16
    458e:	1f 93       	push	r17
    4590:	cf 93       	push	r28
    4592:	df 93       	push	r29
    4594:	fb 01       	movw	r30, r22
    4596:	23 81       	ldd	r18, Z+3	; 0x03
    4598:	21 fd       	sbrc	r18, 1
    459a:	03 c0       	rjmp	.+6      	; 0x45a2 <fputc+0x16>
    459c:	8f ef       	ldi	r24, 0xFF	; 255
    459e:	9f ef       	ldi	r25, 0xFF	; 255
    45a0:	2c c0       	rjmp	.+88     	; 0x45fa <fputc+0x6e>
    45a2:	22 ff       	sbrs	r18, 2
    45a4:	16 c0       	rjmp	.+44     	; 0x45d2 <fputc+0x46>
    45a6:	46 81       	ldd	r20, Z+6	; 0x06
    45a8:	57 81       	ldd	r21, Z+7	; 0x07
    45aa:	24 81       	ldd	r18, Z+4	; 0x04
    45ac:	35 81       	ldd	r19, Z+5	; 0x05
    45ae:	42 17       	cp	r20, r18
    45b0:	53 07       	cpc	r21, r19
    45b2:	44 f4       	brge	.+16     	; 0x45c4 <fputc+0x38>
    45b4:	a0 81       	ld	r26, Z
    45b6:	b1 81       	ldd	r27, Z+1	; 0x01
    45b8:	9d 01       	movw	r18, r26
    45ba:	2f 5f       	subi	r18, 0xFF	; 255
    45bc:	3f 4f       	sbci	r19, 0xFF	; 255
    45be:	31 83       	std	Z+1, r19	; 0x01
    45c0:	20 83       	st	Z, r18
    45c2:	8c 93       	st	X, r24
    45c4:	26 81       	ldd	r18, Z+6	; 0x06
    45c6:	37 81       	ldd	r19, Z+7	; 0x07
    45c8:	2f 5f       	subi	r18, 0xFF	; 255
    45ca:	3f 4f       	sbci	r19, 0xFF	; 255
    45cc:	37 83       	std	Z+7, r19	; 0x07
    45ce:	26 83       	std	Z+6, r18	; 0x06
    45d0:	14 c0       	rjmp	.+40     	; 0x45fa <fputc+0x6e>
    45d2:	8b 01       	movw	r16, r22
    45d4:	ec 01       	movw	r28, r24
    45d6:	fb 01       	movw	r30, r22
    45d8:	00 84       	ldd	r0, Z+8	; 0x08
    45da:	f1 85       	ldd	r31, Z+9	; 0x09
    45dc:	e0 2d       	mov	r30, r0
    45de:	19 95       	eicall
    45e0:	89 2b       	or	r24, r25
    45e2:	e1 f6       	brne	.-72     	; 0x459c <fputc+0x10>
    45e4:	d8 01       	movw	r26, r16
    45e6:	16 96       	adiw	r26, 0x06	; 6
    45e8:	8d 91       	ld	r24, X+
    45ea:	9c 91       	ld	r25, X
    45ec:	17 97       	sbiw	r26, 0x07	; 7
    45ee:	01 96       	adiw	r24, 0x01	; 1
    45f0:	17 96       	adiw	r26, 0x07	; 7
    45f2:	9c 93       	st	X, r25
    45f4:	8e 93       	st	-X, r24
    45f6:	16 97       	sbiw	r26, 0x06	; 6
    45f8:	ce 01       	movw	r24, r28
    45fa:	df 91       	pop	r29
    45fc:	cf 91       	pop	r28
    45fe:	1f 91       	pop	r17
    4600:	0f 91       	pop	r16
    4602:	08 95       	ret

00004604 <__ultoa_invert>:
    4604:	fa 01       	movw	r30, r20
    4606:	aa 27       	eor	r26, r26
    4608:	28 30       	cpi	r18, 0x08	; 8
    460a:	51 f1       	breq	.+84     	; 0x4660 <__ultoa_invert+0x5c>
    460c:	20 31       	cpi	r18, 0x10	; 16
    460e:	81 f1       	breq	.+96     	; 0x4670 <__ultoa_invert+0x6c>
    4610:	e8 94       	clt
    4612:	6f 93       	push	r22
    4614:	6e 7f       	andi	r22, 0xFE	; 254
    4616:	6e 5f       	subi	r22, 0xFE	; 254
    4618:	7f 4f       	sbci	r23, 0xFF	; 255
    461a:	8f 4f       	sbci	r24, 0xFF	; 255
    461c:	9f 4f       	sbci	r25, 0xFF	; 255
    461e:	af 4f       	sbci	r26, 0xFF	; 255
    4620:	b1 e0       	ldi	r27, 0x01	; 1
    4622:	3e d0       	rcall	.+124    	; 0x46a0 <__ultoa_invert+0x9c>
    4624:	b4 e0       	ldi	r27, 0x04	; 4
    4626:	3c d0       	rcall	.+120    	; 0x46a0 <__ultoa_invert+0x9c>
    4628:	67 0f       	add	r22, r23
    462a:	78 1f       	adc	r23, r24
    462c:	89 1f       	adc	r24, r25
    462e:	9a 1f       	adc	r25, r26
    4630:	a1 1d       	adc	r26, r1
    4632:	68 0f       	add	r22, r24
    4634:	79 1f       	adc	r23, r25
    4636:	8a 1f       	adc	r24, r26
    4638:	91 1d       	adc	r25, r1
    463a:	a1 1d       	adc	r26, r1
    463c:	6a 0f       	add	r22, r26
    463e:	71 1d       	adc	r23, r1
    4640:	81 1d       	adc	r24, r1
    4642:	91 1d       	adc	r25, r1
    4644:	a1 1d       	adc	r26, r1
    4646:	20 d0       	rcall	.+64     	; 0x4688 <__ultoa_invert+0x84>
    4648:	09 f4       	brne	.+2      	; 0x464c <__ultoa_invert+0x48>
    464a:	68 94       	set
    464c:	3f 91       	pop	r19
    464e:	2a e0       	ldi	r18, 0x0A	; 10
    4650:	26 9f       	mul	r18, r22
    4652:	11 24       	eor	r1, r1
    4654:	30 19       	sub	r19, r0
    4656:	30 5d       	subi	r19, 0xD0	; 208
    4658:	31 93       	st	Z+, r19
    465a:	de f6       	brtc	.-74     	; 0x4612 <__ultoa_invert+0xe>
    465c:	cf 01       	movw	r24, r30
    465e:	08 95       	ret
    4660:	46 2f       	mov	r20, r22
    4662:	47 70       	andi	r20, 0x07	; 7
    4664:	40 5d       	subi	r20, 0xD0	; 208
    4666:	41 93       	st	Z+, r20
    4668:	b3 e0       	ldi	r27, 0x03	; 3
    466a:	0f d0       	rcall	.+30     	; 0x468a <__ultoa_invert+0x86>
    466c:	c9 f7       	brne	.-14     	; 0x4660 <__ultoa_invert+0x5c>
    466e:	f6 cf       	rjmp	.-20     	; 0x465c <__ultoa_invert+0x58>
    4670:	46 2f       	mov	r20, r22
    4672:	4f 70       	andi	r20, 0x0F	; 15
    4674:	40 5d       	subi	r20, 0xD0	; 208
    4676:	4a 33       	cpi	r20, 0x3A	; 58
    4678:	18 f0       	brcs	.+6      	; 0x4680 <__ultoa_invert+0x7c>
    467a:	49 5d       	subi	r20, 0xD9	; 217
    467c:	31 fd       	sbrc	r19, 1
    467e:	40 52       	subi	r20, 0x20	; 32
    4680:	41 93       	st	Z+, r20
    4682:	02 d0       	rcall	.+4      	; 0x4688 <__ultoa_invert+0x84>
    4684:	a9 f7       	brne	.-22     	; 0x4670 <__ultoa_invert+0x6c>
    4686:	ea cf       	rjmp	.-44     	; 0x465c <__ultoa_invert+0x58>
    4688:	b4 e0       	ldi	r27, 0x04	; 4
    468a:	a6 95       	lsr	r26
    468c:	97 95       	ror	r25
    468e:	87 95       	ror	r24
    4690:	77 95       	ror	r23
    4692:	67 95       	ror	r22
    4694:	ba 95       	dec	r27
    4696:	c9 f7       	brne	.-14     	; 0x468a <__ultoa_invert+0x86>
    4698:	00 97       	sbiw	r24, 0x00	; 0
    469a:	61 05       	cpc	r22, r1
    469c:	71 05       	cpc	r23, r1
    469e:	08 95       	ret
    46a0:	9b 01       	movw	r18, r22
    46a2:	ac 01       	movw	r20, r24
    46a4:	0a 2e       	mov	r0, r26
    46a6:	06 94       	lsr	r0
    46a8:	57 95       	ror	r21
    46aa:	47 95       	ror	r20
    46ac:	37 95       	ror	r19
    46ae:	27 95       	ror	r18
    46b0:	ba 95       	dec	r27
    46b2:	c9 f7       	brne	.-14     	; 0x46a6 <__ultoa_invert+0xa2>
    46b4:	62 0f       	add	r22, r18
    46b6:	73 1f       	adc	r23, r19
    46b8:	84 1f       	adc	r24, r20
    46ba:	95 1f       	adc	r25, r21
    46bc:	a0 1d       	adc	r26, r0
    46be:	08 95       	ret

000046c0 <_exit>:
    46c0:	f8 94       	cli

000046c2 <__stop_program>:
    46c2:	ff cf       	rjmp	.-2      	; 0x46c2 <__stop_program>
