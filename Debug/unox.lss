
unox.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00800100  00001402  00001496  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001402  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000465  00800116  00800116  000014ac  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000014ac  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000248  00000000  00000000  000014dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000028bb  00000000  00000000  00001724  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000b9c  00000000  00000000  00003fdf  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000d60  00000000  00000000  00004b7b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000710  00000000  00000000  000058dc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000baf  00000000  00000000  00005fec  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000021c9  00000000  00000000  00006b9b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000001f0  00000000  00000000  00008d64  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 28 03 	jmp	0x650	; 0x650 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 41 09 	jmp	0x1282	; 0x1282 <__vector_18>
      4c:	0c 94 7c 09 	jmp	0x12f8	; 0x12f8 <__vector_19>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e2 e0       	ldi	r30, 0x02	; 2
      7c:	f4 e1       	ldi	r31, 0x14	; 20
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a6 31       	cpi	r26, 0x16	; 22
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	25 e0       	ldi	r18, 0x05	; 5
      8c:	a6 e1       	ldi	r26, 0x16	; 22
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	ab 37       	cpi	r26, 0x7B	; 123
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 bc 00 	call	0x178	; 0x178 <main>
      9e:	0c 94 ff 09 	jmp	0x13fe	; 0x13fe <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <DoCalculate>:
		DoCalculate(500); // "application"
	}
}

static void DoCalculate(int count) // just to use processor time
{
      a6:	cf 93       	push	r28
      a8:	df 93       	push	r29
      aa:	00 d0       	rcall	.+0      	; 0xac <DoCalculate+0x6>
      ac:	00 d0       	rcall	.+0      	; 0xae <DoCalculate+0x8>
      ae:	cd b7       	in	r28, 0x3d	; 61
      b0:	de b7       	in	r29, 0x3e	; 62
	     volatile int i, a = 0;
      b2:	1c 82       	std	Y+4, r1	; 0x04
      b4:	1b 82       	std	Y+3, r1	; 0x03
	     for(i=0; i < count; i++)
      b6:	1a 82       	std	Y+2, r1	; 0x02
      b8:	19 82       	std	Y+1, r1	; 0x01
      ba:	29 81       	ldd	r18, Y+1	; 0x01
      bc:	3a 81       	ldd	r19, Y+2	; 0x02
      be:	28 17       	cp	r18, r24
      c0:	39 07       	cpc	r19, r25
      c2:	bc f4       	brge	.+46     	; 0xf2 <DoCalculate+0x4c>
	     a=a*100+200;
      c4:	64 e6       	ldi	r22, 0x64	; 100
      c6:	4b 81       	ldd	r20, Y+3	; 0x03
      c8:	5c 81       	ldd	r21, Y+4	; 0x04
      ca:	64 9f       	mul	r22, r20
      cc:	90 01       	movw	r18, r0
      ce:	65 9f       	mul	r22, r21
      d0:	30 0d       	add	r19, r0
      d2:	11 24       	eor	r1, r1
      d4:	28 53       	subi	r18, 0x38	; 56
      d6:	3f 4f       	sbci	r19, 0xFF	; 255
      d8:	3c 83       	std	Y+4, r19	; 0x04
      da:	2b 83       	std	Y+3, r18	; 0x03
}

static void DoCalculate(int count) // just to use processor time
{
	     volatile int i, a = 0;
	     for(i=0; i < count; i++)
      dc:	29 81       	ldd	r18, Y+1	; 0x01
      de:	3a 81       	ldd	r19, Y+2	; 0x02
      e0:	2f 5f       	subi	r18, 0xFF	; 255
      e2:	3f 4f       	sbci	r19, 0xFF	; 255
      e4:	3a 83       	std	Y+2, r19	; 0x02
      e6:	29 83       	std	Y+1, r18	; 0x01
      e8:	29 81       	ldd	r18, Y+1	; 0x01
      ea:	3a 81       	ldd	r19, Y+2	; 0x02
      ec:	28 17       	cp	r18, r24
      ee:	39 07       	cpc	r19, r25
      f0:	54 f3       	brlt	.-44     	; 0xc6 <DoCalculate+0x20>
	     a=a*100+200;
}
      f2:	0f 90       	pop	r0
      f4:	0f 90       	pop	r0
      f6:	0f 90       	pop	r0
      f8:	0f 90       	pop	r0
      fa:	df 91       	pop	r29
      fc:	cf 91       	pop	r28
      fe:	08 95       	ret

00000100 <vWriter3>:

		DoCalculate(500); // "application"
	}
}
static void vWriter3( void *pvParameters )
{
     100:	cf 93       	push	r28
     102:	df 93       	push	r29
     104:	1f 92       	push	r1
     106:	cd b7       	in	r28, 0x3d	; 61
     108:	de b7       	in	r29, 0x3e	; 62
	volatile char ch;

	ch = *( char *) pvParameters; // parametri = kirjoitettava merkki
     10a:	fc 01       	movw	r30, r24
     10c:	80 81       	ld	r24, Z
     10e:	89 83       	std	Y+1, r24	; 0x01

	// taskilla tulee aina  olla ikisilmukka
	for( ;; )
	{
		xSerialPutChar( 0, ch, 0 ); // kirjoitetaan merkki kuvaruudulle
     110:	69 81       	ldd	r22, Y+1	; 0x01
     112:	40 e0       	ldi	r20, 0x00	; 0
     114:	50 e0       	ldi	r21, 0x00	; 0
     116:	80 e0       	ldi	r24, 0x00	; 0
     118:	90 e0       	ldi	r25, 0x00	; 0
     11a:	0e 94 24 09 	call	0x1248	; 0x1248 <xSerialPutChar>

		DoCalculate(500); // "application"
     11e:	84 ef       	ldi	r24, 0xF4	; 244
     120:	91 e0       	ldi	r25, 0x01	; 1
     122:	0e 94 53 00 	call	0xa6	; 0xa6 <DoCalculate>
     126:	f4 cf       	rjmp	.-24     	; 0x110 <vWriter3+0x10>

00000128 <vWriter2>:

		DoCalculate(500); // "application"
	}
}
static void vWriter2( void *pvParameters )
{
     128:	cf 93       	push	r28
     12a:	df 93       	push	r29
     12c:	1f 92       	push	r1
     12e:	cd b7       	in	r28, 0x3d	; 61
     130:	de b7       	in	r29, 0x3e	; 62
	volatile char ch;

	ch = *( char *) pvParameters; // parametri = kirjoitettava merkki
     132:	fc 01       	movw	r30, r24
     134:	80 81       	ld	r24, Z
     136:	89 83       	std	Y+1, r24	; 0x01

	// taskilla tulee aina  olla ikisilmukka
	for( ;; )
	{
		xSerialPutChar( 0, ch, 0 ); // kirjoitetaan merkki kuvaruudulle
     138:	69 81       	ldd	r22, Y+1	; 0x01
     13a:	40 e0       	ldi	r20, 0x00	; 0
     13c:	50 e0       	ldi	r21, 0x00	; 0
     13e:	80 e0       	ldi	r24, 0x00	; 0
     140:	90 e0       	ldi	r25, 0x00	; 0
     142:	0e 94 24 09 	call	0x1248	; 0x1248 <xSerialPutChar>

		DoCalculate(500); // "application"
     146:	84 ef       	ldi	r24, 0xF4	; 244
     148:	91 e0       	ldi	r25, 0x01	; 1
     14a:	0e 94 53 00 	call	0xa6	; 0xa6 <DoCalculate>
     14e:	f4 cf       	rjmp	.-24     	; 0x138 <vWriter2+0x10>

00000150 <vWriter1>:
	return 0;
}
//------ rinnakkain toimivat taskit -------------------------------

static void vWriter1( void *pvParameters )
{
     150:	cf 93       	push	r28
     152:	df 93       	push	r29
     154:	1f 92       	push	r1
     156:	cd b7       	in	r28, 0x3d	; 61
     158:	de b7       	in	r29, 0x3e	; 62
	volatile char ch;

	ch = *( char *) pvParameters; // parametri = kirjoitettava merkki
     15a:	fc 01       	movw	r30, r24
     15c:	80 81       	ld	r24, Z
     15e:	89 83       	std	Y+1, r24	; 0x01

	// taskilla tulee aina  olla ikisilmukka
	for( ;; )
	{
		xSerialPutChar( 0, ch, 0 ); // kirjoitetaan merkki kuvaruudulle
     160:	69 81       	ldd	r22, Y+1	; 0x01
     162:	40 e0       	ldi	r20, 0x00	; 0
     164:	50 e0       	ldi	r21, 0x00	; 0
     166:	80 e0       	ldi	r24, 0x00	; 0
     168:	90 e0       	ldi	r25, 0x00	; 0
     16a:	0e 94 24 09 	call	0x1248	; 0x1248 <xSerialPutChar>

		DoCalculate(500); // "application"
     16e:	84 ef       	ldi	r24, 0xF4	; 244
     170:	91 e0       	ldi	r25, 0x01	; 1
     172:	0e 94 53 00 	call	0xa6	; 0xa6 <DoCalculate>
     176:	f4 cf       	rjmp	.-24     	; 0x160 <vWriter1+0x10>

00000178 <main>:
static void vWriter3( void *pvParameters );

static void DoCalculate(int count);

int main( void )
{
     178:	ef 92       	push	r14
     17a:	ff 92       	push	r15
     17c:	0f 93       	push	r16
     17e:	cf 93       	push	r28
     180:	df 93       	push	r29
     182:	cd b7       	in	r28, 0x3d	; 61
     184:	de b7       	in	r29, 0x3e	; 62
     186:	28 97       	sbiw	r28, 0x08	; 8
     188:	0f b6       	in	r0, 0x3f	; 63
     18a:	f8 94       	cli
     18c:	de bf       	out	0x3e, r29	; 62
     18e:	0f be       	out	0x3f, r0	; 63
     190:	cd bf       	out	0x3d, r28	; 61
	char ch[] = "1234567";
     192:	88 e0       	ldi	r24, 0x08	; 8
     194:	e9 e0       	ldi	r30, 0x09	; 9
     196:	f1 e0       	ldi	r31, 0x01	; 1
     198:	de 01       	movw	r26, r28
     19a:	11 96       	adiw	r26, 0x01	; 1
     19c:	01 90       	ld	r0, Z+
     19e:	0d 92       	st	X+, r0
     1a0:	8a 95       	dec	r24
     1a2:	e1 f7       	brne	.-8      	; 0x19c <main+0x24>
	// alustetaan sarjaportti
	xSerialPortInitMinimal( mainCOM_BAUD_RATE, comBUFFER_LEN );
     1a4:	42 e3       	ldi	r20, 0x32	; 50
     1a6:	60 e0       	ldi	r22, 0x00	; 0
     1a8:	7b e4       	ldi	r23, 0x4B	; 75
     1aa:	80 e0       	ldi	r24, 0x00	; 0
     1ac:	90 e0       	ldi	r25, 0x00	; 0
     1ae:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <xSerialPortInitMinimal>

	// luodaan kirjoitustaskit
	xTaskCreate( vWriter1, ( signed portCHAR * )"W1", configMINIMAL_STACK_SIZE, &ch[0],  (tskIDLE_PRIORITY + 3), NULL );
     1b2:	e1 2c       	mov	r14, r1
     1b4:	f1 2c       	mov	r15, r1
     1b6:	03 e0       	ldi	r16, 0x03	; 3
     1b8:	9e 01       	movw	r18, r28
     1ba:	2f 5f       	subi	r18, 0xFF	; 255
     1bc:	3f 4f       	sbci	r19, 0xFF	; 255
     1be:	45 e5       	ldi	r20, 0x55	; 85
     1c0:	50 e0       	ldi	r21, 0x00	; 0
     1c2:	60 e0       	ldi	r22, 0x00	; 0
     1c4:	71 e0       	ldi	r23, 0x01	; 1
     1c6:	88 ea       	ldi	r24, 0xA8	; 168
     1c8:	90 e0       	ldi	r25, 0x00	; 0
     1ca:	0e 94 1b 05 	call	0xa36	; 0xa36 <xTaskCreate>
	xTaskCreate( vWriter2, ( signed portCHAR * )"W2", configMINIMAL_STACK_SIZE, &ch[1],  (tskIDLE_PRIORITY + 3), NULL );
     1ce:	9e 01       	movw	r18, r28
     1d0:	2e 5f       	subi	r18, 0xFE	; 254
     1d2:	3f 4f       	sbci	r19, 0xFF	; 255
     1d4:	45 e5       	ldi	r20, 0x55	; 85
     1d6:	50 e0       	ldi	r21, 0x00	; 0
     1d8:	63 e0       	ldi	r22, 0x03	; 3
     1da:	71 e0       	ldi	r23, 0x01	; 1
     1dc:	84 e9       	ldi	r24, 0x94	; 148
     1de:	90 e0       	ldi	r25, 0x00	; 0
     1e0:	0e 94 1b 05 	call	0xa36	; 0xa36 <xTaskCreate>
	xTaskCreate( vWriter3, ( signed portCHAR * )"W3", configMINIMAL_STACK_SIZE, &ch[2],  (tskIDLE_PRIORITY + 3), NULL );
     1e4:	9e 01       	movw	r18, r28
     1e6:	2d 5f       	subi	r18, 0xFD	; 253
     1e8:	3f 4f       	sbci	r19, 0xFF	; 255
     1ea:	45 e5       	ldi	r20, 0x55	; 85
     1ec:	50 e0       	ldi	r21, 0x00	; 0
     1ee:	66 e0       	ldi	r22, 0x06	; 6
     1f0:	71 e0       	ldi	r23, 0x01	; 1
     1f2:	80 e8       	ldi	r24, 0x80	; 128
     1f4:	90 e0       	ldi	r25, 0x00	; 0
     1f6:	0e 94 1b 05 	call	0xa36	; 0xa36 <xTaskCreate>

	vTaskStartScheduler();  // ajastus päälle
     1fa:	0e 94 08 06 	call	0xc10	; 0xc10 <vTaskStartScheduler>

	return 0;
}
     1fe:	80 e0       	ldi	r24, 0x00	; 0
     200:	90 e0       	ldi	r25, 0x00	; 0
     202:	28 96       	adiw	r28, 0x08	; 8
     204:	0f b6       	in	r0, 0x3f	; 63
     206:	f8 94       	cli
     208:	de bf       	out	0x3e, r29	; 62
     20a:	0f be       	out	0x3f, r0	; 63
     20c:	cd bf       	out	0x3d, r28	; 61
     20e:	df 91       	pop	r29
     210:	cf 91       	pop	r28
     212:	0f 91       	pop	r16
     214:	ff 90       	pop	r15
     216:	ef 90       	pop	r14
     218:	08 95       	ret

0000021a <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     21a:	cf 93       	push	r28
     21c:	df 93       	push	r29
     21e:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & heapBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     220:	0e 94 27 06 	call	0xc4e	; 0xc4e <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     224:	40 91 16 01 	lds	r20, 0x0116
     228:	50 91 17 01 	lds	r21, 0x0117
     22c:	9e 01       	movw	r18, r28
     22e:	24 0f       	add	r18, r20
     230:	35 1f       	adc	r19, r21
     232:	28 3e       	cpi	r18, 0xE8	; 232
     234:	83 e0       	ldi	r24, 0x03	; 3
     236:	38 07       	cpc	r19, r24
     238:	58 f4       	brcc	.+22     	; 0x250 <pvPortMalloc+0x36>
     23a:	42 17       	cp	r20, r18
     23c:	53 07       	cpc	r21, r19
     23e:	58 f4       	brcc	.+22     	; 0x256 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     240:	ea 01       	movw	r28, r20
     242:	c4 5e       	subi	r28, 0xE4	; 228
     244:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
     246:	30 93 17 01 	sts	0x0117, r19
     24a:	20 93 16 01 	sts	0x0116, r18
     24e:	05 c0       	rjmp	.+10     	; 0x25a <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     250:	c0 e0       	ldi	r28, 0x00	; 0
     252:	d0 e0       	ldi	r29, 0x00	; 0
     254:	02 c0       	rjmp	.+4      	; 0x25a <pvPortMalloc+0x40>
     256:	c0 e0       	ldi	r28, 0x00	; 0
     258:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     25a:	0e 94 32 06 	call	0xc64	; 0xc64 <xTaskResumeAll>

	return pvReturn;
}
     25e:	ce 01       	movw	r24, r28
     260:	df 91       	pop	r29
     262:	cf 91       	pop	r28
     264:	08 95       	ret

00000266 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     266:	08 95       	ret

00000268 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     268:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     26a:	03 96       	adiw	r24, 0x03	; 3
     26c:	92 83       	std	Z+2, r25	; 0x02
     26e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     270:	2f ef       	ldi	r18, 0xFF	; 255
     272:	3f ef       	ldi	r19, 0xFF	; 255
     274:	34 83       	std	Z+4, r19	; 0x04
     276:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     278:	96 83       	std	Z+6, r25	; 0x06
     27a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     27c:	90 87       	std	Z+8, r25	; 0x08
     27e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = 0;
     280:	10 82       	st	Z, r1
     282:	08 95       	ret

00000284 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     284:	fc 01       	movw	r30, r24
     286:	11 86       	std	Z+9, r1	; 0x09
     288:	10 86       	std	Z+8, r1	; 0x08
     28a:	08 95       	ret

0000028c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     28c:	cf 93       	push	r28
     28e:	df 93       	push	r29
     290:	fc 01       	movw	r30, r24
     292:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     294:	21 81       	ldd	r18, Z+1	; 0x01
     296:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     298:	e9 01       	movw	r28, r18
     29a:	8a 81       	ldd	r24, Y+2	; 0x02
     29c:	9b 81       	ldd	r25, Y+3	; 0x03
     29e:	13 96       	adiw	r26, 0x03	; 3
     2a0:	9c 93       	st	X, r25
     2a2:	8e 93       	st	-X, r24
     2a4:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     2a6:	81 81       	ldd	r24, Z+1	; 0x01
     2a8:	92 81       	ldd	r25, Z+2	; 0x02
     2aa:	15 96       	adiw	r26, 0x05	; 5
     2ac:	9c 93       	st	X, r25
     2ae:	8e 93       	st	-X, r24
     2b0:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     2b2:	8a 81       	ldd	r24, Y+2	; 0x02
     2b4:	9b 81       	ldd	r25, Y+3	; 0x03
     2b6:	ec 01       	movw	r28, r24
     2b8:	7d 83       	std	Y+5, r23	; 0x05
     2ba:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     2bc:	e9 01       	movw	r28, r18
     2be:	7b 83       	std	Y+3, r23	; 0x03
     2c0:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     2c2:	72 83       	std	Z+2, r23	; 0x02
     2c4:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2c6:	19 96       	adiw	r26, 0x09	; 9
     2c8:	fc 93       	st	X, r31
     2ca:	ee 93       	st	-X, r30
     2cc:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     2ce:	80 81       	ld	r24, Z
     2d0:	8f 5f       	subi	r24, 0xFF	; 255
     2d2:	80 83       	st	Z, r24
}
     2d4:	df 91       	pop	r29
     2d6:	cf 91       	pop	r28
     2d8:	08 95       	ret

000002da <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     2da:	cf 93       	push	r28
     2dc:	df 93       	push	r29
     2de:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     2e0:	48 81       	ld	r20, Y
     2e2:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     2e4:	4f 3f       	cpi	r20, 0xFF	; 255
     2e6:	2f ef       	ldi	r18, 0xFF	; 255
     2e8:	52 07       	cpc	r21, r18
     2ea:	31 f4       	brne	.+12     	; 0x2f8 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2ec:	dc 01       	movw	r26, r24
     2ee:	17 96       	adiw	r26, 0x07	; 7
     2f0:	ed 91       	ld	r30, X+
     2f2:	fc 91       	ld	r31, X
     2f4:	18 97       	sbiw	r26, 0x08	; 8
     2f6:	17 c0       	rjmp	.+46     	; 0x326 <vListInsert+0x4c>
	}
	else
	{
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     2f8:	fc 01       	movw	r30, r24
     2fa:	33 96       	adiw	r30, 0x03	; 3
     2fc:	dc 01       	movw	r26, r24
     2fe:	15 96       	adiw	r26, 0x05	; 5
     300:	2d 91       	ld	r18, X+
     302:	3c 91       	ld	r19, X
     304:	16 97       	sbiw	r26, 0x06	; 6
     306:	d9 01       	movw	r26, r18
     308:	2d 91       	ld	r18, X+
     30a:	3c 91       	ld	r19, X
     30c:	42 17       	cp	r20, r18
     30e:	53 07       	cpc	r21, r19
     310:	50 f0       	brcs	.+20     	; 0x326 <vListInsert+0x4c>
     312:	02 80       	ldd	r0, Z+2	; 0x02
     314:	f3 81       	ldd	r31, Z+3	; 0x03
     316:	e0 2d       	mov	r30, r0
     318:	a2 81       	ldd	r26, Z+2	; 0x02
     31a:	b3 81       	ldd	r27, Z+3	; 0x03
     31c:	2d 91       	ld	r18, X+
     31e:	3c 91       	ld	r19, X
     320:	42 17       	cp	r20, r18
     322:	53 07       	cpc	r21, r19
     324:	b0 f7       	brcc	.-20     	; 0x312 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     326:	a2 81       	ldd	r26, Z+2	; 0x02
     328:	b3 81       	ldd	r27, Z+3	; 0x03
     32a:	bb 83       	std	Y+3, r27	; 0x03
     32c:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     32e:	15 96       	adiw	r26, 0x05	; 5
     330:	dc 93       	st	X, r29
     332:	ce 93       	st	-X, r28
     334:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     336:	fd 83       	std	Y+5, r31	; 0x05
     338:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     33a:	d3 83       	std	Z+3, r29	; 0x03
     33c:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     33e:	99 87       	std	Y+9, r25	; 0x09
     340:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     342:	fc 01       	movw	r30, r24
     344:	20 81       	ld	r18, Z
     346:	2f 5f       	subi	r18, 0xFF	; 255
     348:	20 83       	st	Z, r18
}
     34a:	df 91       	pop	r29
     34c:	cf 91       	pop	r28
     34e:	08 95       	ret

00000350 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     350:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     352:	a2 81       	ldd	r26, Z+2	; 0x02
     354:	b3 81       	ldd	r27, Z+3	; 0x03
     356:	84 81       	ldd	r24, Z+4	; 0x04
     358:	95 81       	ldd	r25, Z+5	; 0x05
     35a:	15 96       	adiw	r26, 0x05	; 5
     35c:	9c 93       	st	X, r25
     35e:	8e 93       	st	-X, r24
     360:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     362:	a4 81       	ldd	r26, Z+4	; 0x04
     364:	b5 81       	ldd	r27, Z+5	; 0x05
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	13 96       	adiw	r26, 0x03	; 3
     36c:	9c 93       	st	X, r25
     36e:	8e 93       	st	-X, r24
     370:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     372:	a0 85       	ldd	r26, Z+8	; 0x08
     374:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     376:	11 96       	adiw	r26, 0x01	; 1
     378:	8d 91       	ld	r24, X+
     37a:	9c 91       	ld	r25, X
     37c:	12 97       	sbiw	r26, 0x02	; 2
     37e:	8e 17       	cp	r24, r30
     380:	9f 07       	cpc	r25, r31
     382:	31 f4       	brne	.+12     	; 0x390 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     384:	84 81       	ldd	r24, Z+4	; 0x04
     386:	95 81       	ldd	r25, Z+5	; 0x05
     388:	12 96       	adiw	r26, 0x02	; 2
     38a:	9c 93       	st	X, r25
     38c:	8e 93       	st	-X, r24
     38e:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     390:	11 86       	std	Z+9, r1	; 0x09
     392:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     394:	8c 91       	ld	r24, X
     396:	81 50       	subi	r24, 0x01	; 1
     398:	8c 93       	st	X, r24
     39a:	08 95       	ret

0000039c <pxPortInitialiseStack>:
unsigned portSHORT usAddress;

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     39c:	31 e1       	ldi	r19, 0x11	; 17
     39e:	fc 01       	movw	r30, r24
     3a0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     3a2:	31 97       	sbiw	r30, 0x01	; 1
     3a4:	22 e2       	ldi	r18, 0x22	; 34
     3a6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     3a8:	31 97       	sbiw	r30, 0x01	; 1
     3aa:	a3 e3       	ldi	r26, 0x33	; 51
     3ac:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     3ae:	31 97       	sbiw	r30, 0x01	; 1
     3b0:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     3b2:	31 97       	sbiw	r30, 0x01	; 1
     3b4:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     3b6:	31 97       	sbiw	r30, 0x01	; 1
     3b8:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     3ba:	31 97       	sbiw	r30, 0x01	; 1
     3bc:	60 e8       	ldi	r22, 0x80	; 128
     3be:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     3c0:	31 97       	sbiw	r30, 0x01	; 1
     3c2:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     3c4:	31 97       	sbiw	r30, 0x01	; 1
     3c6:	62 e0       	ldi	r22, 0x02	; 2
     3c8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     3ca:	31 97       	sbiw	r30, 0x01	; 1
     3cc:	63 e0       	ldi	r22, 0x03	; 3
     3ce:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     3d0:	31 97       	sbiw	r30, 0x01	; 1
     3d2:	64 e0       	ldi	r22, 0x04	; 4
     3d4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     3d6:	31 97       	sbiw	r30, 0x01	; 1
     3d8:	65 e0       	ldi	r22, 0x05	; 5
     3da:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     3dc:	31 97       	sbiw	r30, 0x01	; 1
     3de:	66 e0       	ldi	r22, 0x06	; 6
     3e0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     3e2:	31 97       	sbiw	r30, 0x01	; 1
     3e4:	67 e0       	ldi	r22, 0x07	; 7
     3e6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     3e8:	31 97       	sbiw	r30, 0x01	; 1
     3ea:	68 e0       	ldi	r22, 0x08	; 8
     3ec:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     3ee:	31 97       	sbiw	r30, 0x01	; 1
     3f0:	69 e0       	ldi	r22, 0x09	; 9
     3f2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     3f4:	31 97       	sbiw	r30, 0x01	; 1
     3f6:	60 e1       	ldi	r22, 0x10	; 16
     3f8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     3fa:	31 97       	sbiw	r30, 0x01	; 1
     3fc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     3fe:	31 97       	sbiw	r30, 0x01	; 1
     400:	32 e1       	ldi	r19, 0x12	; 18
     402:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     404:	31 97       	sbiw	r30, 0x01	; 1
     406:	33 e1       	ldi	r19, 0x13	; 19
     408:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     40a:	31 97       	sbiw	r30, 0x01	; 1
     40c:	34 e1       	ldi	r19, 0x14	; 20
     40e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     410:	31 97       	sbiw	r30, 0x01	; 1
     412:	35 e1       	ldi	r19, 0x15	; 21
     414:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     416:	31 97       	sbiw	r30, 0x01	; 1
     418:	36 e1       	ldi	r19, 0x16	; 22
     41a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     41c:	31 97       	sbiw	r30, 0x01	; 1
     41e:	37 e1       	ldi	r19, 0x17	; 23
     420:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     422:	31 97       	sbiw	r30, 0x01	; 1
     424:	38 e1       	ldi	r19, 0x18	; 24
     426:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     428:	31 97       	sbiw	r30, 0x01	; 1
     42a:	39 e1       	ldi	r19, 0x19	; 25
     42c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     42e:	31 97       	sbiw	r30, 0x01	; 1
     430:	30 e2       	ldi	r19, 0x20	; 32
     432:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     434:	31 97       	sbiw	r30, 0x01	; 1
     436:	31 e2       	ldi	r19, 0x21	; 33
     438:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     43a:	31 97       	sbiw	r30, 0x01	; 1
     43c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     43e:	31 97       	sbiw	r30, 0x01	; 1
     440:	23 e2       	ldi	r18, 0x23	; 35
     442:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned portSHORT ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     444:	31 97       	sbiw	r30, 0x01	; 1
     446:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     448:	31 97       	sbiw	r30, 0x01	; 1
     44a:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     44c:	31 97       	sbiw	r30, 0x01	; 1
     44e:	26 e2       	ldi	r18, 0x26	; 38
     450:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     452:	31 97       	sbiw	r30, 0x01	; 1
     454:	27 e2       	ldi	r18, 0x27	; 39
     456:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     458:	31 97       	sbiw	r30, 0x01	; 1
     45a:	28 e2       	ldi	r18, 0x28	; 40
     45c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     45e:	31 97       	sbiw	r30, 0x01	; 1
     460:	29 e2       	ldi	r18, 0x29	; 41
     462:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     464:	31 97       	sbiw	r30, 0x01	; 1
     466:	20 e3       	ldi	r18, 0x30	; 48
     468:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     46a:	31 97       	sbiw	r30, 0x01	; 1
     46c:	21 e3       	ldi	r18, 0x31	; 49
     46e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     470:	86 97       	sbiw	r24, 0x26	; 38
     472:	08 95       	ret

00000474 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
	OCR1AH = ucHighByte;
     474:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     478:	89 ef       	ldi	r24, 0xF9	; 249
     47a:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     47e:	8b e0       	ldi	r24, 0x0B	; 11
     480:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     484:	ef e6       	ldi	r30, 0x6F	; 111
     486:	f0 e0       	ldi	r31, 0x00	; 0
     488:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     48a:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     48c:	80 83       	st	Z, r24

	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     48e:	a0 91 75 05 	lds	r26, 0x0575
     492:	b0 91 76 05 	lds	r27, 0x0576
     496:	cd 91       	ld	r28, X+
     498:	cd bf       	out	0x3d, r28	; 61
     49a:	dd 91       	ld	r29, X+
     49c:	de bf       	out	0x3e, r29	; 62
     49e:	ff 91       	pop	r31
     4a0:	ef 91       	pop	r30
     4a2:	df 91       	pop	r29
     4a4:	cf 91       	pop	r28
     4a6:	bf 91       	pop	r27
     4a8:	af 91       	pop	r26
     4aa:	9f 91       	pop	r25
     4ac:	8f 91       	pop	r24
     4ae:	7f 91       	pop	r23
     4b0:	6f 91       	pop	r22
     4b2:	5f 91       	pop	r21
     4b4:	4f 91       	pop	r20
     4b6:	3f 91       	pop	r19
     4b8:	2f 91       	pop	r18
     4ba:	1f 91       	pop	r17
     4bc:	0f 91       	pop	r16
     4be:	ff 90       	pop	r15
     4c0:	ef 90       	pop	r14
     4c2:	df 90       	pop	r13
     4c4:	cf 90       	pop	r12
     4c6:	bf 90       	pop	r11
     4c8:	af 90       	pop	r10
     4ca:	9f 90       	pop	r9
     4cc:	8f 90       	pop	r8
     4ce:	7f 90       	pop	r7
     4d0:	6f 90       	pop	r6
     4d2:	5f 90       	pop	r5
     4d4:	4f 90       	pop	r4
     4d6:	3f 90       	pop	r3
     4d8:	2f 90       	pop	r2
     4da:	1f 90       	pop	r1
     4dc:	0f 90       	pop	r0
     4de:	0f be       	out	0x3f, r0	; 63
     4e0:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     4e2:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     4e4:	81 e0       	ldi	r24, 0x01	; 1
     4e6:	08 95       	ret

000004e8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     4e8:	0f 92       	push	r0
     4ea:	0f b6       	in	r0, 0x3f	; 63
     4ec:	f8 94       	cli
     4ee:	0f 92       	push	r0
     4f0:	1f 92       	push	r1
     4f2:	11 24       	eor	r1, r1
     4f4:	2f 92       	push	r2
     4f6:	3f 92       	push	r3
     4f8:	4f 92       	push	r4
     4fa:	5f 92       	push	r5
     4fc:	6f 92       	push	r6
     4fe:	7f 92       	push	r7
     500:	8f 92       	push	r8
     502:	9f 92       	push	r9
     504:	af 92       	push	r10
     506:	bf 92       	push	r11
     508:	cf 92       	push	r12
     50a:	df 92       	push	r13
     50c:	ef 92       	push	r14
     50e:	ff 92       	push	r15
     510:	0f 93       	push	r16
     512:	1f 93       	push	r17
     514:	2f 93       	push	r18
     516:	3f 93       	push	r19
     518:	4f 93       	push	r20
     51a:	5f 93       	push	r21
     51c:	6f 93       	push	r22
     51e:	7f 93       	push	r23
     520:	8f 93       	push	r24
     522:	9f 93       	push	r25
     524:	af 93       	push	r26
     526:	bf 93       	push	r27
     528:	cf 93       	push	r28
     52a:	df 93       	push	r29
     52c:	ef 93       	push	r30
     52e:	ff 93       	push	r31
     530:	a0 91 75 05 	lds	r26, 0x0575
     534:	b0 91 76 05 	lds	r27, 0x0576
     538:	0d b6       	in	r0, 0x3d	; 61
     53a:	0d 92       	st	X+, r0
     53c:	0e b6       	in	r0, 0x3e	; 62
     53e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     540:	0e 94 ab 07 	call	0xf56	; 0xf56 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     544:	a0 91 75 05 	lds	r26, 0x0575
     548:	b0 91 76 05 	lds	r27, 0x0576
     54c:	cd 91       	ld	r28, X+
     54e:	cd bf       	out	0x3d, r28	; 61
     550:	dd 91       	ld	r29, X+
     552:	de bf       	out	0x3e, r29	; 62
     554:	ff 91       	pop	r31
     556:	ef 91       	pop	r30
     558:	df 91       	pop	r29
     55a:	cf 91       	pop	r28
     55c:	bf 91       	pop	r27
     55e:	af 91       	pop	r26
     560:	9f 91       	pop	r25
     562:	8f 91       	pop	r24
     564:	7f 91       	pop	r23
     566:	6f 91       	pop	r22
     568:	5f 91       	pop	r21
     56a:	4f 91       	pop	r20
     56c:	3f 91       	pop	r19
     56e:	2f 91       	pop	r18
     570:	1f 91       	pop	r17
     572:	0f 91       	pop	r16
     574:	ff 90       	pop	r15
     576:	ef 90       	pop	r14
     578:	df 90       	pop	r13
     57a:	cf 90       	pop	r12
     57c:	bf 90       	pop	r11
     57e:	af 90       	pop	r10
     580:	9f 90       	pop	r9
     582:	8f 90       	pop	r8
     584:	7f 90       	pop	r7
     586:	6f 90       	pop	r6
     588:	5f 90       	pop	r5
     58a:	4f 90       	pop	r4
     58c:	3f 90       	pop	r3
     58e:	2f 90       	pop	r2
     590:	1f 90       	pop	r1
     592:	0f 90       	pop	r0
     594:	0f be       	out	0x3f, r0	; 63
     596:	0f 90       	pop	r0

	asm volatile ( "ret" );
     598:	08 95       	ret

0000059a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     59a:	0f 92       	push	r0
     59c:	0f b6       	in	r0, 0x3f	; 63
     59e:	f8 94       	cli
     5a0:	0f 92       	push	r0
     5a2:	1f 92       	push	r1
     5a4:	11 24       	eor	r1, r1
     5a6:	2f 92       	push	r2
     5a8:	3f 92       	push	r3
     5aa:	4f 92       	push	r4
     5ac:	5f 92       	push	r5
     5ae:	6f 92       	push	r6
     5b0:	7f 92       	push	r7
     5b2:	8f 92       	push	r8
     5b4:	9f 92       	push	r9
     5b6:	af 92       	push	r10
     5b8:	bf 92       	push	r11
     5ba:	cf 92       	push	r12
     5bc:	df 92       	push	r13
     5be:	ef 92       	push	r14
     5c0:	ff 92       	push	r15
     5c2:	0f 93       	push	r16
     5c4:	1f 93       	push	r17
     5c6:	2f 93       	push	r18
     5c8:	3f 93       	push	r19
     5ca:	4f 93       	push	r20
     5cc:	5f 93       	push	r21
     5ce:	6f 93       	push	r22
     5d0:	7f 93       	push	r23
     5d2:	8f 93       	push	r24
     5d4:	9f 93       	push	r25
     5d6:	af 93       	push	r26
     5d8:	bf 93       	push	r27
     5da:	cf 93       	push	r28
     5dc:	df 93       	push	r29
     5de:	ef 93       	push	r30
     5e0:	ff 93       	push	r31
     5e2:	a0 91 75 05 	lds	r26, 0x0575
     5e6:	b0 91 76 05 	lds	r27, 0x0576
     5ea:	0d b6       	in	r0, 0x3d	; 61
     5ec:	0d 92       	st	X+, r0
     5ee:	0e b6       	in	r0, 0x3e	; 62
     5f0:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     5f2:	0e 94 33 07 	call	0xe66	; 0xe66 <vTaskIncrementTick>
	vTaskSwitchContext();
     5f6:	0e 94 ab 07 	call	0xf56	; 0xf56 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     5fa:	a0 91 75 05 	lds	r26, 0x0575
     5fe:	b0 91 76 05 	lds	r27, 0x0576
     602:	cd 91       	ld	r28, X+
     604:	cd bf       	out	0x3d, r28	; 61
     606:	dd 91       	ld	r29, X+
     608:	de bf       	out	0x3e, r29	; 62
     60a:	ff 91       	pop	r31
     60c:	ef 91       	pop	r30
     60e:	df 91       	pop	r29
     610:	cf 91       	pop	r28
     612:	bf 91       	pop	r27
     614:	af 91       	pop	r26
     616:	9f 91       	pop	r25
     618:	8f 91       	pop	r24
     61a:	7f 91       	pop	r23
     61c:	6f 91       	pop	r22
     61e:	5f 91       	pop	r21
     620:	4f 91       	pop	r20
     622:	3f 91       	pop	r19
     624:	2f 91       	pop	r18
     626:	1f 91       	pop	r17
     628:	0f 91       	pop	r16
     62a:	ff 90       	pop	r15
     62c:	ef 90       	pop	r14
     62e:	df 90       	pop	r13
     630:	cf 90       	pop	r12
     632:	bf 90       	pop	r11
     634:	af 90       	pop	r10
     636:	9f 90       	pop	r9
     638:	8f 90       	pop	r8
     63a:	7f 90       	pop	r7
     63c:	6f 90       	pop	r6
     63e:	5f 90       	pop	r5
     640:	4f 90       	pop	r4
     642:	3f 90       	pop	r3
     644:	2f 90       	pop	r2
     646:	1f 90       	pop	r1
     648:	0f 90       	pop	r0
     64a:	0f be       	out	0x3f, r0	; 63
     64c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     64e:	08 95       	ret

00000650 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     650:	0e 94 cd 02 	call	0x59a	; 0x59a <vPortYieldFromTick>
		asm volatile ( "reti" );
     654:	18 95       	reti

00000656 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     656:	cf 93       	push	r28
     658:	df 93       	push	r29
     65a:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == 0 )
     65c:	8c 8d       	ldd	r24, Y+28	; 0x1c
     65e:	88 23       	and	r24, r24
     660:	a9 f1       	breq	.+106    	; 0x6cc <prvCopyDataToQueue+0x76>
				vTaskPriorityDisinherit( ( void * const ) pxQueue->pxMutexHolder );
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     662:	41 11       	cpse	r20, r1
     664:	17 c0       	rjmp	.+46     	; 0x694 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     666:	48 2f       	mov	r20, r24
     668:	50 e0       	ldi	r21, 0x00	; 0
     66a:	8c 81       	ldd	r24, Y+4	; 0x04
     66c:	9d 81       	ldd	r25, Y+5	; 0x05
     66e:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     672:	2c 8d       	ldd	r18, Y+28	; 0x1c
     674:	8c 81       	ldd	r24, Y+4	; 0x04
     676:	9d 81       	ldd	r25, Y+5	; 0x05
     678:	82 0f       	add	r24, r18
     67a:	91 1d       	adc	r25, r1
     67c:	9d 83       	std	Y+5, r25	; 0x05
     67e:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     680:	2a 81       	ldd	r18, Y+2	; 0x02
     682:	3b 81       	ldd	r19, Y+3	; 0x03
     684:	82 17       	cp	r24, r18
     686:	93 07       	cpc	r25, r19
     688:	08 f1       	brcs	.+66     	; 0x6cc <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     68a:	88 81       	ld	r24, Y
     68c:	99 81       	ldd	r25, Y+1	; 0x01
     68e:	9d 83       	std	Y+5, r25	; 0x05
     690:	8c 83       	std	Y+4, r24	; 0x04
     692:	1c c0       	rjmp	.+56     	; 0x6cc <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     694:	48 2f       	mov	r20, r24
     696:	50 e0       	ldi	r21, 0x00	; 0
     698:	8e 81       	ldd	r24, Y+6	; 0x06
     69a:	9f 81       	ldd	r25, Y+7	; 0x07
     69c:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     6a0:	2c 8d       	ldd	r18, Y+28	; 0x1c
     6a2:	30 e0       	ldi	r19, 0x00	; 0
     6a4:	31 95       	neg	r19
     6a6:	21 95       	neg	r18
     6a8:	31 09       	sbc	r19, r1
     6aa:	8e 81       	ldd	r24, Y+6	; 0x06
     6ac:	9f 81       	ldd	r25, Y+7	; 0x07
     6ae:	82 0f       	add	r24, r18
     6b0:	93 1f       	adc	r25, r19
     6b2:	9f 83       	std	Y+7, r25	; 0x07
     6b4:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     6b6:	48 81       	ld	r20, Y
     6b8:	59 81       	ldd	r21, Y+1	; 0x01
     6ba:	84 17       	cp	r24, r20
     6bc:	95 07       	cpc	r25, r21
     6be:	30 f4       	brcc	.+12     	; 0x6cc <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     6c0:	8a 81       	ldd	r24, Y+2	; 0x02
     6c2:	9b 81       	ldd	r25, Y+3	; 0x03
     6c4:	28 0f       	add	r18, r24
     6c6:	39 1f       	adc	r19, r25
     6c8:	3f 83       	std	Y+7, r19	; 0x07
     6ca:	2e 83       	std	Y+6, r18	; 0x06
		}		
	}

	++( pxQueue->uxMessagesWaiting );
     6cc:	8a 8d       	ldd	r24, Y+26	; 0x1a
     6ce:	8f 5f       	subi	r24, 0xFF	; 255
     6d0:	8a 8f       	std	Y+26, r24	; 0x1a
}
     6d2:	df 91       	pop	r29
     6d4:	cf 91       	pop	r28
     6d6:	08 95       	ret

000006d8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     6d8:	fc 01       	movw	r30, r24
     6da:	cb 01       	movw	r24, r22
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     6dc:	a0 81       	ld	r26, Z
     6de:	b1 81       	ldd	r27, Z+1	; 0x01
     6e0:	10 97       	sbiw	r26, 0x00	; 0
     6e2:	99 f0       	breq	.+38     	; 0x70a <prvCopyDataFromQueue+0x32>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     6e4:	44 8d       	ldd	r20, Z+28	; 0x1c
     6e6:	50 e0       	ldi	r21, 0x00	; 0
     6e8:	26 81       	ldd	r18, Z+6	; 0x06
     6ea:	37 81       	ldd	r19, Z+7	; 0x07
     6ec:	24 0f       	add	r18, r20
     6ee:	35 1f       	adc	r19, r21
     6f0:	37 83       	std	Z+7, r19	; 0x07
     6f2:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     6f4:	62 81       	ldd	r22, Z+2	; 0x02
     6f6:	73 81       	ldd	r23, Z+3	; 0x03
     6f8:	26 17       	cp	r18, r22
     6fa:	37 07       	cpc	r19, r23
     6fc:	10 f0       	brcs	.+4      	; 0x702 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     6fe:	b7 83       	std	Z+7, r27	; 0x07
     700:	a6 83       	std	Z+6, r26	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     702:	66 81       	ldd	r22, Z+6	; 0x06
     704:	77 81       	ldd	r23, Z+7	; 0x07
     706:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <memcpy>
     70a:	08 95       	ret

0000070c <prvUnlockQueue>:
	}	
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29
     710:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     712:	0f b6       	in	r0, 0x3f	; 63
     714:	f8 94       	cli
     716:	0f 92       	push	r0
	{
		--( pxQueue->xTxLock );
     718:	8e 8d       	ldd	r24, Y+30	; 0x1e
     71a:	81 50       	subi	r24, 0x01	; 1

		/* See if data was added to the queue while it was locked. */
		if( pxQueue->xTxLock > queueUNLOCKED )
     71c:	12 f4       	brpl	.+4      	; 0x722 <prvUnlockQueue+0x16>
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		--( pxQueue->xTxLock );
     71e:	8e 8f       	std	Y+30, r24	; 0x1e
     720:	0c c0       	rjmp	.+24     	; 0x73a <prvUnlockQueue+0x2e>

		/* See if data was added to the queue while it was locked. */
		if( pxQueue->xTxLock > queueUNLOCKED )
		{
			pxQueue->xTxLock = queueUNLOCKED;
     722:	8f ef       	ldi	r24, 0xFF	; 255
     724:	8e 8f       	std	Y+30, r24	; 0x1e

			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     726:	89 89       	ldd	r24, Y+17	; 0x11
     728:	88 23       	and	r24, r24
     72a:	39 f0       	breq	.+14     	; 0x73a <prvUnlockQueue+0x2e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     72c:	ce 01       	movw	r24, r28
     72e:	41 96       	adiw	r24, 0x11	; 17
     730:	0e 94 49 08 	call	0x1092	; 0x1092 <xTaskRemoveFromEventList>
     734:	81 11       	cpse	r24, r1
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     736:	0e 94 d4 08 	call	0x11a8	; 0x11a8 <vTaskMissedYield>
				}
			}			
		}
	}
	taskEXIT_CRITICAL();
     73a:	0f 90       	pop	r0
     73c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     73e:	0f b6       	in	r0, 0x3f	; 63
     740:	f8 94       	cli
     742:	0f 92       	push	r0
	{
		--( pxQueue->xRxLock );
     744:	8d 8d       	ldd	r24, Y+29	; 0x1d
     746:	81 50       	subi	r24, 0x01	; 1

		if( pxQueue->xRxLock > queueUNLOCKED )
     748:	12 f4       	brpl	.+4      	; 0x74e <prvUnlockQueue+0x42>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		--( pxQueue->xRxLock );
     74a:	8d 8f       	std	Y+29, r24	; 0x1d
     74c:	0c c0       	rjmp	.+24     	; 0x766 <prvUnlockQueue+0x5a>

		if( pxQueue->xRxLock > queueUNLOCKED )
		{
			pxQueue->xRxLock = queueUNLOCKED;
     74e:	8f ef       	ldi	r24, 0xFF	; 255
     750:	8d 8f       	std	Y+29, r24	; 0x1d

			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     752:	88 85       	ldd	r24, Y+8	; 0x08
     754:	88 23       	and	r24, r24
     756:	39 f0       	breq	.+14     	; 0x766 <prvUnlockQueue+0x5a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     758:	ce 01       	movw	r24, r28
     75a:	08 96       	adiw	r24, 0x08	; 8
     75c:	0e 94 49 08 	call	0x1092	; 0x1092 <xTaskRemoveFromEventList>
     760:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     762:	0e 94 d4 08 	call	0x11a8	; 0x11a8 <vTaskMissedYield>
				}
			}			
		}
	}
	taskEXIT_CRITICAL();
     766:	0f 90       	pop	r0
     768:	0f be       	out	0x3f, r0	; 63
}
     76a:	df 91       	pop	r29
     76c:	cf 91       	pop	r28
     76e:	08 95       	ret

00000770 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     770:	cf 92       	push	r12
     772:	df 92       	push	r13
     774:	ef 92       	push	r14
     776:	ff 92       	push	r15
     778:	0f 93       	push	r16
     77a:	1f 93       	push	r17
     77c:	cf 93       	push	r28
     77e:	df 93       	push	r29
     780:	d8 2e       	mov	r13, r24
     782:	c6 2e       	mov	r12, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     784:	88 23       	and	r24, r24
     786:	d9 f1       	breq	.+118    	; 0x7fe <xQueueCreate+0x8e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     788:	8f e1       	ldi	r24, 0x1F	; 31
     78a:	90 e0       	ldi	r25, 0x00	; 0
     78c:	0e 94 0d 01 	call	0x21a	; 0x21a <pvPortMalloc>
     790:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     792:	00 97       	sbiw	r24, 0x00	; 0
     794:	b9 f1       	breq	.+110    	; 0x804 <xQueueCreate+0x94>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     796:	ec 2c       	mov	r14, r12
     798:	f1 2c       	mov	r15, r1
     79a:	de 9c       	mul	r13, r14
     79c:	80 01       	movw	r16, r0
     79e:	df 9c       	mul	r13, r15
     7a0:	10 0d       	add	r17, r0
     7a2:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed portCHAR * ) pvPortMalloc( xQueueSizeInBytes );
     7a4:	c8 01       	movw	r24, r16
     7a6:	01 96       	adiw	r24, 0x01	; 1
     7a8:	0e 94 0d 01 	call	0x21a	; 0x21a <pvPortMalloc>
     7ac:	99 83       	std	Y+1, r25	; 0x01
     7ae:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     7b0:	00 97       	sbiw	r24, 0x00	; 0
     7b2:	f9 f0       	breq	.+62     	; 0x7f2 <xQueueCreate+0x82>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     7b4:	ac 01       	movw	r20, r24
     7b6:	40 0f       	add	r20, r16
     7b8:	51 1f       	adc	r21, r17
     7ba:	5b 83       	std	Y+3, r21	; 0x03
     7bc:	4a 83       	std	Y+2, r20	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
     7be:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     7c0:	9d 83       	std	Y+5, r25	; 0x05
     7c2:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
     7c4:	0e 19       	sub	r16, r14
     7c6:	1f 09       	sbc	r17, r15
     7c8:	9c 01       	movw	r18, r24
     7ca:	20 0f       	add	r18, r16
     7cc:	31 1f       	adc	r19, r17
     7ce:	3f 83       	std	Y+7, r19	; 0x07
     7d0:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
     7d2:	db 8e       	std	Y+27, r13	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     7d4:	cc 8e       	std	Y+28, r12	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
     7d6:	8f ef       	ldi	r24, 0xFF	; 255
     7d8:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
     7da:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     7dc:	ce 01       	movw	r24, r28
     7de:	08 96       	adiw	r24, 0x08	; 8
     7e0:	0e 94 34 01 	call	0x268	; 0x268 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     7e4:	ce 01       	movw	r24, r28
     7e6:	41 96       	adiw	r24, 0x11	; 17
     7e8:	0e 94 34 01 	call	0x268	; 0x268 <vListInitialise>

				return  pxNewQueue;
     7ec:	8c 2f       	mov	r24, r28
     7ee:	9d 2f       	mov	r25, r29
     7f0:	0b c0       	rjmp	.+22     	; 0x808 <xQueueCreate+0x98>
			}
			else
			{
				vPortFree( pxNewQueue );
     7f2:	ce 01       	movw	r24, r28
     7f4:	0e 94 33 01 	call	0x266	; 0x266 <vPortFree>
		}
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
     7f8:	80 e0       	ldi	r24, 0x00	; 0
     7fa:	90 e0       	ldi	r25, 0x00	; 0
     7fc:	05 c0       	rjmp	.+10     	; 0x808 <xQueueCreate+0x98>
     7fe:	80 e0       	ldi	r24, 0x00	; 0
     800:	90 e0       	ldi	r25, 0x00	; 0
     802:	02 c0       	rjmp	.+4      	; 0x808 <xQueueCreate+0x98>
     804:	80 e0       	ldi	r24, 0x00	; 0
     806:	90 e0       	ldi	r25, 0x00	; 0
}
     808:	df 91       	pop	r29
     80a:	cf 91       	pop	r28
     80c:	1f 91       	pop	r17
     80e:	0f 91       	pop	r16
     810:	ff 90       	pop	r15
     812:	ef 90       	pop	r14
     814:	df 90       	pop	r13
     816:	cf 90       	pop	r12
     818:	08 95       	ret

0000081a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     81a:	7f 92       	push	r7
     81c:	8f 92       	push	r8
     81e:	9f 92       	push	r9
     820:	af 92       	push	r10
     822:	bf 92       	push	r11
     824:	cf 92       	push	r12
     826:	df 92       	push	r13
     828:	ef 92       	push	r14
     82a:	ff 92       	push	r15
     82c:	0f 93       	push	r16
     82e:	1f 93       	push	r17
     830:	cf 93       	push	r28
     832:	df 93       	push	r29
     834:	00 d0       	rcall	.+0      	; 0x836 <xQueueGenericSend+0x1c>
     836:	00 d0       	rcall	.+0      	; 0x838 <xQueueGenericSend+0x1e>
     838:	1f 92       	push	r1
     83a:	cd b7       	in	r28, 0x3d	; 61
     83c:	de b7       	in	r29, 0x3e	; 62
     83e:	8c 01       	movw	r16, r24
     840:	6b 01       	movw	r12, r22
     842:	5d 83       	std	Y+5, r21	; 0x05
     844:	4c 83       	std	Y+4, r20	; 0x04
     846:	92 2e       	mov	r9, r18
signed portBASE_TYPE xReturn = pdPASS;
xTimeOutType xTimeOut;

	/* Make sure other tasks do not access the queue. */
	vTaskSuspendAll();
     848:	0e 94 27 06 	call	0xc4e	; 0xc4e <vTaskSuspendAll>

	/* Capture the current time status for future reference. */
	vTaskSetTimeOutState( &xTimeOut );
     84c:	ce 01       	movw	r24, r28
     84e:	01 96       	adiw	r24, 0x01	; 1
     850:	0e 94 94 08 	call	0x1128	; 0x1128 <vTaskSetTimeOutState>
		  suspended.  If so then the TCB being removed from the event is
		  removed from the event and added to the xPendingReadyList.
	*/

	/* Make sure interrupts do not access the queue event list. */
	prvLockQueue( pxQueue );
     854:	0f b6       	in	r0, 0x3f	; 63
     856:	f8 94       	cli
     858:	0f 92       	push	r0
     85a:	f8 01       	movw	r30, r16
     85c:	85 8d       	ldd	r24, Z+29	; 0x1d
     85e:	8f 5f       	subi	r24, 0xFF	; 255
     860:	85 8f       	std	Z+29, r24	; 0x1d
     862:	86 8d       	ldd	r24, Z+30	; 0x1e
     864:	8f 5f       	subi	r24, 0xFF	; 255
     866:	86 8f       	std	Z+30, r24	; 0x1e
     868:	0f 90       	pop	r0
     86a:	0f be       	out	0x3f, r0	; 63
#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
signed portBASE_TYPE xReturn = pdPASS;
     86c:	77 24       	eor	r7, r7
     86e:	73 94       	inc	r7
				It is possible that an ISR has removed data from the queue since we
				checked if any was available.  If this is the case then the data
				will have been copied from the queue, and the queue variables
				updated, but the event list will not yet have been checked to see if
				anything is waiting as the queue is locked. */
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     870:	78 01       	movw	r14, r16
     872:	f8 e0       	ldi	r31, 0x08	; 8
     874:	ef 0e       	add	r14, r31
     876:	f1 1c       	adc	r15, r1
					scheduler gets suspended). */
					if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
					{
						/* We unblocked but there is no space in the queue,
						we probably timed out. */
						xReturn = errQUEUE_FULL;
     878:	b1 2c       	mov	r11, r1
			{
				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
				{
					/* There is room in the queue, copy the data into the queue. */			
					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
					xReturn = pdPASS;
     87a:	aa 24       	eor	r10, r10
     87c:	a3 94       	inc	r10
     87e:	88 24       	eor	r8, r8
     880:	8a 94       	dec	r8

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     882:	0f b6       	in	r0, 0x3f	; 63
     884:	f8 94       	cli
     886:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     888:	f8 01       	movw	r30, r16
     88a:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     88c:	0f 90       	pop	r0
     88e:	0f be       	out	0x3f, r0	; 63
	*/
		
	/* If the queue is already full we may have to block. */
	do
	{
		if( prvIsQueueFull( pxQueue ) )
     890:	f8 01       	movw	r30, r16
     892:	83 8d       	ldd	r24, Z+27	; 0x1b
     894:	98 13       	cpse	r25, r24
     896:	2a c0       	rjmp	.+84     	; 0x8ec <xQueueGenericSend+0xd2>
		{
			/* The queue is full - do we want to block or just leave without
			posting? */
			if( xTicksToWait > ( portTickType ) 0 )
     898:	6c 81       	ldd	r22, Y+4	; 0x04
     89a:	7d 81       	ldd	r23, Y+5	; 0x05
     89c:	61 15       	cp	r22, r1
     89e:	71 05       	cpc	r23, r1
     8a0:	29 f1       	breq	.+74     	; 0x8ec <xQueueGenericSend+0xd2>
				It is possible that an ISR has removed data from the queue since we
				checked if any was available.  If this is the case then the data
				will have been copied from the queue, and the queue variables
				updated, but the event list will not yet have been checked to see if
				anything is waiting as the queue is locked. */
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     8a2:	c7 01       	movw	r24, r14
     8a4:	0e 94 08 08 	call	0x1010	; 0x1010 <vTaskPlaceOnEventList>
				It is possible that an ISR has caused an event on an unrelated and
				unlocked queue.  If this was the case then the event list for that
				queue will have been updated but the ready lists left unchanged -
				instead the readied task will have been added to the pending ready
				list. */
				taskENTER_CRITICAL();
     8a8:	0f b6       	in	r0, 0x3f	; 63
     8aa:	f8 94       	cli
     8ac:	0f 92       	push	r0
					locked, but we can yield from within a critical section.
					
					Tasks that have been placed on the pending ready list cannot
					be tasks that are waiting for events on this queue.  See
					in comment xTaskRemoveFromEventList(). */
					prvUnlockQueue( pxQueue );
     8ae:	c8 01       	movw	r24, r16
     8b0:	0e 94 86 03 	call	0x70c	; 0x70c <prvUnlockQueue>
	
					/* Resuming the scheduler may cause a yield.  If so then there
					is no point yielding again here. */
					if( !xTaskResumeAll() )
     8b4:	0e 94 32 06 	call	0xc64	; 0xc64 <xTaskResumeAll>
     8b8:	81 11       	cpse	r24, r1
     8ba:	02 c0       	rjmp	.+4      	; 0x8c0 <xQueueGenericSend+0xa6>
					{
						taskYIELD();
     8bc:	0e 94 74 02 	call	0x4e8	; 0x4e8 <vPortYield>
					this task placing an item into the queue due to an
					interrupt making space on the queue between critical
					sections (when there might be a higher priority task
					blocked on the queue that cannot run yet because the
					scheduler gets suspended). */
					if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     8c0:	f8 01       	movw	r30, r16
     8c2:	92 8d       	ldd	r25, Z+26	; 0x1a
     8c4:	83 8d       	ldd	r24, Z+27	; 0x1b
     8c6:	98 13       	cpse	r25, r24
     8c8:	01 c0       	rjmp	.+2      	; 0x8cc <xQueueGenericSend+0xb2>
					{
						/* We unblocked but there is no space in the queue,
						we probably timed out. */
						xReturn = errQUEUE_FULL;
     8ca:	7b 2c       	mov	r7, r11
					}
	
					/* Before leaving the critical section we have to ensure
					exclusive access again. */
					vTaskSuspendAll();
     8cc:	0e 94 27 06 	call	0xc4e	; 0xc4e <vTaskSuspendAll>
					prvLockQueue( pxQueue );				
     8d0:	0f b6       	in	r0, 0x3f	; 63
     8d2:	f8 94       	cli
     8d4:	0f 92       	push	r0
     8d6:	f8 01       	movw	r30, r16
     8d8:	85 8d       	ldd	r24, Z+29	; 0x1d
     8da:	8f 5f       	subi	r24, 0xFF	; 255
     8dc:	85 8f       	std	Z+29, r24	; 0x1d
     8de:	86 8d       	ldd	r24, Z+30	; 0x1e
     8e0:	8f 5f       	subi	r24, 0xFF	; 255
     8e2:	86 8f       	std	Z+30, r24	; 0x1e
     8e4:	0f 90       	pop	r0
     8e6:	0f be       	out	0x3f, r0	; 63
				}
				taskEXIT_CRITICAL();
     8e8:	0f 90       	pop	r0
     8ea:	0f be       	out	0x3f, r0	; 63
		an interrupt has removed an item from the queue since we left the
		critical section and we don't want to write to the queue in case
		there is a task of higher priority blocked waiting for space to
		be available on the queue.  If this is the case the higher priority
		task will execute when the scheduler is unsupended. */
		if( xReturn != errQUEUE_FULL )
     8ec:	77 20       	and	r7, r7
     8ee:	c1 f0       	breq	.+48     	; 0x920 <__stack+0x21>
			/* When we are here it is possible that we unblocked as space became
			available on the queue.  It is also possible that an ISR posted to the
			queue since we left the critical section, so it may be that again there
			is no space.  This would only happen if a task and ISR post onto the
			same queue. */
			taskENTER_CRITICAL();
     8f0:	0f b6       	in	r0, 0x3f	; 63
     8f2:	f8 94       	cli
     8f4:	0f 92       	push	r0
			{
				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     8f6:	f8 01       	movw	r30, r16
     8f8:	92 8d       	ldd	r25, Z+26	; 0x1a
     8fa:	83 8d       	ldd	r24, Z+27	; 0x1b
     8fc:	98 17       	cp	r25, r24
     8fe:	58 f4       	brcc	.+22     	; 0x916 <__stack+0x17>
				{
					/* There is room in the queue, copy the data into the queue. */			
					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     900:	49 2d       	mov	r20, r9
     902:	b6 01       	movw	r22, r12
     904:	c8 01       	movw	r24, r16
     906:	0e 94 2b 03 	call	0x656	; 0x656 <prvCopyDataToQueue>
					xReturn = pdPASS;
		
					/* Update the TxLock count so prvUnlockQueue knows to check for
					tasks waiting for data to become available in the queue. */
					++( pxQueue->xTxLock );
     90a:	f8 01       	movw	r30, r16
     90c:	86 8d       	ldd	r24, Z+30	; 0x1e
     90e:	8f 5f       	subi	r24, 0xFF	; 255
     910:	86 8f       	std	Z+30, r24	; 0x1e
			{
				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
				{
					/* There is room in the queue, copy the data into the queue. */			
					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
					xReturn = pdPASS;
     912:	7a 2c       	mov	r7, r10
     914:	01 c0       	rjmp	.+2      	; 0x918 <__stack+0x19>
					tasks waiting for data to become available in the queue. */
					++( pxQueue->xTxLock );
				}
				else
				{
					xReturn = errQUEUE_FULL;
     916:	7b 2c       	mov	r7, r11
				}
			}
			taskEXIT_CRITICAL();
     918:	0f 90       	pop	r0
     91a:	0f be       	out	0x3f, r0	; 63
		}

		if( xReturn == errQUEUE_FULL )
     91c:	71 10       	cpse	r7, r1
     91e:	10 c0       	rjmp	.+32     	; 0x940 <__stack+0x41>
		{
			if( xTicksToWait > 0 )
     920:	ec 81       	ldd	r30, Y+4	; 0x04
     922:	fd 81       	ldd	r31, Y+5	; 0x05
     924:	ef 2b       	or	r30, r31
     926:	59 f0       	breq	.+22     	; 0x93e <__stack+0x3f>
			{
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     928:	be 01       	movw	r22, r28
     92a:	6c 5f       	subi	r22, 0xFC	; 252
     92c:	7f 4f       	sbci	r23, 0xFF	; 255
     92e:	ce 01       	movw	r24, r28
     930:	01 96       	adiw	r24, 0x01	; 1
     932:	0e 94 9f 08 	call	0x113e	; 0x113e <xTaskCheckForTimeOut>
     936:	81 11       	cpse	r24, r1
     938:	02 c0       	rjmp	.+4      	; 0x93e <__stack+0x3f>
     93a:	78 2c       	mov	r7, r8
     93c:	a2 cf       	rjmp	.-188    	; 0x882 <xQueueGenericSend+0x68>
					tasks waiting for data to become available in the queue. */
					++( pxQueue->xTxLock );
				}
				else
				{
					xReturn = errQUEUE_FULL;
     93e:	71 2c       	mov	r7, r1
			}
		}
	}
	while( xReturn == queueERRONEOUS_UNBLOCK );

	prvUnlockQueue( pxQueue );
     940:	c8 01       	movw	r24, r16
     942:	0e 94 86 03 	call	0x70c	; 0x70c <prvUnlockQueue>
	xTaskResumeAll();
     946:	0e 94 32 06 	call	0xc64	; 0xc64 <xTaskResumeAll>

	return xReturn;
}
     94a:	87 2d       	mov	r24, r7
     94c:	0f 90       	pop	r0
     94e:	0f 90       	pop	r0
     950:	0f 90       	pop	r0
     952:	0f 90       	pop	r0
     954:	0f 90       	pop	r0
     956:	df 91       	pop	r29
     958:	cf 91       	pop	r28
     95a:	1f 91       	pop	r17
     95c:	0f 91       	pop	r16
     95e:	ff 90       	pop	r15
     960:	ef 90       	pop	r14
     962:	df 90       	pop	r13
     964:	cf 90       	pop	r12
     966:	bf 90       	pop	r11
     968:	af 90       	pop	r10
     96a:	9f 90       	pop	r9
     96c:	8f 90       	pop	r8
     96e:	7f 90       	pop	r7
     970:	08 95       	ret

00000972 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE xTaskPreviouslyWoken, portBASE_TYPE xCopyPosition )
{
     972:	1f 93       	push	r17
     974:	cf 93       	push	r28
     976:	df 93       	push	r29
     978:	ec 01       	movw	r28, r24
     97a:	14 2f       	mov	r17, r20
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     97c:	9a 8d       	ldd	r25, Y+26	; 0x1a
     97e:	8b 8d       	ldd	r24, Y+27	; 0x1b
     980:	98 17       	cp	r25, r24
     982:	c8 f4       	brcc	.+50     	; 0x9b6 <xQueueGenericSendFromISR+0x44>
	{
		prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     984:	42 2f       	mov	r20, r18
     986:	ce 01       	movw	r24, r28
     988:	0e 94 2b 03 	call	0x656	; 0x656 <prvCopyDataToQueue>

		/* If the queue is locked we do not alter the event list.  This will
		be done when the queue is unlocked later. */
		if( pxQueue->xTxLock == queueUNLOCKED )
     98c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     98e:	8f 3f       	cpi	r24, 0xFF	; 255
     990:	71 f4       	brne	.+28     	; 0x9ae <xQueueGenericSendFromISR+0x3c>
		{
			/* We only want to wake one task per ISR, so check that a task has
			not already been woken. */
			if( !xTaskPreviouslyWoken )		
     992:	11 11       	cpse	r17, r1
     994:	10 c0       	rjmp	.+32     	; 0x9b6 <xQueueGenericSendFromISR+0x44>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     996:	89 89       	ldd	r24, Y+17	; 0x11
     998:	88 23       	and	r24, r24
     99a:	61 f0       	breq	.+24     	; 0x9b4 <xQueueGenericSendFromISR+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     99c:	ce 01       	movw	r24, r28
     99e:	41 96       	adiw	r24, 0x11	; 17
     9a0:	0e 94 49 08 	call	0x1092	; 0x1092 <xTaskRemoveFromEventList>
     9a4:	11 e0       	ldi	r17, 0x01	; 1
     9a6:	81 11       	cpse	r24, r1
     9a8:	06 c0       	rjmp	.+12     	; 0x9b6 <xQueueGenericSendFromISR+0x44>
     9aa:	10 e0       	ldi	r17, 0x00	; 0
     9ac:	04 c0       	rjmp	.+8      	; 0x9b6 <xQueueGenericSendFromISR+0x44>
		}
		else
		{
			/* Increment the lock count so the task that unlocks the queue
			knows that data was posted while it was locked. */
			++( pxQueue->xTxLock );
     9ae:	8f 5f       	subi	r24, 0xFF	; 255
     9b0:	8e 8f       	std	Y+30, r24	; 0x1e
     9b2:	01 c0       	rjmp	.+2      	; 0x9b6 <xQueueGenericSendFromISR+0x44>
		}
	}

	return xTaskPreviouslyWoken;
     9b4:	10 e0       	ldi	r17, 0x00	; 0
}
     9b6:	81 2f       	mov	r24, r17
     9b8:	df 91       	pop	r29
     9ba:	cf 91       	pop	r28
     9bc:	1f 91       	pop	r17
     9be:	08 95       	ret

000009c0 <xQueueReceiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, const void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
     9c0:	0f 93       	push	r16
     9c2:	1f 93       	push	r17
     9c4:	cf 93       	push	r28
     9c6:	df 93       	push	r29
     9c8:	ec 01       	movw	r28, r24
     9ca:	8a 01       	movw	r16, r20
signed portBASE_TYPE xReturn;

	/* We cannot block from an ISR, so check there is data available. */
	if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     9cc:	8a 8d       	ldd	r24, Y+26	; 0x1a
     9ce:	88 23       	and	r24, r24
     9d0:	f1 f0       	breq	.+60     	; 0xa0e <xQueueReceiveFromISR+0x4e>
	{
		prvCopyDataFromQueue( pxQueue, pvBuffer );
     9d2:	ce 01       	movw	r24, r28
     9d4:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <prvCopyDataFromQueue>
		--( pxQueue->uxMessagesWaiting );
     9d8:	8a 8d       	ldd	r24, Y+26	; 0x1a
     9da:	81 50       	subi	r24, 0x01	; 1
     9dc:	8a 8f       	std	Y+26, r24	; 0x1a

		/* If the queue is locked we will not modify the event list.  Instead
		we update the lock count so the task that unlocks the queue will know
		that an ISR has removed data while the queue was locked. */
		if( pxQueue->xRxLock == queueUNLOCKED )
     9de:	8d 8d       	ldd	r24, Y+29	; 0x1d
     9e0:	8f 3f       	cpi	r24, 0xFF	; 255
     9e2:	89 f4       	brne	.+34     	; 0xa06 <xQueueReceiveFromISR+0x46>
		{
			/* We only want to wake one task per ISR, so check that a task has
			not already been woken. */
			if( !( *pxTaskWoken ) )
     9e4:	f8 01       	movw	r30, r16
     9e6:	80 81       	ld	r24, Z
     9e8:	81 11       	cpse	r24, r1
     9ea:	13 c0       	rjmp	.+38     	; 0xa12 <xQueueReceiveFromISR+0x52>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     9ec:	88 85       	ldd	r24, Y+8	; 0x08
     9ee:	88 23       	and	r24, r24
     9f0:	91 f0       	breq	.+36     	; 0xa16 <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     9f2:	ce 01       	movw	r24, r28
     9f4:	08 96       	adiw	r24, 0x08	; 8
     9f6:	0e 94 49 08 	call	0x1092	; 0x1092 <xTaskRemoveFromEventList>
     9fa:	88 23       	and	r24, r24
     9fc:	71 f0       	breq	.+28     	; 0xa1a <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
     9fe:	81 e0       	ldi	r24, 0x01	; 1
     a00:	f8 01       	movw	r30, r16
     a02:	80 83       	st	Z, r24
     a04:	0b c0       	rjmp	.+22     	; 0xa1c <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			/* Increment the lock count so the task that unlocks the queue
			knows that data was removed while it was locked. */
			++( pxQueue->xRxLock );
     a06:	8f 5f       	subi	r24, 0xFF	; 255
     a08:	8d 8f       	std	Y+29, r24	; 0x1d
		}

		xReturn = pdPASS;
     a0a:	81 e0       	ldi	r24, 0x01	; 1
     a0c:	07 c0       	rjmp	.+14     	; 0xa1c <xQueueReceiveFromISR+0x5c>
	}
	else
	{
		xReturn = pdFAIL;
     a0e:	80 e0       	ldi	r24, 0x00	; 0
     a10:	05 c0       	rjmp	.+10     	; 0xa1c <xQueueReceiveFromISR+0x5c>
			/* Increment the lock count so the task that unlocks the queue
			knows that data was removed while it was locked. */
			++( pxQueue->xRxLock );
		}

		xReturn = pdPASS;
     a12:	81 e0       	ldi	r24, 0x01	; 1
     a14:	03 c0       	rjmp	.+6      	; 0xa1c <xQueueReceiveFromISR+0x5c>
     a16:	81 e0       	ldi	r24, 0x01	; 1
     a18:	01 c0       	rjmp	.+2      	; 0xa1c <xQueueReceiveFromISR+0x5c>
     a1a:	81 e0       	ldi	r24, 0x01	; 1
	{
		xReturn = pdFAIL;
	}

	return xReturn;
}
     a1c:	df 91       	pop	r29
     a1e:	cf 91       	pop	r28
     a20:	1f 91       	pop	r17
     a22:	0f 91       	pop	r16
     a24:	08 95       	ret

00000a26 <prvIdleTask>:
			
			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
     a26:	cd e2       	ldi	r28, 0x2D	; 45
     a28:	d5 e0       	ldi	r29, 0x05	; 5
     a2a:	88 81       	ld	r24, Y
     a2c:	82 30       	cpi	r24, 0x02	; 2
     a2e:	e8 f3       	brcs	.-6      	; 0xa2a <prvIdleTask+0x4>
			{
				taskYIELD();
     a30:	0e 94 74 02 	call	0x4e8	; 0x4e8 <vPortYield>
     a34:	fa cf       	rjmp	.-12     	; 0xa2a <prvIdleTask+0x4>

00000a36 <xTaskCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskCreate( pdTASK_CODE pvTaskCode, const signed portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask )
{
     a36:	6f 92       	push	r6
     a38:	7f 92       	push	r7
     a3a:	8f 92       	push	r8
     a3c:	9f 92       	push	r9
     a3e:	af 92       	push	r10
     a40:	bf 92       	push	r11
     a42:	cf 92       	push	r12
     a44:	df 92       	push	r13
     a46:	ef 92       	push	r14
     a48:	ff 92       	push	r15
     a4a:	0f 93       	push	r16
     a4c:	1f 93       	push	r17
     a4e:	cf 93       	push	r28
     a50:	df 93       	push	r29
     a52:	4c 01       	movw	r8, r24
     a54:	5b 01       	movw	r10, r22
     a56:	6a 01       	movw	r12, r20
     a58:	39 01       	movw	r6, r18
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
     a5a:	81 e2       	ldi	r24, 0x21	; 33
     a5c:	90 e0       	ldi	r25, 0x00	; 0
     a5e:	0e 94 0d 01 	call	0x21a	; 0x21a <pvPortMalloc>
     a62:	ec 01       	movw	r28, r24

	if( pxNewTCB != NULL )
     a64:	00 97       	sbiw	r24, 0x00	; 0
     a66:	09 f4       	brne	.+2      	; 0xa6a <xTaskCreate+0x34>
     a68:	c3 c0       	rjmp	.+390    	; 0xbf0 <xTaskCreate+0x1ba>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMalloc( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) );
     a6a:	c6 01       	movw	r24, r12
     a6c:	0e 94 0d 01 	call	0x21a	; 0x21a <pvPortMalloc>
     a70:	98 8f       	std	Y+24, r25	; 0x18
     a72:	8f 8b       	std	Y+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
     a74:	00 97       	sbiw	r24, 0x00	; 0
     a76:	21 f4       	brne	.+8      	; 0xa80 <xTaskCreate+0x4a>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );			
     a78:	ce 01       	movw	r24, r28
     a7a:	0e 94 33 01 	call	0x266	; 0x266 <vPortFree>
     a7e:	b8 c0       	rjmp	.+368    	; 0xbf0 <xTaskCreate+0x1ba>
			pxNewTCB = NULL;			
		}		
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
     a80:	a6 01       	movw	r20, r12
     a82:	65 ea       	ldi	r22, 0xA5	; 165
     a84:	70 e0       	ldi	r23, 0x00	; 0
     a86:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <memset>


static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed portCHAR * const pcName, unsigned portBASE_TYPE uxPriority )
{
	/* Store the function name in the TCB. */
	strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned portSHORT ) configMAX_TASK_NAME_LEN );
     a8a:	48 e0       	ldi	r20, 0x08	; 8
     a8c:	50 e0       	ldi	r21, 0x00	; 0
     a8e:	b5 01       	movw	r22, r10
     a90:	ce 01       	movw	r24, r28
     a92:	49 96       	adiw	r24, 0x19	; 25
     a94:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <strncpy>
	pxTCB->pcTaskName[ ( unsigned portSHORT ) configMAX_TASK_NAME_LEN - ( unsigned portSHORT ) 1 ] = '\0';
     a98:	18 a2       	std	Y+32, r1	; 0x20
     a9a:	10 2f       	mov	r17, r16
     a9c:	08 30       	cpi	r16, 0x08	; 8
     a9e:	08 f0       	brcs	.+2      	; 0xaa2 <xTaskCreate+0x6c>
     aa0:	17 e0       	ldi	r17, 0x07	; 7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
     aa2:	1e 8b       	std	Y+22, r17	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     aa4:	5e 01       	movw	r10, r28
     aa6:	82 e0       	ldi	r24, 0x02	; 2
     aa8:	a8 0e       	add	r10, r24
     aaa:	b1 1c       	adc	r11, r1
     aac:	c5 01       	movw	r24, r10
     aae:	0e 94 42 01 	call	0x284	; 0x284 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     ab2:	ce 01       	movw	r24, r28
     ab4:	0c 96       	adiw	r24, 0x0c	; 12
     ab6:	0e 94 42 01 	call	0x284	; 0x284 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     aba:	d9 87       	std	Y+9, r29	; 0x09
     abc:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     abe:	88 e0       	ldi	r24, 0x08	; 8
     ac0:	90 e0       	ldi	r25, 0x00	; 0
     ac2:	81 1b       	sub	r24, r17
     ac4:	91 09       	sbc	r25, r1
     ac6:	9d 87       	std	Y+13, r25	; 0x0d
     ac8:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     aca:	db 8b       	std	Y+19, r29	; 0x13
     acc:	ca 8b       	std	Y+18, r28	; 0x12
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if portSTACK_GROWTH < 0
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
     ace:	e1 e0       	ldi	r30, 0x01	; 1
     ad0:	ce 1a       	sub	r12, r30
     ad2:	d1 08       	sbc	r13, r1
     ad4:	8f 89       	ldd	r24, Y+23	; 0x17
     ad6:	98 8d       	ldd	r25, Y+24	; 0x18

		/* Initialize the TCB stack to look as if the task was already running,
		but had been interrupted by the scheduler.  The return address is set
		to the start of the task function. Once the stack has been initialised
		the	top of stack variable is updated. */
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pvTaskCode, pvParameters );
     ad8:	a3 01       	movw	r20, r6
     ada:	b4 01       	movw	r22, r8
     adc:	8c 0d       	add	r24, r12
     ade:	9d 1d       	adc	r25, r13
     ae0:	0e 94 ce 01 	call	0x39c	; 0x39c <pxPortInitialiseStack>
     ae4:	99 83       	std	Y+1, r25	; 0x01
     ae6:	88 83       	st	Y, r24

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
     ae8:	0f b6       	in	r0, 0x3f	; 63
     aea:	f8 94       	cli
     aec:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     aee:	80 91 0d 05 	lds	r24, 0x050D
     af2:	8f 5f       	subi	r24, 0xFF	; 255
     af4:	80 93 0d 05 	sts	0x050D, r24
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
     af8:	80 91 0d 05 	lds	r24, 0x050D
     afc:	81 30       	cpi	r24, 0x01	; 1
     afe:	91 f5       	brne	.+100    	; 0xb64 <xTaskCreate+0x12e>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
     b00:	d0 93 76 05 	sts	0x0576, r29
     b04:	c0 93 75 05 	sts	0x0575, r28
     b08:	0f 2e       	mov	r0, r31
     b0a:	fd e2       	ldi	r31, 0x2D	; 45
     b0c:	cf 2e       	mov	r12, r31
     b0e:	f5 e0       	ldi	r31, 0x05	; 5
     b10:	df 2e       	mov	r13, r31
     b12:	f0 2d       	mov	r31, r0
     b14:	0f 2e       	mov	r0, r31
     b16:	f5 e7       	ldi	r31, 0x75	; 117
     b18:	8f 2e       	mov	r8, r31
     b1a:	f5 e0       	ldi	r31, 0x05	; 5
     b1c:	9f 2e       	mov	r9, r31
     b1e:	f0 2d       	mov	r31, r0
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
     b20:	c6 01       	movw	r24, r12
     b22:	0e 94 34 01 	call	0x268	; 0x268 <vListInitialise>
     b26:	f9 e0       	ldi	r31, 0x09	; 9
     b28:	cf 0e       	add	r12, r31
     b2a:	d1 1c       	adc	r13, r1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
     b2c:	c8 14       	cp	r12, r8
     b2e:	d9 04       	cpc	r13, r9
     b30:	b9 f7       	brne	.-18     	; 0xb20 <xTaskCreate+0xea>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
     b32:	84 e2       	ldi	r24, 0x24	; 36
     b34:	95 e0       	ldi	r25, 0x05	; 5
     b36:	0e 94 34 01 	call	0x268	; 0x268 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
     b3a:	8b e1       	ldi	r24, 0x1B	; 27
     b3c:	95 e0       	ldi	r25, 0x05	; 5
     b3e:	0e 94 34 01 	call	0x268	; 0x268 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
     b42:	8e e0       	ldi	r24, 0x0E	; 14
     b44:	95 e0       	ldi	r25, 0x05	; 5
     b46:	0e 94 34 01 	call	0x268	; 0x268 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     b4a:	84 e2       	ldi	r24, 0x24	; 36
     b4c:	95 e0       	ldi	r25, 0x05	; 5
     b4e:	90 93 1a 05 	sts	0x051A, r25
     b52:	80 93 19 05 	sts	0x0519, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     b56:	8b e1       	ldi	r24, 0x1B	; 27
     b58:	95 e0       	ldi	r25, 0x05	; 5
     b5a:	90 93 18 05 	sts	0x0518, r25
     b5e:	80 93 17 05 	sts	0x0517, r24
     b62:	0f c0       	rjmp	.+30     	; 0xb82 <xTaskCreate+0x14c>
			else
			{	
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     b64:	80 91 08 05 	lds	r24, 0x0508
     b68:	81 11       	cpse	r24, r1
     b6a:	0b c0       	rjmp	.+22     	; 0xb82 <xTaskCreate+0x14c>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     b6c:	e0 91 75 05 	lds	r30, 0x0575
     b70:	f0 91 76 05 	lds	r31, 0x0576
     b74:	86 89       	ldd	r24, Z+22	; 0x16
     b76:	08 17       	cp	r16, r24
     b78:	20 f0       	brcs	.+8      	; 0xb82 <xTaskCreate+0x14c>
					{
						pxCurrentTCB = pxNewTCB;	
     b7a:	d0 93 76 05 	sts	0x0576, r29
     b7e:	c0 93 75 05 	sts	0x0575, r28
				}
			}				

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
     b82:	8e 89       	ldd	r24, Y+22	; 0x16
     b84:	90 91 0a 05 	lds	r25, 0x050A
     b88:	98 17       	cp	r25, r24
     b8a:	10 f4       	brcc	.+4      	; 0xb90 <xTaskCreate+0x15a>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
     b8c:	80 93 0a 05 	sts	0x050A, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
				uxTaskNumber++;
			}
			#endif

			prvAddTaskToReadyQueue( pxNewTCB );
     b90:	90 91 09 05 	lds	r25, 0x0509
     b94:	98 17       	cp	r25, r24
     b96:	10 f4       	brcc	.+4      	; 0xb9c <xTaskCreate+0x166>
     b98:	80 93 09 05 	sts	0x0509, r24
     b9c:	90 e0       	ldi	r25, 0x00	; 0
     b9e:	9c 01       	movw	r18, r24
     ba0:	22 0f       	add	r18, r18
     ba2:	33 1f       	adc	r19, r19
     ba4:	22 0f       	add	r18, r18
     ba6:	33 1f       	adc	r19, r19
     ba8:	22 0f       	add	r18, r18
     baa:	33 1f       	adc	r19, r19
     bac:	82 0f       	add	r24, r18
     bae:	93 1f       	adc	r25, r19
     bb0:	b5 01       	movw	r22, r10
     bb2:	83 5d       	subi	r24, 0xD3	; 211
     bb4:	9a 4f       	sbci	r25, 0xFA	; 250
     bb6:	0e 94 46 01 	call	0x28c	; 0x28c <vListInsertEnd>

			xReturn = pdPASS;
		}
		portEXIT_CRITICAL();
     bba:	0f 90       	pop	r0
     bbc:	0f be       	out	0x3f, r0	; 63
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
     bbe:	e1 14       	cp	r14, r1
     bc0:	f1 04       	cpc	r15, r1
     bc2:	19 f0       	breq	.+6      	; 0xbca <xTaskCreate+0x194>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
     bc4:	f7 01       	movw	r30, r14
     bc6:	d1 83       	std	Z+1, r29	; 0x01
     bc8:	c0 83       	st	Z, r28
		}

		if( xSchedulerRunning != pdFALSE )
     bca:	80 91 08 05 	lds	r24, 0x0508
     bce:	88 23       	and	r24, r24
     bd0:	59 f0       	breq	.+22     	; 0xbe8 <xTaskCreate+0x1b2>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     bd2:	e0 91 75 05 	lds	r30, 0x0575
     bd6:	f0 91 76 05 	lds	r31, 0x0576
     bda:	86 89       	ldd	r24, Z+22	; 0x16
     bdc:	80 17       	cp	r24, r16
     bde:	30 f4       	brcc	.+12     	; 0xbec <xTaskCreate+0x1b6>
			{
				taskYIELD();
     be0:	0e 94 74 02 	call	0x4e8	; 0x4e8 <vPortYield>
			}
			#endif

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
     be4:	81 e0       	ldi	r24, 0x01	; 1
     be6:	05 c0       	rjmp	.+10     	; 0xbf2 <xTaskCreate+0x1bc>
     be8:	81 e0       	ldi	r24, 0x01	; 1
     bea:	03 c0       	rjmp	.+6      	; 0xbf2 <xTaskCreate+0x1bc>
     bec:	81 e0       	ldi	r24, 0x01	; 1
     bee:	01 c0       	rjmp	.+2      	; 0xbf2 <xTaskCreate+0x1bc>
		}
		portEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     bf0:	8f ef       	ldi	r24, 0xFF	; 255
			}
		}
	}

	return xReturn;
}
     bf2:	df 91       	pop	r29
     bf4:	cf 91       	pop	r28
     bf6:	1f 91       	pop	r17
     bf8:	0f 91       	pop	r16
     bfa:	ff 90       	pop	r15
     bfc:	ef 90       	pop	r14
     bfe:	df 90       	pop	r13
     c00:	cf 90       	pop	r12
     c02:	bf 90       	pop	r11
     c04:	af 90       	pop	r10
     c06:	9f 90       	pop	r9
     c08:	8f 90       	pop	r8
     c0a:	7f 90       	pop	r7
     c0c:	6f 90       	pop	r6
     c0e:	08 95       	ret

00000c10 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
     c10:	ef 92       	push	r14
     c12:	ff 92       	push	r15
     c14:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed portCHAR * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
     c16:	e1 2c       	mov	r14, r1
     c18:	f1 2c       	mov	r15, r1
     c1a:	00 e0       	ldi	r16, 0x00	; 0
     c1c:	20 e0       	ldi	r18, 0x00	; 0
     c1e:	30 e0       	ldi	r19, 0x00	; 0
     c20:	45 e5       	ldi	r20, 0x55	; 85
     c22:	50 e0       	ldi	r21, 0x00	; 0
     c24:	61 e1       	ldi	r22, 0x11	; 17
     c26:	71 e0       	ldi	r23, 0x01	; 1
     c28:	83 e1       	ldi	r24, 0x13	; 19
     c2a:	95 e0       	ldi	r25, 0x05	; 5
     c2c:	0e 94 1b 05 	call	0xa36	; 0xa36 <xTaskCreate>

	if( xReturn == pdPASS )
     c30:	81 30       	cpi	r24, 0x01	; 1
     c32:	49 f4       	brne	.+18     	; 0xc46 <vTaskStartScheduler+0x36>
		so interrupts will automatically get re-enabled when the first task
		starts to run.
		
		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
     c34:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
     c36:	80 93 08 05 	sts	0x0508, r24
		xTickCount = ( portTickType ) 0;
     c3a:	10 92 0c 05 	sts	0x050C, r1
     c3e:	10 92 0b 05 	sts	0x050B, r1

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
     c42:	0e 94 3a 02 	call	0x474	; 0x474 <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
     c46:	0f 91       	pop	r16
     c48:	ff 90       	pop	r15
     c4a:	ef 90       	pop	r14
     c4c:	08 95       	ret

00000c4e <vTaskSuspendAll>:
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
	portENTER_CRITICAL();
     c4e:	0f b6       	in	r0, 0x3f	; 63
     c50:	f8 94       	cli
     c52:	0f 92       	push	r0
		++uxSchedulerSuspended;
     c54:	80 91 07 05 	lds	r24, 0x0507
     c58:	8f 5f       	subi	r24, 0xFF	; 255
     c5a:	80 93 07 05 	sts	0x0507, r24
	portEXIT_CRITICAL();
     c5e:	0f 90       	pop	r0
     c60:	0f be       	out	0x3f, r0	; 63
     c62:	08 95       	ret

00000c64 <xTaskResumeAll>:
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
     c64:	af 92       	push	r10
     c66:	bf 92       	push	r11
     c68:	cf 92       	push	r12
     c6a:	df 92       	push	r13
     c6c:	ef 92       	push	r14
     c6e:	ff 92       	push	r15
     c70:	0f 93       	push	r16
     c72:	1f 93       	push	r17
     c74:	cf 93       	push	r28
     c76:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
     c78:	0f b6       	in	r0, 0x3f	; 63
     c7a:	f8 94       	cli
     c7c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     c7e:	80 91 07 05 	lds	r24, 0x0507
     c82:	81 50       	subi	r24, 0x01	; 1
     c84:	80 93 07 05 	sts	0x0507, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     c88:	80 91 07 05 	lds	r24, 0x0507
     c8c:	81 11       	cpse	r24, r1
     c8e:	d9 c0       	rjmp	.+434    	; 0xe42 <xTaskResumeAll+0x1de>
		{			
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
     c90:	80 91 0d 05 	lds	r24, 0x050D
     c94:	88 23       	and	r24, r24
     c96:	09 f4       	brne	.+2      	; 0xc9a <xTaskResumeAll+0x36>
     c98:	d6 c0       	rjmp	.+428    	; 0xe46 <xTaskResumeAll+0x1e2>
     c9a:	b1 2c       	mov	r11, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
				
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
     c9c:	0f 2e       	mov	r0, r31
     c9e:	fe e0       	ldi	r31, 0x0E	; 14
     ca0:	ef 2e       	mov	r14, r31
     ca2:	f5 e0       	ldi	r31, 0x05	; 5
     ca4:	ff 2e       	mov	r15, r31
     ca6:	f0 2d       	mov	r31, r0
     ca8:	0f 2e       	mov	r0, r31
     caa:	f3 e1       	ldi	r31, 0x13	; 19
     cac:	cf 2e       	mov	r12, r31
     cae:	f5 e0       	ldi	r31, 0x05	; 5
     cb0:	df 2e       	mov	r13, r31
     cb2:	f0 2d       	mov	r31, r0
					
					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
     cb4:	aa 24       	eor	r10, r10
     cb6:	a3 94       	inc	r10
     cb8:	29 c0       	rjmp	.+82     	; 0xd0c <xTaskResumeAll+0xa8>
				
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
     cba:	ce 01       	movw	r24, r28
     cbc:	0c 96       	adiw	r24, 0x0c	; 12
     cbe:	0e 94 a8 01 	call	0x350	; 0x350 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
     cc2:	8e 01       	movw	r16, r28
     cc4:	0e 5f       	subi	r16, 0xFE	; 254
     cc6:	1f 4f       	sbci	r17, 0xFF	; 255
     cc8:	c8 01       	movw	r24, r16
     cca:	0e 94 a8 01 	call	0x350	; 0x350 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     cce:	8e 89       	ldd	r24, Y+22	; 0x16
     cd0:	90 91 09 05 	lds	r25, 0x0509
     cd4:	98 17       	cp	r25, r24
     cd6:	10 f4       	brcc	.+4      	; 0xcdc <xTaskResumeAll+0x78>
     cd8:	80 93 09 05 	sts	0x0509, r24
     cdc:	90 e0       	ldi	r25, 0x00	; 0
     cde:	9c 01       	movw	r18, r24
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	22 0f       	add	r18, r18
     ce6:	33 1f       	adc	r19, r19
     ce8:	22 0f       	add	r18, r18
     cea:	33 1f       	adc	r19, r19
     cec:	82 0f       	add	r24, r18
     cee:	93 1f       	adc	r25, r19
     cf0:	b8 01       	movw	r22, r16
     cf2:	83 5d       	subi	r24, 0xD3	; 211
     cf4:	9a 4f       	sbci	r25, 0xFA	; 250
     cf6:	0e 94 46 01 	call	0x28c	; 0x28c <vListInsertEnd>
					
					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     cfa:	e0 91 75 05 	lds	r30, 0x0575
     cfe:	f0 91 76 05 	lds	r31, 0x0576
     d02:	9e 89       	ldd	r25, Y+22	; 0x16
     d04:	86 89       	ldd	r24, Z+22	; 0x16
     d06:	98 17       	cp	r25, r24
     d08:	08 f0       	brcs	.+2      	; 0xd0c <xTaskResumeAll+0xa8>
					{
						xYieldRequired = pdTRUE;
     d0a:	ba 2c       	mov	r11, r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
				
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
     d0c:	d7 01       	movw	r26, r14
     d0e:	8c 91       	ld	r24, X
     d10:	88 23       	and	r24, r24
     d12:	39 f0       	breq	.+14     	; 0xd22 <xTaskResumeAll+0xbe>
     d14:	d6 01       	movw	r26, r12
     d16:	ed 91       	ld	r30, X+
     d18:	fc 91       	ld	r31, X
     d1a:	c6 81       	ldd	r28, Z+6	; 0x06
     d1c:	d7 81       	ldd	r29, Z+7	; 0x07
     d1e:	20 97       	sbiw	r28, 0x00	; 0
     d20:	61 f6       	brne	.-104    	; 0xcba <xTaskResumeAll+0x56>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
     d22:	80 91 06 05 	lds	r24, 0x0506
     d26:	88 23       	and	r24, r24
     d28:	09 f4       	brne	.+2      	; 0xd2c <xTaskResumeAll+0xc8>
     d2a:	7e c0       	rjmp	.+252    	; 0xe28 <xTaskResumeAll+0x1c4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
     d2c:	80 91 06 05 	lds	r24, 0x0506
     d30:	88 23       	and	r24, r24
     d32:	09 f4       	brne	.+2      	; 0xd36 <xTaskResumeAll+0xd2>
     d34:	80 c0       	rjmp	.+256    	; 0xe36 <xTaskResumeAll+0x1d2>
 void vTaskIncrementTick( void )
{
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     d36:	80 91 07 05 	lds	r24, 0x0507
     d3a:	81 11       	cpse	r24, r1
     d3c:	66 c0       	rjmp	.+204    	; 0xe0a <xTaskResumeAll+0x1a6>
	{
		++xTickCount;
     d3e:	80 91 0b 05 	lds	r24, 0x050B
     d42:	90 91 0c 05 	lds	r25, 0x050C
     d46:	01 96       	adiw	r24, 0x01	; 1
     d48:	90 93 0c 05 	sts	0x050C, r25
     d4c:	80 93 0b 05 	sts	0x050B, r24
		if( xTickCount == ( portTickType ) 0 )
     d50:	80 91 0b 05 	lds	r24, 0x050B
     d54:	90 91 0c 05 	lds	r25, 0x050C
     d58:	89 2b       	or	r24, r25
     d5a:	09 f0       	breq	.+2      	; 0xd5e <xTaskResumeAll+0xfa>
     d5c:	43 c0       	rjmp	.+134    	; 0xde4 <xTaskResumeAll+0x180>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
     d5e:	80 91 19 05 	lds	r24, 0x0519
     d62:	90 91 1a 05 	lds	r25, 0x051A
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     d66:	20 91 17 05 	lds	r18, 0x0517
     d6a:	30 91 18 05 	lds	r19, 0x0518
     d6e:	30 93 1a 05 	sts	0x051A, r19
     d72:	20 93 19 05 	sts	0x0519, r18
			pxOverflowDelayedTaskList = pxTemp;
     d76:	90 93 18 05 	sts	0x0518, r25
     d7a:	80 93 17 05 	sts	0x0517, r24
            xNumOfOverflows++;
     d7e:	80 91 04 05 	lds	r24, 0x0504
     d82:	8f 5f       	subi	r24, 0xFF	; 255
     d84:	80 93 04 05 	sts	0x0504, r24
     d88:	2d c0       	rjmp	.+90     	; 0xde4 <xTaskResumeAll+0x180>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     d8a:	80 91 0b 05 	lds	r24, 0x050B
     d8e:	90 91 0c 05 	lds	r25, 0x050C
     d92:	2a 81       	ldd	r18, Y+2	; 0x02
     d94:	3b 81       	ldd	r19, Y+3	; 0x03
     d96:	82 17       	cp	r24, r18
     d98:	93 07       	cpc	r25, r19
     d9a:	e0 f1       	brcs	.+120    	; 0xe14 <xTaskResumeAll+0x1b0>
     d9c:	8e 01       	movw	r16, r28
     d9e:	0e 5f       	subi	r16, 0xFE	; 254
     da0:	1f 4f       	sbci	r17, 0xFF	; 255
     da2:	c8 01       	movw	r24, r16
     da4:	0e 94 a8 01 	call	0x350	; 0x350 <vListRemove>
     da8:	8c 89       	ldd	r24, Y+20	; 0x14
     daa:	9d 89       	ldd	r25, Y+21	; 0x15
     dac:	89 2b       	or	r24, r25
     dae:	21 f0       	breq	.+8      	; 0xdb8 <xTaskResumeAll+0x154>
     db0:	ce 01       	movw	r24, r28
     db2:	0c 96       	adiw	r24, 0x0c	; 12
     db4:	0e 94 a8 01 	call	0x350	; 0x350 <vListRemove>
     db8:	8e 89       	ldd	r24, Y+22	; 0x16
     dba:	90 91 09 05 	lds	r25, 0x0509
     dbe:	98 17       	cp	r25, r24
     dc0:	10 f4       	brcc	.+4      	; 0xdc6 <xTaskResumeAll+0x162>
     dc2:	80 93 09 05 	sts	0x0509, r24
     dc6:	90 e0       	ldi	r25, 0x00	; 0
     dc8:	9c 01       	movw	r18, r24
     dca:	22 0f       	add	r18, r18
     dcc:	33 1f       	adc	r19, r19
     dce:	22 0f       	add	r18, r18
     dd0:	33 1f       	adc	r19, r19
     dd2:	22 0f       	add	r18, r18
     dd4:	33 1f       	adc	r19, r19
     dd6:	82 0f       	add	r24, r18
     dd8:	93 1f       	adc	r25, r19
     dda:	b8 01       	movw	r22, r16
     ddc:	83 5d       	subi	r24, 0xD3	; 211
     dde:	9a 4f       	sbci	r25, 0xFA	; 250
     de0:	0e 94 46 01 	call	0x28c	; 0x28c <vListInsertEnd>
     de4:	e0 91 19 05 	lds	r30, 0x0519
     de8:	f0 91 1a 05 	lds	r31, 0x051A
     dec:	80 81       	ld	r24, Z
     dee:	88 23       	and	r24, r24
     df0:	89 f0       	breq	.+34     	; 0xe14 <xTaskResumeAll+0x1b0>
     df2:	e0 91 19 05 	lds	r30, 0x0519
     df6:	f0 91 1a 05 	lds	r31, 0x051A
     dfa:	05 80       	ldd	r0, Z+5	; 0x05
     dfc:	f6 81       	ldd	r31, Z+6	; 0x06
     dfe:	e0 2d       	mov	r30, r0
     e00:	c6 81       	ldd	r28, Z+6	; 0x06
     e02:	d7 81       	ldd	r29, Z+7	; 0x07
     e04:	20 97       	sbiw	r28, 0x00	; 0
     e06:	09 f6       	brne	.-126    	; 0xd8a <xTaskResumeAll+0x126>
     e08:	05 c0       	rjmp	.+10     	; 0xe14 <xTaskResumeAll+0x1b0>
	}
	else
	{
		++uxMissedTicks;
     e0a:	80 91 06 05 	lds	r24, 0x0506
     e0e:	8f 5f       	subi	r24, 0xFF	; 255
     e10:	80 93 06 05 	sts	0x0506, r24
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
						--uxMissedTicks;
     e14:	80 91 06 05 	lds	r24, 0x0506
     e18:	81 50       	subi	r24, 0x01	; 1
     e1a:	80 93 06 05 	sts	0x0506, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
     e1e:	80 91 06 05 	lds	r24, 0x0506
     e22:	81 11       	cpse	r24, r1
     e24:	88 cf       	rjmp	.-240    	; 0xd36 <xTaskResumeAll+0xd2>
     e26:	07 c0       	rjmp	.+14     	; 0xe36 <xTaskResumeAll+0x1d2>
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					xYieldRequired = pdTRUE;
				}
				
				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
     e28:	b1 e0       	ldi	r27, 0x01	; 1
     e2a:	bb 16       	cp	r11, r27
     e2c:	21 f0       	breq	.+8      	; 0xe36 <xTaskResumeAll+0x1d2>
     e2e:	80 91 05 05 	lds	r24, 0x0505
     e32:	81 30       	cpi	r24, 0x01	; 1
     e34:	51 f4       	brne	.+20     	; 0xe4a <xTaskResumeAll+0x1e6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
     e36:	10 92 05 05 	sts	0x0505, r1
					taskYIELD();
     e3a:	0e 94 74 02 	call	0x4e8	; 0x4e8 <vPortYield>
					xYieldRequired = pdTRUE;
				}
				
				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
     e3e:	81 e0       	ldi	r24, 0x01	; 1
     e40:	05 c0       	rjmp	.+10     	; 0xe4c <xTaskResumeAll+0x1e8>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     e42:	80 e0       	ldi	r24, 0x00	; 0
     e44:	03 c0       	rjmp	.+6      	; 0xe4c <xTaskResumeAll+0x1e8>
     e46:	80 e0       	ldi	r24, 0x00	; 0
     e48:	01 c0       	rjmp	.+2      	; 0xe4c <xTaskResumeAll+0x1e8>
     e4a:	80 e0       	ldi	r24, 0x00	; 0
					taskYIELD();
				}
			}
		}
	}
	portEXIT_CRITICAL();
     e4c:	0f 90       	pop	r0
     e4e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     e50:	df 91       	pop	r29
     e52:	cf 91       	pop	r28
     e54:	1f 91       	pop	r17
     e56:	0f 91       	pop	r16
     e58:	ff 90       	pop	r15
     e5a:	ef 90       	pop	r14
     e5c:	df 90       	pop	r13
     e5e:	cf 90       	pop	r12
     e60:	bf 90       	pop	r11
     e62:	af 90       	pop	r10
     e64:	08 95       	ret

00000e66 <vTaskIncrementTick>:
 *----------------------------------------------------------*/


//inline
 void vTaskIncrementTick( void )
{
     e66:	0f 93       	push	r16
     e68:	1f 93       	push	r17
     e6a:	cf 93       	push	r28
     e6c:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     e6e:	80 91 07 05 	lds	r24, 0x0507
     e72:	81 11       	cpse	r24, r1
     e74:	66 c0       	rjmp	.+204    	; 0xf42 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
     e76:	80 91 0b 05 	lds	r24, 0x050B
     e7a:	90 91 0c 05 	lds	r25, 0x050C
     e7e:	01 96       	adiw	r24, 0x01	; 1
     e80:	90 93 0c 05 	sts	0x050C, r25
     e84:	80 93 0b 05 	sts	0x050B, r24
		if( xTickCount == ( portTickType ) 0 )
     e88:	80 91 0b 05 	lds	r24, 0x050B
     e8c:	90 91 0c 05 	lds	r25, 0x050C
     e90:	89 2b       	or	r24, r25
     e92:	09 f0       	breq	.+2      	; 0xe96 <vTaskIncrementTick+0x30>
     e94:	43 c0       	rjmp	.+134    	; 0xf1c <vTaskIncrementTick+0xb6>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
     e96:	80 91 19 05 	lds	r24, 0x0519
     e9a:	90 91 1a 05 	lds	r25, 0x051A
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     e9e:	20 91 17 05 	lds	r18, 0x0517
     ea2:	30 91 18 05 	lds	r19, 0x0518
     ea6:	30 93 1a 05 	sts	0x051A, r19
     eaa:	20 93 19 05 	sts	0x0519, r18
			pxOverflowDelayedTaskList = pxTemp;
     eae:	90 93 18 05 	sts	0x0518, r25
     eb2:	80 93 17 05 	sts	0x0517, r24
            xNumOfOverflows++;
     eb6:	80 91 04 05 	lds	r24, 0x0504
     eba:	8f 5f       	subi	r24, 0xFF	; 255
     ebc:	80 93 04 05 	sts	0x0504, r24
     ec0:	2d c0       	rjmp	.+90     	; 0xf1c <vTaskIncrementTick+0xb6>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     ec2:	80 91 0b 05 	lds	r24, 0x050B
     ec6:	90 91 0c 05 	lds	r25, 0x050C
     eca:	2a 81       	ldd	r18, Y+2	; 0x02
     ecc:	3b 81       	ldd	r19, Y+3	; 0x03
     ece:	82 17       	cp	r24, r18
     ed0:	93 07       	cpc	r25, r19
     ed2:	e0 f1       	brcs	.+120    	; 0xf4c <vTaskIncrementTick+0xe6>
     ed4:	8e 01       	movw	r16, r28
     ed6:	0e 5f       	subi	r16, 0xFE	; 254
     ed8:	1f 4f       	sbci	r17, 0xFF	; 255
     eda:	c8 01       	movw	r24, r16
     edc:	0e 94 a8 01 	call	0x350	; 0x350 <vListRemove>
     ee0:	8c 89       	ldd	r24, Y+20	; 0x14
     ee2:	9d 89       	ldd	r25, Y+21	; 0x15
     ee4:	89 2b       	or	r24, r25
     ee6:	21 f0       	breq	.+8      	; 0xef0 <vTaskIncrementTick+0x8a>
     ee8:	ce 01       	movw	r24, r28
     eea:	0c 96       	adiw	r24, 0x0c	; 12
     eec:	0e 94 a8 01 	call	0x350	; 0x350 <vListRemove>
     ef0:	8e 89       	ldd	r24, Y+22	; 0x16
     ef2:	90 91 09 05 	lds	r25, 0x0509
     ef6:	98 17       	cp	r25, r24
     ef8:	10 f4       	brcc	.+4      	; 0xefe <vTaskIncrementTick+0x98>
     efa:	80 93 09 05 	sts	0x0509, r24
     efe:	90 e0       	ldi	r25, 0x00	; 0
     f00:	9c 01       	movw	r18, r24
     f02:	22 0f       	add	r18, r18
     f04:	33 1f       	adc	r19, r19
     f06:	22 0f       	add	r18, r18
     f08:	33 1f       	adc	r19, r19
     f0a:	22 0f       	add	r18, r18
     f0c:	33 1f       	adc	r19, r19
     f0e:	82 0f       	add	r24, r18
     f10:	93 1f       	adc	r25, r19
     f12:	b8 01       	movw	r22, r16
     f14:	83 5d       	subi	r24, 0xD3	; 211
     f16:	9a 4f       	sbci	r25, 0xFA	; 250
     f18:	0e 94 46 01 	call	0x28c	; 0x28c <vListInsertEnd>
     f1c:	e0 91 19 05 	lds	r30, 0x0519
     f20:	f0 91 1a 05 	lds	r31, 0x051A
     f24:	80 81       	ld	r24, Z
     f26:	88 23       	and	r24, r24
     f28:	89 f0       	breq	.+34     	; 0xf4c <vTaskIncrementTick+0xe6>
     f2a:	e0 91 19 05 	lds	r30, 0x0519
     f2e:	f0 91 1a 05 	lds	r31, 0x051A
     f32:	05 80       	ldd	r0, Z+5	; 0x05
     f34:	f6 81       	ldd	r31, Z+6	; 0x06
     f36:	e0 2d       	mov	r30, r0
     f38:	c6 81       	ldd	r28, Z+6	; 0x06
     f3a:	d7 81       	ldd	r29, Z+7	; 0x07
     f3c:	20 97       	sbiw	r28, 0x00	; 0
     f3e:	09 f6       	brne	.-126    	; 0xec2 <vTaskIncrementTick+0x5c>
     f40:	05 c0       	rjmp	.+10     	; 0xf4c <vTaskIncrementTick+0xe6>
	}
	else
	{
		++uxMissedTicks;
     f42:	80 91 06 05 	lds	r24, 0x0506
     f46:	8f 5f       	subi	r24, 0xFF	; 255
     f48:	80 93 06 05 	sts	0x0506, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
     f4c:	df 91       	pop	r29
     f4e:	cf 91       	pop	r28
     f50:	1f 91       	pop	r17
     f52:	0f 91       	pop	r16
     f54:	08 95       	ret

00000f56 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
     f56:	80 91 07 05 	lds	r24, 0x0507
     f5a:	81 11       	cpse	r24, r1
     f5c:	13 c0       	rjmp	.+38     	; 0xf84 <vTaskSwitchContext+0x2e>
		xMissedYield = pdTRUE;
		return;
	}

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
     f5e:	80 91 09 05 	lds	r24, 0x0509
     f62:	90 e0       	ldi	r25, 0x00	; 0
     f64:	fc 01       	movw	r30, r24
     f66:	ee 0f       	add	r30, r30
     f68:	ff 1f       	adc	r31, r31
     f6a:	ee 0f       	add	r30, r30
     f6c:	ff 1f       	adc	r31, r31
     f6e:	ee 0f       	add	r30, r30
     f70:	ff 1f       	adc	r31, r31
     f72:	8e 0f       	add	r24, r30
     f74:	9f 1f       	adc	r25, r31
     f76:	fc 01       	movw	r30, r24
     f78:	e3 5d       	subi	r30, 0xD3	; 211
     f7a:	fa 4f       	sbci	r31, 0xFA	; 250
     f7c:	80 81       	ld	r24, Z
     f7e:	88 23       	and	r24, r24
     f80:	29 f0       	breq	.+10     	; 0xf8c <vTaskSwitchContext+0x36>
     f82:	1b c0       	rjmp	.+54     	; 0xfba <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
     f84:	81 e0       	ldi	r24, 0x01	; 1
     f86:	80 93 05 05 	sts	0x0505, r24
		return;
     f8a:	08 95       	ret
	}

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
     f8c:	80 91 09 05 	lds	r24, 0x0509
     f90:	81 50       	subi	r24, 0x01	; 1
     f92:	80 93 09 05 	sts	0x0509, r24
		xMissedYield = pdTRUE;
		return;
	}

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
     f96:	80 91 09 05 	lds	r24, 0x0509
     f9a:	90 e0       	ldi	r25, 0x00	; 0
     f9c:	fc 01       	movw	r30, r24
     f9e:	ee 0f       	add	r30, r30
     fa0:	ff 1f       	adc	r31, r31
     fa2:	ee 0f       	add	r30, r30
     fa4:	ff 1f       	adc	r31, r31
     fa6:	ee 0f       	add	r30, r30
     fa8:	ff 1f       	adc	r31, r31
     faa:	8e 0f       	add	r24, r30
     fac:	9f 1f       	adc	r25, r31
     fae:	fc 01       	movw	r30, r24
     fb0:	e3 5d       	subi	r30, 0xD3	; 211
     fb2:	fa 4f       	sbci	r31, 0xFA	; 250
     fb4:	80 81       	ld	r24, Z
     fb6:	88 23       	and	r24, r24
     fb8:	49 f3       	breq	.-46     	; 0xf8c <vTaskSwitchContext+0x36>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
     fba:	e0 91 09 05 	lds	r30, 0x0509
     fbe:	f0 e0       	ldi	r31, 0x00	; 0
     fc0:	cf 01       	movw	r24, r30
     fc2:	88 0f       	add	r24, r24
     fc4:	99 1f       	adc	r25, r25
     fc6:	88 0f       	add	r24, r24
     fc8:	99 1f       	adc	r25, r25
     fca:	88 0f       	add	r24, r24
     fcc:	99 1f       	adc	r25, r25
     fce:	e8 0f       	add	r30, r24
     fd0:	f9 1f       	adc	r31, r25
     fd2:	e3 5d       	subi	r30, 0xD3	; 211
     fd4:	fa 4f       	sbci	r31, 0xFA	; 250
     fd6:	a1 81       	ldd	r26, Z+1	; 0x01
     fd8:	b2 81       	ldd	r27, Z+2	; 0x02
     fda:	12 96       	adiw	r26, 0x02	; 2
     fdc:	0d 90       	ld	r0, X+
     fde:	bc 91       	ld	r27, X
     fe0:	a0 2d       	mov	r26, r0
     fe2:	b2 83       	std	Z+2, r27	; 0x02
     fe4:	a1 83       	std	Z+1, r26	; 0x01
     fe6:	cf 01       	movw	r24, r30
     fe8:	03 96       	adiw	r24, 0x03	; 3
     fea:	a8 17       	cp	r26, r24
     fec:	b9 07       	cpc	r27, r25
     fee:	31 f4       	brne	.+12     	; 0xffc <vTaskSwitchContext+0xa6>
     ff0:	12 96       	adiw	r26, 0x02	; 2
     ff2:	8d 91       	ld	r24, X+
     ff4:	9c 91       	ld	r25, X
     ff6:	13 97       	sbiw	r26, 0x03	; 3
     ff8:	92 83       	std	Z+2, r25	; 0x02
     ffa:	81 83       	std	Z+1, r24	; 0x01
     ffc:	01 80       	ldd	r0, Z+1	; 0x01
     ffe:	f2 81       	ldd	r31, Z+2	; 0x02
    1000:	e0 2d       	mov	r30, r0
    1002:	86 81       	ldd	r24, Z+6	; 0x06
    1004:	97 81       	ldd	r25, Z+7	; 0x07
    1006:	90 93 76 05 	sts	0x0576, r25
    100a:	80 93 75 05 	sts	0x0575, r24
    100e:	08 95       	ret

00001010 <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1010:	cf 93       	push	r28
    1012:	df 93       	push	r29
    1014:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1016:	60 91 75 05 	lds	r22, 0x0575
    101a:	70 91 76 05 	lds	r23, 0x0576
    101e:	64 5f       	subi	r22, 0xF4	; 244
    1020:	7f 4f       	sbci	r23, 0xFF	; 255
    1022:	0e 94 6d 01 	call	0x2da	; 0x2da <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1026:	80 91 75 05 	lds	r24, 0x0575
    102a:	90 91 76 05 	lds	r25, 0x0576
    102e:	02 96       	adiw	r24, 0x02	; 2
    1030:	0e 94 a8 01 	call	0x350	; 0x350 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1034:	60 91 0b 05 	lds	r22, 0x050B
    1038:	70 91 0c 05 	lds	r23, 0x050C
    103c:	6c 0f       	add	r22, r28
    103e:	7d 1f       	adc	r23, r29
		
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1040:	e0 91 75 05 	lds	r30, 0x0575
    1044:	f0 91 76 05 	lds	r31, 0x0576
    1048:	73 83       	std	Z+3, r23	; 0x03
    104a:	62 83       	std	Z+2, r22	; 0x02
		
			if( xTimeToWake < xTickCount )
    104c:	80 91 0b 05 	lds	r24, 0x050B
    1050:	90 91 0c 05 	lds	r25, 0x050C
    1054:	68 17       	cp	r22, r24
    1056:	79 07       	cpc	r23, r25
    1058:	68 f4       	brcc	.+26     	; 0x1074 <vTaskPlaceOnEventList+0x64>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    105a:	60 91 75 05 	lds	r22, 0x0575
    105e:	70 91 76 05 	lds	r23, 0x0576
    1062:	80 91 17 05 	lds	r24, 0x0517
    1066:	90 91 18 05 	lds	r25, 0x0518
    106a:	6e 5f       	subi	r22, 0xFE	; 254
    106c:	7f 4f       	sbci	r23, 0xFF	; 255
    106e:	0e 94 6d 01 	call	0x2da	; 0x2da <vListInsert>
    1072:	0c c0       	rjmp	.+24     	; 0x108c <vTaskPlaceOnEventList+0x7c>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1074:	60 91 75 05 	lds	r22, 0x0575
    1078:	70 91 76 05 	lds	r23, 0x0576
    107c:	80 91 19 05 	lds	r24, 0x0519
    1080:	90 91 1a 05 	lds	r25, 0x051A
    1084:	6e 5f       	subi	r22, 0xFE	; 254
    1086:	7f 4f       	sbci	r23, 0xFF	; 255
    1088:	0e 94 6d 01 	call	0x2da	; 0x2da <vListInsert>
			}
	}
	#endif
}
    108c:	df 91       	pop	r29
    108e:	cf 91       	pop	r28
    1090:	08 95       	ret

00001092 <xTaskRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1092:	0f 93       	push	r16
    1094:	1f 93       	push	r17
    1096:	cf 93       	push	r28
    1098:	df 93       	push	r29
	it to the ready list.
	
	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    109a:	dc 01       	movw	r26, r24
    109c:	2c 91       	ld	r18, X
    109e:	22 23       	and	r18, r18
    10a0:	39 f0       	breq	.+14     	; 0x10b0 <xTaskRemoveFromEventList+0x1e>
    10a2:	15 96       	adiw	r26, 0x05	; 5
    10a4:	ed 91       	ld	r30, X+
    10a6:	fc 91       	ld	r31, X
    10a8:	16 97       	sbiw	r26, 0x06	; 6
    10aa:	c6 81       	ldd	r28, Z+6	; 0x06
    10ac:	d7 81       	ldd	r29, Z+7	; 0x07
    10ae:	02 c0       	rjmp	.+4      	; 0x10b4 <xTaskRemoveFromEventList+0x22>
    10b0:	c0 e0       	ldi	r28, 0x00	; 0
    10b2:	d0 e0       	ldi	r29, 0x00	; 0
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    10b4:	8e 01       	movw	r16, r28
    10b6:	04 5f       	subi	r16, 0xF4	; 244
    10b8:	1f 4f       	sbci	r17, 0xFF	; 255
    10ba:	c8 01       	movw	r24, r16
    10bc:	0e 94 a8 01 	call	0x350	; 0x350 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    10c0:	80 91 07 05 	lds	r24, 0x0507
    10c4:	81 11       	cpse	r24, r1
    10c6:	1c c0       	rjmp	.+56     	; 0x1100 <xTaskRemoveFromEventList+0x6e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    10c8:	0a 50       	subi	r16, 0x0A	; 10
    10ca:	11 09       	sbc	r17, r1
    10cc:	c8 01       	movw	r24, r16
    10ce:	0e 94 a8 01 	call	0x350	; 0x350 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    10d2:	8e 89       	ldd	r24, Y+22	; 0x16
    10d4:	90 91 09 05 	lds	r25, 0x0509
    10d8:	98 17       	cp	r25, r24
    10da:	10 f4       	brcc	.+4      	; 0x10e0 <xTaskRemoveFromEventList+0x4e>
    10dc:	80 93 09 05 	sts	0x0509, r24
    10e0:	90 e0       	ldi	r25, 0x00	; 0
    10e2:	9c 01       	movw	r18, r24
    10e4:	22 0f       	add	r18, r18
    10e6:	33 1f       	adc	r19, r19
    10e8:	22 0f       	add	r18, r18
    10ea:	33 1f       	adc	r19, r19
    10ec:	22 0f       	add	r18, r18
    10ee:	33 1f       	adc	r19, r19
    10f0:	82 0f       	add	r24, r18
    10f2:	93 1f       	adc	r25, r19
    10f4:	b8 01       	movw	r22, r16
    10f6:	83 5d       	subi	r24, 0xD3	; 211
    10f8:	9a 4f       	sbci	r25, 0xFA	; 250
    10fa:	0e 94 46 01 	call	0x28c	; 0x28c <vListInsertEnd>
    10fe:	05 c0       	rjmp	.+10     	; 0x110a <xTaskRemoveFromEventList+0x78>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1100:	b8 01       	movw	r22, r16
    1102:	8e e0       	ldi	r24, 0x0E	; 14
    1104:	95 e0       	ldi	r25, 0x05	; 5
    1106:	0e 94 46 01 	call	0x28c	; 0x28c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    110a:	e0 91 75 05 	lds	r30, 0x0575
    110e:	f0 91 76 05 	lds	r31, 0x0576
    1112:	81 e0       	ldi	r24, 0x01	; 1
    1114:	2e 89       	ldd	r18, Y+22	; 0x16
    1116:	96 89       	ldd	r25, Z+22	; 0x16
    1118:	29 17       	cp	r18, r25
    111a:	08 f4       	brcc	.+2      	; 0x111e <xTaskRemoveFromEventList+0x8c>
    111c:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    111e:	df 91       	pop	r29
    1120:	cf 91       	pop	r28
    1122:	1f 91       	pop	r17
    1124:	0f 91       	pop	r16
    1126:	08 95       	ret

00001128 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    1128:	20 91 04 05 	lds	r18, 0x0504
    112c:	fc 01       	movw	r30, r24
    112e:	20 83       	st	Z, r18
    pxTimeOut->xTimeOnEntering = xTickCount;
    1130:	20 91 0b 05 	lds	r18, 0x050B
    1134:	30 91 0c 05 	lds	r19, 0x050C
    1138:	32 83       	std	Z+2, r19	; 0x02
    113a:	21 83       	std	Z+1, r18	; 0x01
    113c:	08 95       	ret

0000113e <xTaskCheckForTimeOut>:
			xReturn = pdFALSE;
		}
		else /* We are not blocking indefinitely, perform the checks below. */
	#endif

    if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xTickCount >= pxTimeOut->xTimeOnEntering ) )
    113e:	20 91 04 05 	lds	r18, 0x0504
    1142:	dc 01       	movw	r26, r24
    1144:	3c 91       	ld	r19, X
    1146:	32 17       	cp	r19, r18
    1148:	59 f0       	breq	.+22     	; 0x1160 <xTaskCheckForTimeOut+0x22>
    114a:	20 91 0b 05 	lds	r18, 0x050B
    114e:	30 91 0c 05 	lds	r19, 0x050C
    1152:	11 96       	adiw	r26, 0x01	; 1
    1154:	4d 91       	ld	r20, X+
    1156:	5c 91       	ld	r21, X
    1158:	12 97       	sbiw	r26, 0x02	; 2
    115a:	24 17       	cp	r18, r20
    115c:	35 07       	cpc	r19, r21
    115e:	00 f5       	brcc	.+64     	; 0x11a0 <xTaskCheckForTimeOut+0x62>
		was called, but has also overflowed since vTaskSetTimeOut() was called.
        It must have wrapped all the way around and gone past us again. This
        passed since vTaskSetTimeout() was called. */
        xReturn = pdTRUE;
    }
    else if( ( xTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    1160:	e0 91 0b 05 	lds	r30, 0x050B
    1164:	f0 91 0c 05 	lds	r31, 0x050C
    1168:	dc 01       	movw	r26, r24
    116a:	11 96       	adiw	r26, 0x01	; 1
    116c:	4d 91       	ld	r20, X+
    116e:	5c 91       	ld	r21, X
    1170:	12 97       	sbiw	r26, 0x02	; 2
    1172:	db 01       	movw	r26, r22
    1174:	2d 91       	ld	r18, X+
    1176:	3c 91       	ld	r19, X
    1178:	11 97       	sbiw	r26, 0x01	; 1
    117a:	e4 1b       	sub	r30, r20
    117c:	f5 0b       	sbc	r31, r21
    117e:	e2 17       	cp	r30, r18
    1180:	f3 07       	cpc	r31, r19
    1182:	80 f4       	brcc	.+32     	; 0x11a4 <xTaskCheckForTimeOut+0x66>
    {
        /* Not a genuine timeout. Adjust parameters for time remaining. */
        *pxTicksToWait -= ( xTickCount - pxTimeOut->xTimeOnEntering );
    1184:	e0 91 0b 05 	lds	r30, 0x050B
    1188:	f0 91 0c 05 	lds	r31, 0x050C
    118c:	4e 1b       	sub	r20, r30
    118e:	5f 0b       	sbc	r21, r31
    1190:	24 0f       	add	r18, r20
    1192:	35 1f       	adc	r19, r21
    1194:	2d 93       	st	X+, r18
    1196:	3c 93       	st	X, r19
        vTaskSetTimeOutState( pxTimeOut );
    1198:	0e 94 94 08 	call	0x1128	; 0x1128 <vTaskSetTimeOutState>
        xReturn = pdFALSE;
    119c:	80 e0       	ldi	r24, 0x00	; 0
    119e:	08 95       	ret
    {
        /* The tick count is greater than the time at which vTaskSetTimeout()
		was called, but has also overflowed since vTaskSetTimeOut() was called.
        It must have wrapped all the way around and gone past us again. This
        passed since vTaskSetTimeout() was called. */
        xReturn = pdTRUE;
    11a0:	81 e0       	ldi	r24, 0x01	; 1
    11a2:	08 95       	ret
        vTaskSetTimeOutState( pxTimeOut );
        xReturn = pdFALSE;
    }
    else
    {
        xReturn = pdTRUE;
    11a4:	81 e0       	ldi	r24, 0x01	; 1
    }

    return xReturn;
}
    11a6:	08 95       	ret

000011a8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    11a8:	81 e0       	ldi	r24, 0x01	; 1
    11aa:	80 93 05 05 	sts	0x0505, r24
    11ae:	08 95       	ret

000011b0 <xSerialPortInitMinimal>:
	UCSR0B = ucInByte;										\
}
/*-----------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned portLONG ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
    11b0:	cf 92       	push	r12
    11b2:	df 92       	push	r13
    11b4:	ef 92       	push	r14
    11b6:	ff 92       	push	r15
    11b8:	cf 93       	push	r28
    11ba:	6b 01       	movw	r12, r22
    11bc:	7c 01       	movw	r14, r24
    11be:	c4 2f       	mov	r28, r20
unsigned portLONG ulBaudRateCounter;
unsigned portCHAR ucByte;

	portENTER_CRITICAL();
    11c0:	0f b6       	in	r0, 0x3f	; 63
    11c2:	f8 94       	cli
    11c4:	0f 92       	push	r0
	{
		/* Create the queues used by the com test task. */
		xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    11c6:	61 e0       	ldi	r22, 0x01	; 1
    11c8:	84 2f       	mov	r24, r20
    11ca:	0e 94 b8 03 	call	0x770	; 0x770 <xQueueCreate>
    11ce:	90 93 7a 05 	sts	0x057A, r25
    11d2:	80 93 79 05 	sts	0x0579, r24
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    11d6:	61 e0       	ldi	r22, 0x01	; 1
    11d8:	8c 2f       	mov	r24, r28
    11da:	0e 94 b8 03 	call	0x770	; 0x770 <xQueueCreate>
    11de:	90 93 78 05 	sts	0x0578, r25
    11e2:	80 93 77 05 	sts	0x0577, r24

		/* Calculate the baud rate register value from the equation in the
		data sheet. */
		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( unsigned portLONG ) 1;
    11e6:	cc 0c       	add	r12, r12
    11e8:	dd 1c       	adc	r13, r13
    11ea:	ee 1c       	adc	r14, r14
    11ec:	ff 1c       	adc	r15, r15
    11ee:	cc 0c       	add	r12, r12
    11f0:	dd 1c       	adc	r13, r13
    11f2:	ee 1c       	adc	r14, r14
    11f4:	ff 1c       	adc	r15, r15
    11f6:	a7 01       	movw	r20, r14
    11f8:	96 01       	movw	r18, r12
    11fa:	22 0f       	add	r18, r18
    11fc:	33 1f       	adc	r19, r19
    11fe:	44 1f       	adc	r20, r20
    1200:	55 1f       	adc	r21, r21
    1202:	60 e0       	ldi	r22, 0x00	; 0
    1204:	74 e2       	ldi	r23, 0x24	; 36
    1206:	84 ef       	ldi	r24, 0xF4	; 244
    1208:	90 e0       	ldi	r25, 0x00	; 0
    120a:	0e 94 be 09 	call	0x137c	; 0x137c <__udivmodsi4>
    120e:	da 01       	movw	r26, r20
    1210:	c9 01       	movw	r24, r18
    1212:	01 97       	sbiw	r24, 0x01	; 1
    1214:	a1 09       	sbc	r26, r1
    1216:	b1 09       	sbc	r27, r1

		/* Set the baud rate. */	
		ucByte = ( unsigned portCHAR ) ( ulBaudRateCounter & ( unsigned portLONG ) 0xff );	
		UBRR0L = ucByte;
    1218:	80 93 c4 00 	sts	0x00C4, r24

		ulBaudRateCounter >>= ( unsigned portLONG ) 8;
    121c:	89 2f       	mov	r24, r25
    121e:	9a 2f       	mov	r25, r26
    1220:	ab 2f       	mov	r26, r27
    1222:	bb 27       	eor	r27, r27
		ucByte = ( unsigned portCHAR ) ( ulBaudRateCounter & ( unsigned portLONG ) 0xff );	
		UBRR0H = ucByte;
    1224:	80 93 c5 00 	sts	0x00C5, r24

		/* Enable the Rx interrupt.  The Tx interrupt will get enabled
		later. Also enable the Rx and Tx. */
		UCSR0B = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
    1228:	88 e9       	ldi	r24, 0x98	; 152
    122a:	80 93 c1 00 	sts	0x00C1, r24

		/* Set the data bits to 8. */
		UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );
    122e:	86 e8       	ldi	r24, 0x86	; 134
    1230:	80 93 c2 00 	sts	0x00C2, r24
	}
	portEXIT_CRITICAL();
    1234:	0f 90       	pop	r0
    1236:	0f be       	out	0x3f, r0	; 63
	
	/* Unlike other ports, this serial code does not allow for more than one
	com port.  We therefore don't return a pointer to a port structure and can
	instead just return NULL. */
	return NULL;
}
    1238:	80 e0       	ldi	r24, 0x00	; 0
    123a:	90 e0       	ldi	r25, 0x00	; 0
    123c:	cf 91       	pop	r28
    123e:	ff 90       	pop	r15
    1240:	ef 90       	pop	r14
    1242:	df 90       	pop	r13
    1244:	cf 90       	pop	r12
    1246:	08 95       	ret

00001248 <xSerialPutChar>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed portCHAR cOutChar, portTickType xBlockTime )
{
    1248:	cf 93       	push	r28
    124a:	df 93       	push	r29
    124c:	1f 92       	push	r1
    124e:	cd b7       	in	r28, 0x3d	; 61
    1250:	de b7       	in	r29, 0x3e	; 62
    1252:	69 83       	std	Y+1, r22	; 0x01
	/* Only one port is supported. */
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
    1254:	20 e0       	ldi	r18, 0x00	; 0
    1256:	be 01       	movw	r22, r28
    1258:	6f 5f       	subi	r22, 0xFF	; 255
    125a:	7f 4f       	sbci	r23, 0xFF	; 255
    125c:	80 91 77 05 	lds	r24, 0x0577
    1260:	90 91 78 05 	lds	r25, 0x0578
    1264:	0e 94 0d 04 	call	0x81a	; 0x81a <xQueueGenericSend>
    1268:	81 30       	cpi	r24, 0x01	; 1
    126a:	31 f4       	brne	.+12     	; 0x1278 <xSerialPutChar+0x30>
	{
		return pdFAIL;
	}

	vInterruptOn();
    126c:	e1 ec       	ldi	r30, 0xC1	; 193
    126e:	f0 e0       	ldi	r31, 0x00	; 0
    1270:	90 81       	ld	r25, Z
    1272:	90 62       	ori	r25, 0x20	; 32
    1274:	90 83       	st	Z, r25

	return pdPASS;
    1276:	01 c0       	rjmp	.+2      	; 0x127a <xSerialPutChar+0x32>
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
	{
		return pdFAIL;
    1278:	80 e0       	ldi	r24, 0x00	; 0
	}

	vInterruptOn();

	return pdPASS;
}
    127a:	0f 90       	pop	r0
    127c:	df 91       	pop	r29
    127e:	cf 91       	pop	r28
    1280:	08 95       	ret

00001282 <__vector_18>:
	portEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

SIGNAL( USART_RX_vect )
{
    1282:	1f 92       	push	r1
    1284:	0f 92       	push	r0
    1286:	0f b6       	in	r0, 0x3f	; 63
    1288:	0f 92       	push	r0
    128a:	11 24       	eor	r1, r1
    128c:	2f 93       	push	r18
    128e:	3f 93       	push	r19
    1290:	4f 93       	push	r20
    1292:	5f 93       	push	r21
    1294:	6f 93       	push	r22
    1296:	7f 93       	push	r23
    1298:	8f 93       	push	r24
    129a:	9f 93       	push	r25
    129c:	af 93       	push	r26
    129e:	bf 93       	push	r27
    12a0:	ef 93       	push	r30
    12a2:	ff 93       	push	r31
    12a4:	cf 93       	push	r28
    12a6:	df 93       	push	r29
    12a8:	1f 92       	push	r1
    12aa:	cd b7       	in	r28, 0x3d	; 61
    12ac:	de b7       	in	r29, 0x3e	; 62
signed portCHAR cChar;

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
    12ae:	80 91 c6 00 	lds	r24, 0x00C6
    12b2:	89 83       	std	Y+1, r24	; 0x01

	if( xQueueSendFromISR( xRxedChars, &cChar, pdFALSE ) )
    12b4:	20 e0       	ldi	r18, 0x00	; 0
    12b6:	40 e0       	ldi	r20, 0x00	; 0
    12b8:	be 01       	movw	r22, r28
    12ba:	6f 5f       	subi	r22, 0xFF	; 255
    12bc:	7f 4f       	sbci	r23, 0xFF	; 255
    12be:	80 91 79 05 	lds	r24, 0x0579
    12c2:	90 91 7a 05 	lds	r25, 0x057A
    12c6:	0e 94 b9 04 	call	0x972	; 0x972 <xQueueGenericSendFromISR>
    12ca:	81 11       	cpse	r24, r1
	{
		taskYIELD();
    12cc:	0e 94 74 02 	call	0x4e8	; 0x4e8 <vPortYield>
	}
}
    12d0:	0f 90       	pop	r0
    12d2:	df 91       	pop	r29
    12d4:	cf 91       	pop	r28
    12d6:	ff 91       	pop	r31
    12d8:	ef 91       	pop	r30
    12da:	bf 91       	pop	r27
    12dc:	af 91       	pop	r26
    12de:	9f 91       	pop	r25
    12e0:	8f 91       	pop	r24
    12e2:	7f 91       	pop	r23
    12e4:	6f 91       	pop	r22
    12e6:	5f 91       	pop	r21
    12e8:	4f 91       	pop	r20
    12ea:	3f 91       	pop	r19
    12ec:	2f 91       	pop	r18
    12ee:	0f 90       	pop	r0
    12f0:	0f be       	out	0x3f, r0	; 63
    12f2:	0f 90       	pop	r0
    12f4:	1f 90       	pop	r1
    12f6:	18 95       	reti

000012f8 <__vector_19>:
/*-----------------------------------------------------------*/

SIGNAL( USART_UDRE_vect )
{
    12f8:	1f 92       	push	r1
    12fa:	0f 92       	push	r0
    12fc:	0f b6       	in	r0, 0x3f	; 63
    12fe:	0f 92       	push	r0
    1300:	11 24       	eor	r1, r1
    1302:	2f 93       	push	r18
    1304:	3f 93       	push	r19
    1306:	4f 93       	push	r20
    1308:	5f 93       	push	r21
    130a:	6f 93       	push	r22
    130c:	7f 93       	push	r23
    130e:	8f 93       	push	r24
    1310:	9f 93       	push	r25
    1312:	af 93       	push	r26
    1314:	bf 93       	push	r27
    1316:	ef 93       	push	r30
    1318:	ff 93       	push	r31
    131a:	cf 93       	push	r28
    131c:	df 93       	push	r29
    131e:	00 d0       	rcall	.+0      	; 0x1320 <__vector_19+0x28>
    1320:	cd b7       	in	r28, 0x3d	; 61
    1322:	de b7       	in	r29, 0x3e	; 62
signed portCHAR cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
    1324:	ae 01       	movw	r20, r28
    1326:	4e 5f       	subi	r20, 0xFE	; 254
    1328:	5f 4f       	sbci	r21, 0xFF	; 255
    132a:	be 01       	movw	r22, r28
    132c:	6f 5f       	subi	r22, 0xFF	; 255
    132e:	7f 4f       	sbci	r23, 0xFF	; 255
    1330:	80 91 77 05 	lds	r24, 0x0577
    1334:	90 91 78 05 	lds	r25, 0x0578
    1338:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <xQueueReceiveFromISR>
    133c:	81 30       	cpi	r24, 0x01	; 1
    133e:	21 f4       	brne	.+8      	; 0x1348 <__vector_19+0x50>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
    1340:	89 81       	ldd	r24, Y+1	; 0x01
    1342:	80 93 c6 00 	sts	0x00C6, r24
    1346:	05 c0       	rjmp	.+10     	; 0x1352 <__vector_19+0x5a>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
    1348:	e1 ec       	ldi	r30, 0xC1	; 193
    134a:	f0 e0       	ldi	r31, 0x00	; 0
    134c:	80 81       	ld	r24, Z
    134e:	8f 7d       	andi	r24, 0xDF	; 223
    1350:	80 83       	st	Z, r24
	}
}
    1352:	0f 90       	pop	r0
    1354:	0f 90       	pop	r0
    1356:	df 91       	pop	r29
    1358:	cf 91       	pop	r28
    135a:	ff 91       	pop	r31
    135c:	ef 91       	pop	r30
    135e:	bf 91       	pop	r27
    1360:	af 91       	pop	r26
    1362:	9f 91       	pop	r25
    1364:	8f 91       	pop	r24
    1366:	7f 91       	pop	r23
    1368:	6f 91       	pop	r22
    136a:	5f 91       	pop	r21
    136c:	4f 91       	pop	r20
    136e:	3f 91       	pop	r19
    1370:	2f 91       	pop	r18
    1372:	0f 90       	pop	r0
    1374:	0f be       	out	0x3f, r0	; 63
    1376:	0f 90       	pop	r0
    1378:	1f 90       	pop	r1
    137a:	18 95       	reti

0000137c <__udivmodsi4>:
    137c:	a1 e2       	ldi	r26, 0x21	; 33
    137e:	1a 2e       	mov	r1, r26
    1380:	aa 1b       	sub	r26, r26
    1382:	bb 1b       	sub	r27, r27
    1384:	fd 01       	movw	r30, r26
    1386:	0d c0       	rjmp	.+26     	; 0x13a2 <__udivmodsi4_ep>

00001388 <__udivmodsi4_loop>:
    1388:	aa 1f       	adc	r26, r26
    138a:	bb 1f       	adc	r27, r27
    138c:	ee 1f       	adc	r30, r30
    138e:	ff 1f       	adc	r31, r31
    1390:	a2 17       	cp	r26, r18
    1392:	b3 07       	cpc	r27, r19
    1394:	e4 07       	cpc	r30, r20
    1396:	f5 07       	cpc	r31, r21
    1398:	20 f0       	brcs	.+8      	; 0x13a2 <__udivmodsi4_ep>
    139a:	a2 1b       	sub	r26, r18
    139c:	b3 0b       	sbc	r27, r19
    139e:	e4 0b       	sbc	r30, r20
    13a0:	f5 0b       	sbc	r31, r21

000013a2 <__udivmodsi4_ep>:
    13a2:	66 1f       	adc	r22, r22
    13a4:	77 1f       	adc	r23, r23
    13a6:	88 1f       	adc	r24, r24
    13a8:	99 1f       	adc	r25, r25
    13aa:	1a 94       	dec	r1
    13ac:	69 f7       	brne	.-38     	; 0x1388 <__udivmodsi4_loop>
    13ae:	60 95       	com	r22
    13b0:	70 95       	com	r23
    13b2:	80 95       	com	r24
    13b4:	90 95       	com	r25
    13b6:	9b 01       	movw	r18, r22
    13b8:	ac 01       	movw	r20, r24
    13ba:	bd 01       	movw	r22, r26
    13bc:	cf 01       	movw	r24, r30
    13be:	08 95       	ret

000013c0 <memcpy>:
    13c0:	fb 01       	movw	r30, r22
    13c2:	dc 01       	movw	r26, r24
    13c4:	02 c0       	rjmp	.+4      	; 0x13ca <memcpy+0xa>
    13c6:	01 90       	ld	r0, Z+
    13c8:	0d 92       	st	X+, r0
    13ca:	41 50       	subi	r20, 0x01	; 1
    13cc:	50 40       	sbci	r21, 0x00	; 0
    13ce:	d8 f7       	brcc	.-10     	; 0x13c6 <memcpy+0x6>
    13d0:	08 95       	ret

000013d2 <memset>:
    13d2:	dc 01       	movw	r26, r24
    13d4:	01 c0       	rjmp	.+2      	; 0x13d8 <memset+0x6>
    13d6:	6d 93       	st	X+, r22
    13d8:	41 50       	subi	r20, 0x01	; 1
    13da:	50 40       	sbci	r21, 0x00	; 0
    13dc:	e0 f7       	brcc	.-8      	; 0x13d6 <memset+0x4>
    13de:	08 95       	ret

000013e0 <strncpy>:
    13e0:	fb 01       	movw	r30, r22
    13e2:	dc 01       	movw	r26, r24
    13e4:	41 50       	subi	r20, 0x01	; 1
    13e6:	50 40       	sbci	r21, 0x00	; 0
    13e8:	48 f0       	brcs	.+18     	; 0x13fc <strncpy+0x1c>
    13ea:	01 90       	ld	r0, Z+
    13ec:	0d 92       	st	X+, r0
    13ee:	00 20       	and	r0, r0
    13f0:	c9 f7       	brne	.-14     	; 0x13e4 <strncpy+0x4>
    13f2:	01 c0       	rjmp	.+2      	; 0x13f6 <strncpy+0x16>
    13f4:	1d 92       	st	X+, r1
    13f6:	41 50       	subi	r20, 0x01	; 1
    13f8:	50 40       	sbci	r21, 0x00	; 0
    13fa:	e0 f7       	brcc	.-8      	; 0x13f4 <strncpy+0x14>
    13fc:	08 95       	ret

000013fe <_exit>:
    13fe:	f8 94       	cli

00001400 <__stop_program>:
    1400:	ff cf       	rjmp	.-2      	; 0x1400 <__stop_program>
