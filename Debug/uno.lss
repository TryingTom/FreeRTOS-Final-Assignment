
uno.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00800200  00001e4a  00001ede  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001e4a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000012f8  00800216  00800216  00001ef4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001ef4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001f24  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003f0  00000000  00000000  00001f64  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000064a3  00000000  00000000  00002354  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000184c  00000000  00000000  000087f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003c95  00000000  00000000  0000a043  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ff4  00000000  00000000  0000dcd8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001834  00000000  00000000  0000eccc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005f91  00000000  00000000  00010500  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000818  00000000  00000000  00016491  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	e8 c1       	rjmp	.+976    	; 0x3d2 <__ctors_end>
       2:	00 00       	nop
       4:	06 c2       	rjmp	.+1036   	; 0x412 <__bad_interrupt>
       6:	00 00       	nop
       8:	04 c2       	rjmp	.+1032   	; 0x412 <__bad_interrupt>
       a:	00 00       	nop
       c:	02 c2       	rjmp	.+1028   	; 0x412 <__bad_interrupt>
       e:	00 00       	nop
      10:	00 c2       	rjmp	.+1024   	; 0x412 <__bad_interrupt>
      12:	00 00       	nop
      14:	fe c1       	rjmp	.+1020   	; 0x412 <__bad_interrupt>
      16:	00 00       	nop
      18:	fc c1       	rjmp	.+1016   	; 0x412 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	fa c1       	rjmp	.+1012   	; 0x412 <__bad_interrupt>
      1e:	00 00       	nop
      20:	f8 c1       	rjmp	.+1008   	; 0x412 <__bad_interrupt>
      22:	00 00       	nop
      24:	f6 c1       	rjmp	.+1004   	; 0x412 <__bad_interrupt>
      26:	00 00       	nop
      28:	f4 c1       	rjmp	.+1000   	; 0x412 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	f2 c1       	rjmp	.+996    	; 0x412 <__bad_interrupt>
      2e:	00 00       	nop
      30:	f0 c1       	rjmp	.+992    	; 0x412 <__bad_interrupt>
      32:	00 00       	nop
      34:	ee c1       	rjmp	.+988    	; 0x412 <__bad_interrupt>
      36:	00 00       	nop
      38:	ec c1       	rjmp	.+984    	; 0x412 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	ea c1       	rjmp	.+980    	; 0x412 <__bad_interrupt>
      3e:	00 00       	nop
      40:	e8 c1       	rjmp	.+976    	; 0x412 <__bad_interrupt>
      42:	00 00       	nop
      44:	eb c4       	rjmp	.+2518   	; 0xa1c <__vector_17>
      46:	00 00       	nop
      48:	e4 c1       	rjmp	.+968    	; 0x412 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	e2 c1       	rjmp	.+964    	; 0x412 <__bad_interrupt>
      4e:	00 00       	nop
      50:	e0 c1       	rjmp	.+960    	; 0x412 <__bad_interrupt>
      52:	00 00       	nop
      54:	de c1       	rjmp	.+956    	; 0x412 <__bad_interrupt>
      56:	00 00       	nop
      58:	dc c1       	rjmp	.+952    	; 0x412 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	da c1       	rjmp	.+948    	; 0x412 <__bad_interrupt>
      5e:	00 00       	nop
      60:	d8 c1       	rjmp	.+944    	; 0x412 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 52 0c 	jmp	0x18a4	; 0x18a4 <__vector_25>
      68:	0c 94 b1 0c 	jmp	0x1962	; 0x1962 <__vector_26>
      6c:	d2 c1       	rjmp	.+932    	; 0x412 <__bad_interrupt>
      6e:	00 00       	nop
      70:	d0 c1       	rjmp	.+928    	; 0x412 <__bad_interrupt>
      72:	00 00       	nop
      74:	ce c1       	rjmp	.+924    	; 0x412 <__bad_interrupt>
      76:	00 00       	nop
      78:	cc c1       	rjmp	.+920    	; 0x412 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	ca c1       	rjmp	.+916    	; 0x412 <__bad_interrupt>
      7e:	00 00       	nop
      80:	c8 c1       	rjmp	.+912    	; 0x412 <__bad_interrupt>
      82:	00 00       	nop
      84:	c6 c1       	rjmp	.+908    	; 0x412 <__bad_interrupt>
      86:	00 00       	nop
      88:	c4 c1       	rjmp	.+904    	; 0x412 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	c2 c1       	rjmp	.+900    	; 0x412 <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 fa 0c 	jmp	0x19f4	; 0x19f4 <__vector_36>
      94:	0c 94 59 0d 	jmp	0x1ab2	; 0x1ab2 <__vector_37>
      98:	bc c1       	rjmp	.+888    	; 0x412 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ba c1       	rjmp	.+884    	; 0x412 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	b8 c1       	rjmp	.+880    	; 0x412 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	b6 c1       	rjmp	.+876    	; 0x412 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	b4 c1       	rjmp	.+872    	; 0x412 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	b2 c1       	rjmp	.+868    	; 0x412 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	b0 c1       	rjmp	.+864    	; 0x412 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	ae c1       	rjmp	.+860    	; 0x412 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	ac c1       	rjmp	.+856    	; 0x412 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	aa c1       	rjmp	.+852    	; 0x412 <__bad_interrupt>
      be:	00 00       	nop
      c0:	a8 c1       	rjmp	.+848    	; 0x412 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	a6 c1       	rjmp	.+844    	; 0x412 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	a4 c1       	rjmp	.+840    	; 0x412 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 a2 0d 	jmp	0x1b44	; 0x1b44 <__vector_51>
      d0:	0c 94 01 0e 	jmp	0x1c02	; 0x1c02 <__vector_52>
      d4:	9e c1       	rjmp	.+828    	; 0x412 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 4a 0e 	jmp	0x1c94	; 0x1c94 <__vector_54>
      dc:	0c 94 a9 0e 	jmp	0x1d52	; 0x1d52 <__vector_55>
      e0:	98 c1       	rjmp	.+816    	; 0x412 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	00 0a       	sbc	r0, r16
      e6:	00 0a       	sbc	r0, r16
      e8:	07 0a       	sbc	r0, r23
      ea:	07 0a       	sbc	r0, r23
      ec:	0e 0a       	sbc	r0, r30
      ee:	0e 0a       	sbc	r0, r30
      f0:	15 0a       	sbc	r1, r21
      f2:	15 0a       	sbc	r1, r21
      f4:	88 0a       	sbc	r8, r24
      f6:	b8 0a       	sbc	r11, r24
      f8:	f1 0a       	sbc	r15, r17
      fa:	21 0b       	sbc	r18, r17
      fc:	5a 0b       	sbc	r21, r26
      fe:	8a 0b       	sbc	r24, r26
     100:	c7 0b       	sbc	r28, r23
     102:	f7 0b       	sbc	r31, r23

00000104 <prvIdleTask>:
UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
}
     104:	0f 2e       	mov	r0, r31
     106:	f0 e3       	ldi	r31, 0x30	; 48
     108:	af 2e       	mov	r10, r31
     10a:	f4 e1       	ldi	r31, 0x14	; 20
     10c:	bf 2e       	mov	r11, r31
     10e:	f0 2d       	mov	r31, r0
     110:	09 e3       	ldi	r16, 0x39	; 57
     112:	14 e1       	ldi	r17, 0x14	; 20
     114:	88 24       	eor	r8, r8
     116:	8a 94       	dec	r8
     118:	98 2c       	mov	r9, r8
     11a:	33 24       	eor	r3, r3
     11c:	33 94       	inc	r3
     11e:	43 2c       	mov	r4, r3
     120:	73 2c       	mov	r7, r3
     122:	48 c1       	rjmp	.+656    	; 0x3b4 <prvIdleTask+0x2b0>
     124:	80 91 1a 14 	lds	r24, 0x141A	; 0x80141a <uxSchedulerSuspended>
     128:	8f 5f       	subi	r24, 0xFF	; 255
     12a:	80 93 1a 14 	sts	0x141A, r24	; 0x80141a <uxSchedulerSuspended>
     12e:	d5 01       	movw	r26, r10
     130:	6c 90       	ld	r6, X
     132:	0f b6       	in	r0, 0x3f	; 63
     134:	f8 94       	cli
     136:	0f 92       	push	r0
     138:	80 91 1a 14 	lds	r24, 0x141A	; 0x80141a <uxSchedulerSuspended>
     13c:	81 50       	subi	r24, 0x01	; 1
     13e:	80 93 1a 14 	sts	0x141A, r24	; 0x80141a <uxSchedulerSuspended>
     142:	80 91 1a 14 	lds	r24, 0x141A	; 0x80141a <uxSchedulerSuspended>
     146:	81 11       	cpse	r24, r1
     148:	13 c1       	rjmp	.+550    	; 0x370 <prvIdleTask+0x26c>
     14a:	80 91 25 14 	lds	r24, 0x1425	; 0x801425 <uxCurrentNumberOfTasks>
     14e:	81 11       	cpse	r24, r1
     150:	30 c0       	rjmp	.+96     	; 0x1b2 <prvIdleTask+0xae>
     152:	0e c1       	rjmp	.+540    	; 0x370 <prvIdleTask+0x26c>
     154:	d8 01       	movw	r26, r16
     156:	15 96       	adiw	r26, 0x05	; 5
     158:	ed 91       	ld	r30, X+
     15a:	fc 91       	ld	r31, X
     15c:	16 97       	sbiw	r26, 0x06	; 6
     15e:	c6 81       	ldd	r28, Z+6	; 0x06
     160:	d7 81       	ldd	r29, Z+7	; 0x07
     162:	ce 01       	movw	r24, r28
     164:	0c 96       	adiw	r24, 0x0c	; 12
     166:	a2 d2       	rcall	.+1348   	; 0x6ac <uxListRemove>
     168:	7e 01       	movw	r14, r28
     16a:	b2 e0       	ldi	r27, 0x02	; 2
     16c:	eb 0e       	add	r14, r27
     16e:	f1 1c       	adc	r15, r1
     170:	c7 01       	movw	r24, r14
     172:	9c d2       	rcall	.+1336   	; 0x6ac <uxListRemove>
     174:	8e 89       	ldd	r24, Y+22	; 0x16
     176:	90 91 22 14 	lds	r25, 0x1422	; 0x801422 <uxTopReadyPriority>
     17a:	98 17       	cp	r25, r24
     17c:	10 f4       	brcc	.+4      	; 0x182 <prvIdleTask+0x7e>
     17e:	80 93 22 14 	sts	0x1422, r24	; 0x801422 <uxTopReadyPriority>
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	9c 01       	movw	r18, r24
     186:	22 0f       	add	r18, r18
     188:	33 1f       	adc	r19, r19
     18a:	22 0f       	add	r18, r18
     18c:	33 1f       	adc	r19, r19
     18e:	22 0f       	add	r18, r18
     190:	33 1f       	adc	r19, r19
     192:	82 0f       	add	r24, r18
     194:	93 1f       	adc	r25, r19
     196:	b7 01       	movw	r22, r14
     198:	88 5a       	subi	r24, 0xA8	; 168
     19a:	9b 4e       	sbci	r25, 0xEB	; 235
     19c:	66 d2       	rcall	.+1228   	; 0x66a <vListInsertEnd>
     19e:	e0 91 7c 14 	lds	r30, 0x147C	; 0x80147c <pxCurrentTCB>
     1a2:	f0 91 7d 14 	lds	r31, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     1a6:	9e 89       	ldd	r25, Y+22	; 0x16
     1a8:	86 89       	ldd	r24, Z+22	; 0x16
     1aa:	98 17       	cp	r25, r24
     1ac:	10 f0       	brcs	.+4      	; 0x1b2 <prvIdleTask+0xae>
     1ae:	40 92 1f 14 	sts	0x141F, r4	; 0x80141f <xYieldPending>
     1b2:	f8 01       	movw	r30, r16
     1b4:	80 81       	ld	r24, Z
     1b6:	81 11       	cpse	r24, r1
     1b8:	cd cf       	rjmp	.-102    	; 0x154 <prvIdleTask+0x50>
     1ba:	80 91 20 14 	lds	r24, 0x1420	; 0x801420 <uxPendedTicks>
     1be:	88 23       	and	r24, r24
     1c0:	09 f4       	brne	.+2      	; 0x1c4 <prvIdleTask+0xc0>
     1c2:	d1 c0       	rjmp	.+418    	; 0x366 <prvIdleTask+0x262>
     1c4:	80 91 20 14 	lds	r24, 0x1420	; 0x801420 <uxPendedTicks>
     1c8:	88 23       	and	r24, r24
     1ca:	09 f4       	brne	.+2      	; 0x1ce <prvIdleTask+0xca>
     1cc:	cc c0       	rjmp	.+408    	; 0x366 <prvIdleTask+0x262>
     1ce:	80 91 1a 14 	lds	r24, 0x141A	; 0x80141a <uxSchedulerSuspended>
     1d2:	81 11       	cpse	r24, r1
     1d4:	ae c0       	rjmp	.+348    	; 0x332 <prvIdleTask+0x22e>
     1d6:	80 91 23 14 	lds	r24, 0x1423	; 0x801423 <xTickCount>
     1da:	90 91 24 14 	lds	r25, 0x1424	; 0x801424 <xTickCount+0x1>
     1de:	01 96       	adiw	r24, 0x01	; 1
     1e0:	90 93 24 14 	sts	0x1424, r25	; 0x801424 <xTickCount+0x1>
     1e4:	80 93 23 14 	sts	0x1423, r24	; 0x801423 <xTickCount>
     1e8:	c0 90 23 14 	lds	r12, 0x1423	; 0x801423 <xTickCount>
     1ec:	d0 90 24 14 	lds	r13, 0x1424	; 0x801424 <xTickCount+0x1>
     1f0:	c1 14       	cp	r12, r1
     1f2:	d1 04       	cpc	r13, r1
     1f4:	89 f5       	brne	.+98     	; 0x258 <prvIdleTask+0x154>
     1f6:	80 91 44 14 	lds	r24, 0x1444	; 0x801444 <pxDelayedTaskList>
     1fa:	90 91 45 14 	lds	r25, 0x1445	; 0x801445 <pxDelayedTaskList+0x1>
     1fe:	20 91 42 14 	lds	r18, 0x1442	; 0x801442 <pxOverflowDelayedTaskList>
     202:	30 91 43 14 	lds	r19, 0x1443	; 0x801443 <pxOverflowDelayedTaskList+0x1>
     206:	30 93 45 14 	sts	0x1445, r19	; 0x801445 <pxDelayedTaskList+0x1>
     20a:	20 93 44 14 	sts	0x1444, r18	; 0x801444 <pxDelayedTaskList>
     20e:	90 93 43 14 	sts	0x1443, r25	; 0x801443 <pxOverflowDelayedTaskList+0x1>
     212:	80 93 42 14 	sts	0x1442, r24	; 0x801442 <pxOverflowDelayedTaskList>
     216:	80 91 1e 14 	lds	r24, 0x141E	; 0x80141e <xNumOfOverflows>
     21a:	8f 5f       	subi	r24, 0xFF	; 255
     21c:	80 93 1e 14 	sts	0x141E, r24	; 0x80141e <xNumOfOverflows>
     220:	e0 91 44 14 	lds	r30, 0x1444	; 0x801444 <pxDelayedTaskList>
     224:	f0 91 45 14 	lds	r31, 0x1445	; 0x801445 <pxDelayedTaskList+0x1>
     228:	80 81       	ld	r24, Z
     22a:	81 11       	cpse	r24, r1
     22c:	05 c0       	rjmp	.+10     	; 0x238 <prvIdleTask+0x134>
     22e:	90 92 1c 14 	sts	0x141C, r9	; 0x80141c <xNextTaskUnblockTime+0x1>
     232:	80 92 1b 14 	sts	0x141B, r8	; 0x80141b <xNextTaskUnblockTime>
     236:	10 c0       	rjmp	.+32     	; 0x258 <prvIdleTask+0x154>
     238:	e0 91 44 14 	lds	r30, 0x1444	; 0x801444 <pxDelayedTaskList>
     23c:	f0 91 45 14 	lds	r31, 0x1445	; 0x801445 <pxDelayedTaskList+0x1>
     240:	05 80       	ldd	r0, Z+5	; 0x05
     242:	f6 81       	ldd	r31, Z+6	; 0x06
     244:	e0 2d       	mov	r30, r0
     246:	06 80       	ldd	r0, Z+6	; 0x06
     248:	f7 81       	ldd	r31, Z+7	; 0x07
     24a:	e0 2d       	mov	r30, r0
     24c:	82 81       	ldd	r24, Z+2	; 0x02
     24e:	93 81       	ldd	r25, Z+3	; 0x03
     250:	90 93 1c 14 	sts	0x141C, r25	; 0x80141c <xNextTaskUnblockTime+0x1>
     254:	80 93 1b 14 	sts	0x141B, r24	; 0x80141b <xNextTaskUnblockTime>
     258:	80 91 1b 14 	lds	r24, 0x141B	; 0x80141b <xNextTaskUnblockTime>
     25c:	90 91 1c 14 	lds	r25, 0x141C	; 0x80141c <xNextTaskUnblockTime+0x1>
     260:	c8 16       	cp	r12, r24
     262:	d9 06       	cpc	r13, r25
     264:	10 f4       	brcc	.+4      	; 0x26a <prvIdleTask+0x166>
     266:	25 2c       	mov	r2, r5
     268:	4d c0       	rjmp	.+154    	; 0x304 <prvIdleTask+0x200>
     26a:	25 2c       	mov	r2, r5
     26c:	e0 91 44 14 	lds	r30, 0x1444	; 0x801444 <pxDelayedTaskList>
     270:	f0 91 45 14 	lds	r31, 0x1445	; 0x801445 <pxDelayedTaskList+0x1>
     274:	80 81       	ld	r24, Z
     276:	81 11       	cpse	r24, r1
     278:	05 c0       	rjmp	.+10     	; 0x284 <prvIdleTask+0x180>
     27a:	90 92 1c 14 	sts	0x141C, r9	; 0x80141c <xNextTaskUnblockTime+0x1>
     27e:	80 92 1b 14 	sts	0x141B, r8	; 0x80141b <xNextTaskUnblockTime>
     282:	40 c0       	rjmp	.+128    	; 0x304 <prvIdleTask+0x200>
     284:	e0 91 44 14 	lds	r30, 0x1444	; 0x801444 <pxDelayedTaskList>
     288:	f0 91 45 14 	lds	r31, 0x1445	; 0x801445 <pxDelayedTaskList+0x1>
     28c:	05 80       	ldd	r0, Z+5	; 0x05
     28e:	f6 81       	ldd	r31, Z+6	; 0x06
     290:	e0 2d       	mov	r30, r0
     292:	c6 81       	ldd	r28, Z+6	; 0x06
     294:	d7 81       	ldd	r29, Z+7	; 0x07
     296:	8a 81       	ldd	r24, Y+2	; 0x02
     298:	9b 81       	ldd	r25, Y+3	; 0x03
     29a:	c8 16       	cp	r12, r24
     29c:	d9 06       	cpc	r13, r25
     29e:	28 f4       	brcc	.+10     	; 0x2aa <prvIdleTask+0x1a6>
     2a0:	90 93 1c 14 	sts	0x141C, r25	; 0x80141c <xNextTaskUnblockTime+0x1>
     2a4:	80 93 1b 14 	sts	0x141B, r24	; 0x80141b <xNextTaskUnblockTime>
     2a8:	2d c0       	rjmp	.+90     	; 0x304 <prvIdleTask+0x200>
     2aa:	7e 01       	movw	r14, r28
     2ac:	f2 e0       	ldi	r31, 0x02	; 2
     2ae:	ef 0e       	add	r14, r31
     2b0:	f1 1c       	adc	r15, r1
     2b2:	c7 01       	movw	r24, r14
     2b4:	fb d1       	rcall	.+1014   	; 0x6ac <uxListRemove>
     2b6:	8c 89       	ldd	r24, Y+20	; 0x14
     2b8:	9d 89       	ldd	r25, Y+21	; 0x15
     2ba:	89 2b       	or	r24, r25
     2bc:	19 f0       	breq	.+6      	; 0x2c4 <prvIdleTask+0x1c0>
     2be:	ce 01       	movw	r24, r28
     2c0:	0c 96       	adiw	r24, 0x0c	; 12
     2c2:	f4 d1       	rcall	.+1000   	; 0x6ac <uxListRemove>
     2c4:	8e 89       	ldd	r24, Y+22	; 0x16
     2c6:	90 91 22 14 	lds	r25, 0x1422	; 0x801422 <uxTopReadyPriority>
     2ca:	98 17       	cp	r25, r24
     2cc:	10 f4       	brcc	.+4      	; 0x2d2 <prvIdleTask+0x1ce>
     2ce:	80 93 22 14 	sts	0x1422, r24	; 0x801422 <uxTopReadyPriority>
     2d2:	90 e0       	ldi	r25, 0x00	; 0
     2d4:	9c 01       	movw	r18, r24
     2d6:	22 0f       	add	r18, r18
     2d8:	33 1f       	adc	r19, r19
     2da:	22 0f       	add	r18, r18
     2dc:	33 1f       	adc	r19, r19
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	82 0f       	add	r24, r18
     2e4:	93 1f       	adc	r25, r19
     2e6:	b7 01       	movw	r22, r14
     2e8:	88 5a       	subi	r24, 0xA8	; 168
     2ea:	9b 4e       	sbci	r25, 0xEB	; 235
     2ec:	be d1       	rcall	.+892    	; 0x66a <vListInsertEnd>
     2ee:	e0 91 7c 14 	lds	r30, 0x147C	; 0x80147c <pxCurrentTCB>
     2f2:	f0 91 7d 14 	lds	r31, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     2f6:	9e 89       	ldd	r25, Y+22	; 0x16
     2f8:	86 89       	ldd	r24, Z+22	; 0x16
     2fa:	98 17       	cp	r25, r24
     2fc:	08 f4       	brcc	.+2      	; 0x300 <prvIdleTask+0x1fc>
     2fe:	b6 cf       	rjmp	.-148    	; 0x26c <prvIdleTask+0x168>
     300:	27 2c       	mov	r2, r7
     302:	b4 cf       	rjmp	.-152    	; 0x26c <prvIdleTask+0x168>
     304:	e0 91 7c 14 	lds	r30, 0x147C	; 0x80147c <pxCurrentTCB>
     308:	f0 91 7d 14 	lds	r31, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     30c:	86 89       	ldd	r24, Z+22	; 0x16
     30e:	90 e0       	ldi	r25, 0x00	; 0
     310:	fc 01       	movw	r30, r24
     312:	ee 0f       	add	r30, r30
     314:	ff 1f       	adc	r31, r31
     316:	ee 0f       	add	r30, r30
     318:	ff 1f       	adc	r31, r31
     31a:	ee 0f       	add	r30, r30
     31c:	ff 1f       	adc	r31, r31
     31e:	8e 0f       	add	r24, r30
     320:	9f 1f       	adc	r25, r31
     322:	fc 01       	movw	r30, r24
     324:	e8 5a       	subi	r30, 0xA8	; 168
     326:	fb 4e       	sbci	r31, 0xEB	; 235
     328:	80 81       	ld	r24, Z
     32a:	82 30       	cpi	r24, 0x02	; 2
     32c:	08 f0       	brcs	.+2      	; 0x330 <prvIdleTask+0x22c>
     32e:	4e c0       	rjmp	.+156    	; 0x3cc <prvIdleTask+0x2c8>
     330:	0a c0       	rjmp	.+20     	; 0x346 <prvIdleTask+0x242>
     332:	80 91 20 14 	lds	r24, 0x1420	; 0x801420 <uxPendedTicks>
     336:	8f 5f       	subi	r24, 0xFF	; 255
     338:	80 93 20 14 	sts	0x1420, r24	; 0x801420 <uxPendedTicks>
     33c:	80 91 1f 14 	lds	r24, 0x141F	; 0x80141f <xYieldPending>
     340:	81 11       	cpse	r24, r1
     342:	06 c0       	rjmp	.+12     	; 0x350 <prvIdleTask+0x24c>
     344:	07 c0       	rjmp	.+14     	; 0x354 <prvIdleTask+0x250>
     346:	80 91 1f 14 	lds	r24, 0x141F	; 0x80141f <xYieldPending>
     34a:	81 11       	cpse	r24, r1
     34c:	01 c0       	rjmp	.+2      	; 0x350 <prvIdleTask+0x24c>
     34e:	21 10       	cpse	r2, r1
     350:	70 92 1f 14 	sts	0x141F, r7	; 0x80141f <xYieldPending>
     354:	80 91 20 14 	lds	r24, 0x1420	; 0x801420 <uxPendedTicks>
     358:	81 50       	subi	r24, 0x01	; 1
     35a:	80 93 20 14 	sts	0x1420, r24	; 0x801420 <uxPendedTicks>
     35e:	80 91 20 14 	lds	r24, 0x1420	; 0x801420 <uxPendedTicks>
     362:	81 11       	cpse	r24, r1
     364:	34 cf       	rjmp	.-408    	; 0x1ce <prvIdleTask+0xca>
     366:	80 91 1f 14 	lds	r24, 0x141F	; 0x80141f <xYieldPending>
     36a:	81 30       	cpi	r24, 0x01	; 1
     36c:	09 f4       	brne	.+2      	; 0x370 <prvIdleTask+0x26c>
     36e:	7f d2       	rcall	.+1278   	; 0x86e <vPortYield>
     370:	0f 90       	pop	r0
     372:	0f be       	out	0x3f, r0	; 63
     374:	66 20       	and	r6, r6
     376:	f9 f0       	breq	.+62     	; 0x3b6 <prvIdleTask+0x2b2>
     378:	0f b6       	in	r0, 0x3f	; 63
     37a:	f8 94       	cli
     37c:	0f 92       	push	r0
     37e:	d5 01       	movw	r26, r10
     380:	15 96       	adiw	r26, 0x05	; 5
     382:	ed 91       	ld	r30, X+
     384:	fc 91       	ld	r31, X
     386:	16 97       	sbiw	r26, 0x06	; 6
     388:	c6 81       	ldd	r28, Z+6	; 0x06
     38a:	d7 81       	ldd	r29, Z+7	; 0x07
     38c:	ce 01       	movw	r24, r28
     38e:	02 96       	adiw	r24, 0x02	; 2
     390:	8d d1       	rcall	.+794    	; 0x6ac <uxListRemove>
     392:	80 91 25 14 	lds	r24, 0x1425	; 0x801425 <uxCurrentNumberOfTasks>
     396:	81 50       	subi	r24, 0x01	; 1
     398:	80 93 25 14 	sts	0x1425, r24	; 0x801425 <uxCurrentNumberOfTasks>
     39c:	80 91 2f 14 	lds	r24, 0x142F	; 0x80142f <uxTasksDeleted>
     3a0:	81 50       	subi	r24, 0x01	; 1
     3a2:	80 93 2f 14 	sts	0x142F, r24	; 0x80142f <uxTasksDeleted>
     3a6:	0f 90       	pop	r0
     3a8:	0f be       	out	0x3f, r0	; 63
     3aa:	8f 89       	ldd	r24, Y+23	; 0x17
     3ac:	98 8d       	ldd	r25, Y+24	; 0x18
     3ae:	4a d1       	rcall	.+660    	; 0x644 <vPortFree>
     3b0:	ce 01       	movw	r24, r28
     3b2:	48 d1       	rcall	.+656    	; 0x644 <vPortFree>
     3b4:	51 2c       	mov	r5, r1
     3b6:	80 91 2f 14 	lds	r24, 0x142F	; 0x80142f <uxTasksDeleted>
     3ba:	81 11       	cpse	r24, r1
     3bc:	b3 ce       	rjmp	.-666    	; 0x124 <prvIdleTask+0x20>
     3be:	80 91 58 14 	lds	r24, 0x1458	; 0x801458 <pxReadyTasksLists>
     3c2:	82 30       	cpi	r24, 0x02	; 2
     3c4:	08 f4       	brcc	.+2      	; 0x3c8 <prvIdleTask+0x2c4>
     3c6:	ab ce       	rjmp	.-682    	; 0x11e <prvIdleTask+0x1a>
     3c8:	52 d2       	rcall	.+1188   	; 0x86e <vPortYield>
     3ca:	a7 ce       	rjmp	.-690    	; 0x11a <prvIdleTask+0x16>
     3cc:	80 91 1f 14 	lds	r24, 0x141F	; 0x80141f <xYieldPending>
     3d0:	bf cf       	rjmp	.-130    	; 0x350 <prvIdleTask+0x24c>

000003d2 <__ctors_end>:
     3d2:	11 24       	eor	r1, r1
     3d4:	1f be       	out	0x3f, r1	; 63
     3d6:	cf ef       	ldi	r28, 0xFF	; 255
     3d8:	d1 e2       	ldi	r29, 0x21	; 33
     3da:	de bf       	out	0x3e, r29	; 62
     3dc:	cd bf       	out	0x3d, r28	; 61
     3de:	00 e0       	ldi	r16, 0x00	; 0
     3e0:	0c bf       	out	0x3c, r16	; 60

000003e2 <__do_copy_data>:
     3e2:	12 e0       	ldi	r17, 0x02	; 2
     3e4:	a0 e0       	ldi	r26, 0x00	; 0
     3e6:	b2 e0       	ldi	r27, 0x02	; 2
     3e8:	ea e4       	ldi	r30, 0x4A	; 74
     3ea:	fe e1       	ldi	r31, 0x1E	; 30
     3ec:	00 e0       	ldi	r16, 0x00	; 0
     3ee:	0b bf       	out	0x3b, r16	; 59
     3f0:	02 c0       	rjmp	.+4      	; 0x3f6 <__do_copy_data+0x14>
     3f2:	07 90       	elpm	r0, Z+
     3f4:	0d 92       	st	X+, r0
     3f6:	a6 31       	cpi	r26, 0x16	; 22
     3f8:	b1 07       	cpc	r27, r17
     3fa:	d9 f7       	brne	.-10     	; 0x3f2 <__do_copy_data+0x10>

000003fc <__do_clear_bss>:
     3fc:	25 e1       	ldi	r18, 0x15	; 21
     3fe:	a6 e1       	ldi	r26, 0x16	; 22
     400:	b2 e0       	ldi	r27, 0x02	; 2
     402:	01 c0       	rjmp	.+2      	; 0x406 <.do_clear_bss_start>

00000404 <.do_clear_bss_loop>:
     404:	1d 92       	st	X+, r1

00000406 <.do_clear_bss_start>:
     406:	ae 30       	cpi	r26, 0x0E	; 14
     408:	b2 07       	cpc	r27, r18
     40a:	e1 f7       	brne	.-8      	; 0x404 <.do_clear_bss_loop>
     40c:	7c d0       	rcall	.+248    	; 0x506 <main>
     40e:	0c 94 23 0f 	jmp	0x1e46	; 0x1e46 <_exit>

00000412 <__bad_interrupt>:
     412:	f6 cd       	rjmp	.-1044   	; 0x0 <__vectors>

00000414 <system_tick>:
     414:	8f 93       	push	r24
     416:	8f b7       	in	r24, 0x3f	; 63
     418:	8f 93       	push	r24
     41a:	f8 94       	cli
     41c:	80 91 0a 15 	lds	r24, 0x150A	; 0x80150a <__system_time>
     420:	8f 5f       	subi	r24, 0xFF	; 255
     422:	80 93 0a 15 	sts	0x150A, r24	; 0x80150a <__system_time>
     426:	80 91 0b 15 	lds	r24, 0x150B	; 0x80150b <__system_time+0x1>
     42a:	8f 4f       	sbci	r24, 0xFF	; 255
     42c:	80 93 0b 15 	sts	0x150B, r24	; 0x80150b <__system_time+0x1>
     430:	80 91 0c 15 	lds	r24, 0x150C	; 0x80150c <__system_time+0x2>
     434:	8f 4f       	sbci	r24, 0xFF	; 255
     436:	80 93 0c 15 	sts	0x150C, r24	; 0x80150c <__system_time+0x2>
     43a:	80 91 0d 15 	lds	r24, 0x150D	; 0x80150d <__system_time+0x3>
     43e:	8f 4f       	sbci	r24, 0xFF	; 255
     440:	80 93 0d 15 	sts	0x150D, r24	; 0x80150d <__system_time+0x3>
     444:	8f 91       	pop	r24
     446:	8f bf       	out	0x3f, r24	; 63
     448:	8f 91       	pop	r24
     44a:	08 95       	ret

0000044c <DoCalculate>:
		DoCalculate(500); // "application"
	}
}

static void DoCalculate(int count) // just to use processor time
{
     44c:	cf 93       	push	r28
     44e:	df 93       	push	r29
     450:	00 d0       	rcall	.+0      	; 0x452 <DoCalculate+0x6>
     452:	1f 92       	push	r1
     454:	cd b7       	in	r28, 0x3d	; 61
     456:	de b7       	in	r29, 0x3e	; 62
	     volatile int i, a = 0;
     458:	1c 82       	std	Y+4, r1	; 0x04
     45a:	1b 82       	std	Y+3, r1	; 0x03
	     for(i=0; i < count; i++)
     45c:	1a 82       	std	Y+2, r1	; 0x02
     45e:	19 82       	std	Y+1, r1	; 0x01
     460:	29 81       	ldd	r18, Y+1	; 0x01
     462:	3a 81       	ldd	r19, Y+2	; 0x02
     464:	28 17       	cp	r18, r24
     466:	39 07       	cpc	r19, r25
     468:	bc f4       	brge	.+46     	; 0x498 <DoCalculate+0x4c>
	     a=a*100+200;
     46a:	64 e6       	ldi	r22, 0x64	; 100
     46c:	4b 81       	ldd	r20, Y+3	; 0x03
     46e:	5c 81       	ldd	r21, Y+4	; 0x04
     470:	64 9f       	mul	r22, r20
     472:	90 01       	movw	r18, r0
     474:	65 9f       	mul	r22, r21
     476:	30 0d       	add	r19, r0
     478:	11 24       	eor	r1, r1
     47a:	28 53       	subi	r18, 0x38	; 56
     47c:	3f 4f       	sbci	r19, 0xFF	; 255
     47e:	3c 83       	std	Y+4, r19	; 0x04
     480:	2b 83       	std	Y+3, r18	; 0x03
}

static void DoCalculate(int count) // just to use processor time
{
	     volatile int i, a = 0;
	     for(i=0; i < count; i++)
     482:	29 81       	ldd	r18, Y+1	; 0x01
     484:	3a 81       	ldd	r19, Y+2	; 0x02
     486:	2f 5f       	subi	r18, 0xFF	; 255
     488:	3f 4f       	sbci	r19, 0xFF	; 255
     48a:	3a 83       	std	Y+2, r19	; 0x02
     48c:	29 83       	std	Y+1, r18	; 0x01
     48e:	29 81       	ldd	r18, Y+1	; 0x01
     490:	3a 81       	ldd	r19, Y+2	; 0x02
     492:	28 17       	cp	r18, r24
     494:	39 07       	cpc	r19, r25
     496:	54 f3       	brlt	.-44     	; 0x46c <DoCalculate+0x20>
	     a=a*100+200;
}
     498:	0f 90       	pop	r0
     49a:	0f 90       	pop	r0
     49c:	0f 90       	pop	r0
     49e:	0f 90       	pop	r0
     4a0:	df 91       	pop	r29
     4a2:	cf 91       	pop	r28
     4a4:	08 95       	ret

000004a6 <vWriter3>:

		DoCalculate(500); // "application"
	}
}
static void vWriter3( void *pvParameters )
{
     4a6:	cf 93       	push	r28
     4a8:	df 93       	push	r29
     4aa:	1f 92       	push	r1
     4ac:	cd b7       	in	r28, 0x3d	; 61
     4ae:	de b7       	in	r29, 0x3e	; 62
	volatile char ch;

	ch = *( char *) pvParameters; // parametri = kirjoitettava merkki
     4b0:	fc 01       	movw	r30, r24
     4b2:	80 81       	ld	r24, Z
     4b4:	89 83       	std	Y+1, r24	; 0x01

	// taskilla tulee aina  olla ikisilmukka
	for( ;; )
	{
		xSerialPutChar( &xSerialPort, ch); // kirjoitetaan merkki kuvaruudulle
     4b6:	69 81       	ldd	r22, Y+1	; 0x01
     4b8:	8e e7       	ldi	r24, 0x7E	; 126
     4ba:	94 e1       	ldi	r25, 0x14	; 20
     4bc:	2e d7       	rcall	.+3676   	; 0x131a <xSerialPutChar>

		DoCalculate(500); // "application"
     4be:	84 ef       	ldi	r24, 0xF4	; 244
     4c0:	91 e0       	ldi	r25, 0x01	; 1
     4c2:	c4 df       	rcall	.-120    	; 0x44c <DoCalculate>
	}
     4c4:	f8 cf       	rjmp	.-16     	; 0x4b6 <vWriter3+0x10>

000004c6 <vWriter2>:

		DoCalculate(500); // "application"
	}
}
static void vWriter2( void *pvParameters )
{
     4c6:	cf 93       	push	r28
     4c8:	df 93       	push	r29
     4ca:	1f 92       	push	r1
     4cc:	cd b7       	in	r28, 0x3d	; 61
     4ce:	de b7       	in	r29, 0x3e	; 62
	volatile char ch;

	ch = *( char *) pvParameters; // parametri = kirjoitettava merkki
     4d0:	fc 01       	movw	r30, r24
     4d2:	80 81       	ld	r24, Z
     4d4:	89 83       	std	Y+1, r24	; 0x01

	// taskilla tulee aina  olla ikisilmukka
	for( ;; )
	{
		xSerialPutChar( &xSerialPort, ch); // kirjoitetaan merkki kuvaruudulle
     4d6:	69 81       	ldd	r22, Y+1	; 0x01
     4d8:	8e e7       	ldi	r24, 0x7E	; 126
     4da:	94 e1       	ldi	r25, 0x14	; 20
     4dc:	1e d7       	rcall	.+3644   	; 0x131a <xSerialPutChar>

		DoCalculate(500); // "application"
     4de:	84 ef       	ldi	r24, 0xF4	; 244
     4e0:	91 e0       	ldi	r25, 0x01	; 1
     4e2:	b4 df       	rcall	.-152    	; 0x44c <DoCalculate>
	}
     4e4:	f8 cf       	rjmp	.-16     	; 0x4d6 <vWriter2+0x10>

000004e6 <vWriter1>:
	return 0;
}
//------ rinnakkain toimivat taskit -------------------------------

static void vWriter1( void *pvParameters )
{
     4e6:	cf 93       	push	r28
     4e8:	df 93       	push	r29
     4ea:	1f 92       	push	r1
     4ec:	cd b7       	in	r28, 0x3d	; 61
     4ee:	de b7       	in	r29, 0x3e	; 62
	volatile char ch;

	ch = *( char *) pvParameters; // parametri = kirjoitettava merkki
     4f0:	fc 01       	movw	r30, r24
     4f2:	80 81       	ld	r24, Z
     4f4:	89 83       	std	Y+1, r24	; 0x01

	// taskilla tulee aina  olla ikisilmukka
	for( ;; )
	{
		xSerialPutChar( &xSerialPort, ch); // kirjoitetaan merkki kuvaruudulle
     4f6:	69 81       	ldd	r22, Y+1	; 0x01
     4f8:	8e e7       	ldi	r24, 0x7E	; 126
     4fa:	94 e1       	ldi	r25, 0x14	; 20
     4fc:	0e d7       	rcall	.+3612   	; 0x131a <xSerialPutChar>

		DoCalculate(500); // "application"
     4fe:	84 ef       	ldi	r24, 0xF4	; 244
     500:	91 e0       	ldi	r25, 0x01	; 1
     502:	a4 df       	rcall	.-184    	; 0x44c <DoCalculate>
	}
     504:	f8 cf       	rjmp	.-16     	; 0x4f6 <vWriter1+0x10>

00000506 <main>:
static void DoCalculate(int count);

xComPortHandle xSerialPort;

int main( void )
{
     506:	af 92       	push	r10
     508:	bf 92       	push	r11
     50a:	cf 92       	push	r12
     50c:	df 92       	push	r13
     50e:	ef 92       	push	r14
     510:	ff 92       	push	r15
     512:	0f 93       	push	r16
     514:	1f 93       	push	r17
     516:	cf 93       	push	r28
     518:	df 93       	push	r29
     51a:	cd b7       	in	r28, 0x3d	; 61
     51c:	de b7       	in	r29, 0x3e	; 62
     51e:	aa 97       	sbiw	r28, 0x2a	; 42
     520:	0f b6       	in	r0, 0x3f	; 63
     522:	f8 94       	cli
     524:	de bf       	out	0x3e, r29	; 62
     526:	0f be       	out	0x3f, r0	; 63
     528:	cd bf       	out	0x3d, r28	; 61
	char ch[] = "1234567";
     52a:	88 e0       	ldi	r24, 0x08	; 8
     52c:	e9 e0       	ldi	r30, 0x09	; 9
     52e:	f2 e0       	ldi	r31, 0x02	; 2
     530:	de 01       	movw	r26, r28
     532:	11 96       	adiw	r26, 0x01	; 1
     534:	01 90       	ld	r0, Z+
     536:	0d 92       	st	X+, r0
     538:	8a 95       	dec	r24
     53a:	e1 f7       	brne	.-8      	; 0x534 <main+0x2e>
	// alustetaan sarjaportti
	xSerialPort = xSerialPortInitMinimal(0, mainCOM_BAUD_RATE, comBUFFER_LEN ,10);
     53c:	0f 2e       	mov	r0, r31
     53e:	fa e0       	ldi	r31, 0x0A	; 10
     540:	ef 2e       	mov	r14, r31
     542:	f1 2c       	mov	r15, r1
     544:	f0 2d       	mov	r31, r0
     546:	0a e0       	ldi	r16, 0x0A	; 10
     548:	10 e0       	ldi	r17, 0x00	; 0
     54a:	20 e8       	ldi	r18, 0x80	; 128
     54c:	35 e2       	ldi	r19, 0x25	; 37
     54e:	40 e0       	ldi	r20, 0x00	; 0
     550:	50 e0       	ldi	r21, 0x00	; 0
     552:	60 e0       	ldi	r22, 0x00	; 0
     554:	ce 01       	movw	r24, r28
     556:	09 96       	adiw	r24, 0x09	; 9
     558:	75 d7       	rcall	.+3818   	; 0x1444 <xSerialPortInitMinimal>
     55a:	82 e2       	ldi	r24, 0x22	; 34
     55c:	fe 01       	movw	r30, r28
     55e:	39 96       	adiw	r30, 0x09	; 9
     560:	ae e7       	ldi	r26, 0x7E	; 126
     562:	b4 e1       	ldi	r27, 0x14	; 20
     564:	01 90       	ld	r0, Z+
     566:	0d 92       	st	X+, r0
     568:	8a 95       	dec	r24
     56a:	e1 f7       	brne	.-8      	; 0x564 <main+0x5e>

	// luodaan kirjoitustaskit
	xTaskCreate( vWriter1, (  portCHAR * )"W1", configMINIMAL_STACK_SIZE, &ch[0],  (tskIDLE_PRIORITY + 3), NULL );
     56c:	a1 2c       	mov	r10, r1
     56e:	b1 2c       	mov	r11, r1
     570:	c1 2c       	mov	r12, r1
     572:	d1 2c       	mov	r13, r1
     574:	e1 2c       	mov	r14, r1
     576:	f1 2c       	mov	r15, r1
     578:	03 e0       	ldi	r16, 0x03	; 3
     57a:	9e 01       	movw	r18, r28
     57c:	2f 5f       	subi	r18, 0xFF	; 255
     57e:	3f 4f       	sbci	r19, 0xFF	; 255
     580:	44 e6       	ldi	r20, 0x64	; 100
     582:	50 e0       	ldi	r21, 0x00	; 0
     584:	60 e0       	ldi	r22, 0x00	; 0
     586:	72 e0       	ldi	r23, 0x02	; 2
     588:	83 e7       	ldi	r24, 0x73	; 115
     58a:	92 e0       	ldi	r25, 0x02	; 2
     58c:	49 d2       	rcall	.+1170   	; 0xa20 <xTaskGenericCreate>
	xTaskCreate( vWriter2, (  portCHAR * )"W2", configMINIMAL_STACK_SIZE, &ch[1],  (tskIDLE_PRIORITY + 3), NULL );
     58e:	9e 01       	movw	r18, r28
     590:	2e 5f       	subi	r18, 0xFE	; 254
     592:	3f 4f       	sbci	r19, 0xFF	; 255
     594:	44 e6       	ldi	r20, 0x64	; 100
     596:	50 e0       	ldi	r21, 0x00	; 0
     598:	63 e0       	ldi	r22, 0x03	; 3
     59a:	72 e0       	ldi	r23, 0x02	; 2
     59c:	83 e6       	ldi	r24, 0x63	; 99
     59e:	92 e0       	ldi	r25, 0x02	; 2
     5a0:	3f d2       	rcall	.+1150   	; 0xa20 <xTaskGenericCreate>
	xTaskCreate( vWriter3, (  portCHAR * )"W3", configMINIMAL_STACK_SIZE, &ch[2],  (tskIDLE_PRIORITY + 3), NULL );
     5a2:	9e 01       	movw	r18, r28
     5a4:	2d 5f       	subi	r18, 0xFD	; 253
     5a6:	3f 4f       	sbci	r19, 0xFF	; 255
     5a8:	44 e6       	ldi	r20, 0x64	; 100
     5aa:	50 e0       	ldi	r21, 0x00	; 0
     5ac:	66 e0       	ldi	r22, 0x06	; 6
     5ae:	72 e0       	ldi	r23, 0x02	; 2
     5b0:	83 e5       	ldi	r24, 0x53	; 83
     5b2:	92 e0       	ldi	r25, 0x02	; 2
     5b4:	35 d2       	rcall	.+1130   	; 0xa20 <xTaskGenericCreate>

	vTaskStartScheduler();  // ajastus päälle
     5b6:	3e d3       	rcall	.+1660   	; 0xc34 <vTaskStartScheduler>
	

	return 0;
}
     5b8:	80 e0       	ldi	r24, 0x00	; 0
     5ba:	90 e0       	ldi	r25, 0x00	; 0
     5bc:	aa 96       	adiw	r28, 0x2a	; 42
     5be:	0f b6       	in	r0, 0x3f	; 63
     5c0:	f8 94       	cli
     5c2:	de bf       	out	0x3e, r29	; 62
     5c4:	0f be       	out	0x3f, r0	; 63
     5c6:	cd bf       	out	0x3d, r28	; 61
     5c8:	df 91       	pop	r29
     5ca:	cf 91       	pop	r28
     5cc:	1f 91       	pop	r17
     5ce:	0f 91       	pop	r16
     5d0:	ff 90       	pop	r15
     5d2:	ef 90       	pop	r14
     5d4:	df 90       	pop	r13
     5d6:	cf 90       	pop	r12
     5d8:	bf 90       	pop	r11
     5da:	af 90       	pop	r10
     5dc:	08 95       	ret

000005de <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     5de:	cf 93       	push	r28
     5e0:	df 93       	push	r29
     5e2:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     5e4:	04 d4       	rcall	.+2056   	; 0xdee <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     5e6:	80 91 16 02 	lds	r24, 0x0216	; 0x800216 <__data_end>
     5ea:	90 91 17 02 	lds	r25, 0x0217	; 0x800217 <__data_end+0x1>
     5ee:	89 2b       	or	r24, r25
     5f0:	31 f4       	brne	.+12     	; 0x5fe <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     5f2:	8b e1       	ldi	r24, 0x1B	; 27
     5f4:	92 e0       	ldi	r25, 0x02	; 2
     5f6:	90 93 17 02 	sts	0x0217, r25	; 0x800217 <__data_end+0x1>
     5fa:	80 93 16 02 	sts	0x0216, r24	; 0x800216 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     5fe:	20 91 18 02 	lds	r18, 0x0218	; 0x800218 <xNextFreeByte>
     602:	30 91 19 02 	lds	r19, 0x0219	; 0x800219 <xNextFreeByte+0x1>
     606:	ce 01       	movw	r24, r28
     608:	82 0f       	add	r24, r18
     60a:	93 1f       	adc	r25, r19
     60c:	8f 3f       	cpi	r24, 0xFF	; 255
     60e:	41 e1       	ldi	r20, 0x11	; 17
     610:	94 07       	cpc	r25, r20
     612:	70 f4       	brcc	.+28     	; 0x630 <pvPortMalloc+0x52>
     614:	28 17       	cp	r18, r24
     616:	39 07       	cpc	r19, r25
     618:	70 f4       	brcc	.+28     	; 0x636 <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     61a:	c0 91 16 02 	lds	r28, 0x0216	; 0x800216 <__data_end>
     61e:	d0 91 17 02 	lds	r29, 0x0217	; 0x800217 <__data_end+0x1>
     622:	c2 0f       	add	r28, r18
     624:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     626:	90 93 19 02 	sts	0x0219, r25	; 0x800219 <xNextFreeByte+0x1>
     62a:	80 93 18 02 	sts	0x0218, r24	; 0x800218 <xNextFreeByte>
     62e:	05 c0       	rjmp	.+10     	; 0x63a <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     630:	c0 e0       	ldi	r28, 0x00	; 0
     632:	d0 e0       	ldi	r29, 0x00	; 0
     634:	02 c0       	rjmp	.+4      	; 0x63a <pvPortMalloc+0x5c>
     636:	c0 e0       	ldi	r28, 0x00	; 0
     638:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     63a:	df d3       	rcall	.+1982   	; 0xdfa <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     63c:	ce 01       	movw	r24, r28
     63e:	df 91       	pop	r29
     640:	cf 91       	pop	r28
     642:	08 95       	ret

00000644 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     644:	08 95       	ret

00000646 <vListInitialise>:
	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
}
     646:	fc 01       	movw	r30, r24
     648:	03 96       	adiw	r24, 0x03	; 3
     64a:	92 83       	std	Z+2, r25	; 0x02
     64c:	81 83       	std	Z+1, r24	; 0x01
     64e:	2f ef       	ldi	r18, 0xFF	; 255
     650:	3f ef       	ldi	r19, 0xFF	; 255
     652:	34 83       	std	Z+4, r19	; 0x04
     654:	23 83       	std	Z+3, r18	; 0x03
     656:	96 83       	std	Z+6, r25	; 0x06
     658:	85 83       	std	Z+5, r24	; 0x05
     65a:	90 87       	std	Z+8, r25	; 0x08
     65c:	87 83       	std	Z+7, r24	; 0x07
     65e:	10 82       	st	Z, r1
     660:	08 95       	ret

00000662 <vListInitialiseItem>:
     662:	fc 01       	movw	r30, r24
     664:	11 86       	std	Z+9, r1	; 0x09
     666:	10 86       	std	Z+8, r1	; 0x08
     668:	08 95       	ret

0000066a <vListInsertEnd>:
     66a:	cf 93       	push	r28
     66c:	df 93       	push	r29
     66e:	9c 01       	movw	r18, r24
     670:	fb 01       	movw	r30, r22
     672:	dc 01       	movw	r26, r24
     674:	11 96       	adiw	r26, 0x01	; 1
     676:	cd 91       	ld	r28, X+
     678:	dc 91       	ld	r29, X
     67a:	12 97       	sbiw	r26, 0x02	; 2
     67c:	d3 83       	std	Z+3, r29	; 0x03
     67e:	c2 83       	std	Z+2, r28	; 0x02
     680:	8c 81       	ldd	r24, Y+4	; 0x04
     682:	9d 81       	ldd	r25, Y+5	; 0x05
     684:	95 83       	std	Z+5, r25	; 0x05
     686:	84 83       	std	Z+4, r24	; 0x04
     688:	8c 81       	ldd	r24, Y+4	; 0x04
     68a:	9d 81       	ldd	r25, Y+5	; 0x05
     68c:	dc 01       	movw	r26, r24
     68e:	13 96       	adiw	r26, 0x03	; 3
     690:	7c 93       	st	X, r23
     692:	6e 93       	st	-X, r22
     694:	12 97       	sbiw	r26, 0x02	; 2
     696:	7d 83       	std	Y+5, r23	; 0x05
     698:	6c 83       	std	Y+4, r22	; 0x04
     69a:	31 87       	std	Z+9, r19	; 0x09
     69c:	20 87       	std	Z+8, r18	; 0x08
     69e:	f9 01       	movw	r30, r18
     6a0:	80 81       	ld	r24, Z
     6a2:	8f 5f       	subi	r24, 0xFF	; 255
     6a4:	80 83       	st	Z, r24
     6a6:	df 91       	pop	r29
     6a8:	cf 91       	pop	r28
     6aa:	08 95       	ret

000006ac <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     6ac:	cf 93       	push	r28
     6ae:	df 93       	push	r29
     6b0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     6b2:	a0 85       	ldd	r26, Z+8	; 0x08
     6b4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     6b6:	c2 81       	ldd	r28, Z+2	; 0x02
     6b8:	d3 81       	ldd	r29, Z+3	; 0x03
     6ba:	84 81       	ldd	r24, Z+4	; 0x04
     6bc:	95 81       	ldd	r25, Z+5	; 0x05
     6be:	9d 83       	std	Y+5, r25	; 0x05
     6c0:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     6c2:	c4 81       	ldd	r28, Z+4	; 0x04
     6c4:	d5 81       	ldd	r29, Z+5	; 0x05
     6c6:	82 81       	ldd	r24, Z+2	; 0x02
     6c8:	93 81       	ldd	r25, Z+3	; 0x03
     6ca:	9b 83       	std	Y+3, r25	; 0x03
     6cc:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     6ce:	11 96       	adiw	r26, 0x01	; 1
     6d0:	cd 91       	ld	r28, X+
     6d2:	dc 91       	ld	r29, X
     6d4:	12 97       	sbiw	r26, 0x02	; 2
     6d6:	ce 17       	cp	r28, r30
     6d8:	df 07       	cpc	r29, r31
     6da:	31 f4       	brne	.+12     	; 0x6e8 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     6dc:	8c 81       	ldd	r24, Y+4	; 0x04
     6de:	9d 81       	ldd	r25, Y+5	; 0x05
     6e0:	12 96       	adiw	r26, 0x02	; 2
     6e2:	9c 93       	st	X, r25
     6e4:	8e 93       	st	-X, r24
     6e6:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     6e8:	11 86       	std	Z+9, r1	; 0x09
     6ea:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     6ec:	8c 91       	ld	r24, X
     6ee:	81 50       	subi	r24, 0x01	; 1
     6f0:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     6f2:	df 91       	pop	r29
     6f4:	cf 91       	pop	r28
     6f6:	08 95       	ret

000006f8 <pxPortInitialiseStack>:

#elif defined( portUSE_TIMER0 )
	portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts

#elif defined( portUSE_TIMER1 )
	portTIMSK &= ~( _BV(OCIE1B)|_BV(OCIE1A)|_BV(TOIE1) );	// disable all Timer1 interrupts
     6f8:	31 e1       	ldi	r19, 0x11	; 17
     6fa:	fc 01       	movw	r30, r24
     6fc:	30 83       	st	Z, r19
     6fe:	31 97       	sbiw	r30, 0x01	; 1
     700:	22 e2       	ldi	r18, 0x22	; 34
     702:	20 83       	st	Z, r18
     704:	31 97       	sbiw	r30, 0x01	; 1
     706:	a3 e3       	ldi	r26, 0x33	; 51
     708:	a0 83       	st	Z, r26
     70a:	31 97       	sbiw	r30, 0x01	; 1
     70c:	60 83       	st	Z, r22
     70e:	31 97       	sbiw	r30, 0x01	; 1
     710:	70 83       	st	Z, r23
     712:	31 97       	sbiw	r30, 0x01	; 1
     714:	10 82       	st	Z, r1
     716:	31 97       	sbiw	r30, 0x01	; 1
     718:	10 82       	st	Z, r1
     71a:	31 97       	sbiw	r30, 0x01	; 1
     71c:	60 e8       	ldi	r22, 0x80	; 128
     71e:	60 83       	st	Z, r22
     720:	31 97       	sbiw	r30, 0x01	; 1
     722:	10 82       	st	Z, r1
     724:	31 97       	sbiw	r30, 0x01	; 1
     726:	10 82       	st	Z, r1
     728:	31 97       	sbiw	r30, 0x01	; 1
     72a:	10 82       	st	Z, r1
     72c:	31 97       	sbiw	r30, 0x01	; 1
     72e:	62 e0       	ldi	r22, 0x02	; 2
     730:	60 83       	st	Z, r22
     732:	31 97       	sbiw	r30, 0x01	; 1
     734:	63 e0       	ldi	r22, 0x03	; 3
     736:	60 83       	st	Z, r22
     738:	31 97       	sbiw	r30, 0x01	; 1
     73a:	64 e0       	ldi	r22, 0x04	; 4
     73c:	60 83       	st	Z, r22
     73e:	31 97       	sbiw	r30, 0x01	; 1
     740:	65 e0       	ldi	r22, 0x05	; 5
     742:	60 83       	st	Z, r22
     744:	31 97       	sbiw	r30, 0x01	; 1
     746:	66 e0       	ldi	r22, 0x06	; 6
     748:	60 83       	st	Z, r22
     74a:	31 97       	sbiw	r30, 0x01	; 1
     74c:	67 e0       	ldi	r22, 0x07	; 7
     74e:	60 83       	st	Z, r22
     750:	31 97       	sbiw	r30, 0x01	; 1
     752:	68 e0       	ldi	r22, 0x08	; 8
     754:	60 83       	st	Z, r22
     756:	31 97       	sbiw	r30, 0x01	; 1
     758:	69 e0       	ldi	r22, 0x09	; 9
     75a:	60 83       	st	Z, r22
     75c:	31 97       	sbiw	r30, 0x01	; 1
     75e:	60 e1       	ldi	r22, 0x10	; 16
     760:	60 83       	st	Z, r22
     762:	31 97       	sbiw	r30, 0x01	; 1
     764:	30 83       	st	Z, r19
     766:	31 97       	sbiw	r30, 0x01	; 1
     768:	32 e1       	ldi	r19, 0x12	; 18
     76a:	30 83       	st	Z, r19
     76c:	31 97       	sbiw	r30, 0x01	; 1
     76e:	33 e1       	ldi	r19, 0x13	; 19
     770:	30 83       	st	Z, r19
     772:	31 97       	sbiw	r30, 0x01	; 1
     774:	34 e1       	ldi	r19, 0x14	; 20
     776:	30 83       	st	Z, r19
     778:	31 97       	sbiw	r30, 0x01	; 1
     77a:	35 e1       	ldi	r19, 0x15	; 21
     77c:	30 83       	st	Z, r19
     77e:	31 97       	sbiw	r30, 0x01	; 1
     780:	36 e1       	ldi	r19, 0x16	; 22
     782:	30 83       	st	Z, r19
     784:	31 97       	sbiw	r30, 0x01	; 1
     786:	37 e1       	ldi	r19, 0x17	; 23
     788:	30 83       	st	Z, r19
     78a:	31 97       	sbiw	r30, 0x01	; 1
     78c:	38 e1       	ldi	r19, 0x18	; 24
     78e:	30 83       	st	Z, r19
     790:	31 97       	sbiw	r30, 0x01	; 1
     792:	39 e1       	ldi	r19, 0x19	; 25
     794:	30 83       	st	Z, r19
     796:	31 97       	sbiw	r30, 0x01	; 1
     798:	30 e2       	ldi	r19, 0x20	; 32
     79a:	30 83       	st	Z, r19
     79c:	31 97       	sbiw	r30, 0x01	; 1
     79e:	31 e2       	ldi	r19, 0x21	; 33
     7a0:	30 83       	st	Z, r19
     7a2:	31 97       	sbiw	r30, 0x01	; 1
     7a4:	20 83       	st	Z, r18
     7a6:	31 97       	sbiw	r30, 0x01	; 1
     7a8:	23 e2       	ldi	r18, 0x23	; 35
     7aa:	20 83       	st	Z, r18
     7ac:	31 97       	sbiw	r30, 0x01	; 1
     7ae:	40 83       	st	Z, r20
     7b0:	31 97       	sbiw	r30, 0x01	; 1
     7b2:	50 83       	st	Z, r21
     7b4:	31 97       	sbiw	r30, 0x01	; 1
     7b6:	26 e2       	ldi	r18, 0x26	; 38
     7b8:	20 83       	st	Z, r18
     7ba:	31 97       	sbiw	r30, 0x01	; 1
     7bc:	27 e2       	ldi	r18, 0x27	; 39
     7be:	20 83       	st	Z, r18
     7c0:	31 97       	sbiw	r30, 0x01	; 1
     7c2:	28 e2       	ldi	r18, 0x28	; 40
     7c4:	20 83       	st	Z, r18
     7c6:	31 97       	sbiw	r30, 0x01	; 1
     7c8:	29 e2       	ldi	r18, 0x29	; 41
     7ca:	20 83       	st	Z, r18
     7cc:	31 97       	sbiw	r30, 0x01	; 1
     7ce:	20 e3       	ldi	r18, 0x30	; 48
     7d0:	20 83       	st	Z, r18
     7d2:	31 97       	sbiw	r30, 0x01	; 1
     7d4:	21 e3       	ldi	r18, 0x31	; 49
     7d6:	20 83       	st	Z, r18
     7d8:	89 97       	sbiw	r24, 0x29	; 41
     7da:	08 95       	ret

000007dc <xPortStartScheduler>:
     7dc:	88 ec       	ldi	r24, 0xC8	; 200
     7de:	90 e0       	ldi	r25, 0x00	; 0
     7e0:	90 93 a1 14 	sts	0x14A1, r25	; 0x8014a1 <portTickRateHz+0x1>
     7e4:	80 93 a0 14 	sts	0x14A0, r24	; 0x8014a0 <portTickRateHz>
     7e8:	90 93 a3 14 	sts	0x14A3, r25	; 0x8014a3 <ticksRemainingInSec+0x1>
     7ec:	80 93 a2 14 	sts	0x14A2, r24	; 0x8014a2 <ticksRemainingInSec>
     7f0:	84 e0       	ldi	r24, 0x04	; 4
     7f2:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     7f6:	81 ee       	ldi	r24, 0xE1	; 225
     7f8:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
     7fc:	8b e0       	ldi	r24, 0x0B	; 11
     7fe:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
     802:	ef e6       	ldi	r30, 0x6F	; 111
     804:	f0 e0       	ldi	r31, 0x00	; 0
     806:	80 81       	ld	r24, Z
     808:	82 60       	ori	r24, 0x02	; 2
     80a:	80 83       	st	Z, r24
     80c:	a0 91 7c 14 	lds	r26, 0x147C	; 0x80147c <pxCurrentTCB>
     810:	b0 91 7d 14 	lds	r27, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     814:	cd 91       	ld	r28, X+
     816:	cd bf       	out	0x3d, r28	; 61
     818:	dd 91       	ld	r29, X+
     81a:	de bf       	out	0x3e, r29	; 62
     81c:	ff 91       	pop	r31
     81e:	ef 91       	pop	r30
     820:	df 91       	pop	r29
     822:	cf 91       	pop	r28
     824:	bf 91       	pop	r27
     826:	af 91       	pop	r26
     828:	9f 91       	pop	r25
     82a:	8f 91       	pop	r24
     82c:	7f 91       	pop	r23
     82e:	6f 91       	pop	r22
     830:	5f 91       	pop	r21
     832:	4f 91       	pop	r20
     834:	3f 91       	pop	r19
     836:	2f 91       	pop	r18
     838:	1f 91       	pop	r17
     83a:	0f 91       	pop	r16
     83c:	ff 90       	pop	r15
     83e:	ef 90       	pop	r14
     840:	df 90       	pop	r13
     842:	cf 90       	pop	r12
     844:	bf 90       	pop	r11
     846:	af 90       	pop	r10
     848:	9f 90       	pop	r9
     84a:	8f 90       	pop	r8
     84c:	7f 90       	pop	r7
     84e:	6f 90       	pop	r6
     850:	5f 90       	pop	r5
     852:	4f 90       	pop	r4
     854:	3f 90       	pop	r3
     856:	2f 90       	pop	r2
     858:	1f 90       	pop	r1
     85a:	0f 90       	pop	r0
     85c:	0c be       	out	0x3c, r0	; 60
     85e:	0f 90       	pop	r0
     860:	0b be       	out	0x3b, r0	; 59
     862:	0f 90       	pop	r0
     864:	0f be       	out	0x3f, r0	; 63
     866:	0f 90       	pop	r0
     868:	08 95       	ret
     86a:	81 e0       	ldi	r24, 0x01	; 1
     86c:	08 95       	ret

0000086e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     86e:	0f 92       	push	r0
     870:	0f b6       	in	r0, 0x3f	; 63
     872:	f8 94       	cli
     874:	0f 92       	push	r0
     876:	0b b6       	in	r0, 0x3b	; 59
     878:	0f 92       	push	r0
     87a:	0c b6       	in	r0, 0x3c	; 60
     87c:	0f 92       	push	r0
     87e:	1f 92       	push	r1
     880:	11 24       	eor	r1, r1
     882:	2f 92       	push	r2
     884:	3f 92       	push	r3
     886:	4f 92       	push	r4
     888:	5f 92       	push	r5
     88a:	6f 92       	push	r6
     88c:	7f 92       	push	r7
     88e:	8f 92       	push	r8
     890:	9f 92       	push	r9
     892:	af 92       	push	r10
     894:	bf 92       	push	r11
     896:	cf 92       	push	r12
     898:	df 92       	push	r13
     89a:	ef 92       	push	r14
     89c:	ff 92       	push	r15
     89e:	0f 93       	push	r16
     8a0:	1f 93       	push	r17
     8a2:	2f 93       	push	r18
     8a4:	3f 93       	push	r19
     8a6:	4f 93       	push	r20
     8a8:	5f 93       	push	r21
     8aa:	6f 93       	push	r22
     8ac:	7f 93       	push	r23
     8ae:	8f 93       	push	r24
     8b0:	9f 93       	push	r25
     8b2:	af 93       	push	r26
     8b4:	bf 93       	push	r27
     8b6:	cf 93       	push	r28
     8b8:	df 93       	push	r29
     8ba:	ef 93       	push	r30
     8bc:	ff 93       	push	r31
     8be:	a0 91 7c 14 	lds	r26, 0x147C	; 0x80147c <pxCurrentTCB>
     8c2:	b0 91 7d 14 	lds	r27, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     8c6:	0d b6       	in	r0, 0x3d	; 61
     8c8:	0d 92       	st	X+, r0
     8ca:	0e b6       	in	r0, 0x3e	; 62
     8cc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     8ce:	b8 d4       	rcall	.+2416   	; 0x1240 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     8d0:	a0 91 7c 14 	lds	r26, 0x147C	; 0x80147c <pxCurrentTCB>
     8d4:	b0 91 7d 14 	lds	r27, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     8d8:	cd 91       	ld	r28, X+
     8da:	cd bf       	out	0x3d, r28	; 61
     8dc:	dd 91       	ld	r29, X+
     8de:	de bf       	out	0x3e, r29	; 62
     8e0:	ff 91       	pop	r31
     8e2:	ef 91       	pop	r30
     8e4:	df 91       	pop	r29
     8e6:	cf 91       	pop	r28
     8e8:	bf 91       	pop	r27
     8ea:	af 91       	pop	r26
     8ec:	9f 91       	pop	r25
     8ee:	8f 91       	pop	r24
     8f0:	7f 91       	pop	r23
     8f2:	6f 91       	pop	r22
     8f4:	5f 91       	pop	r21
     8f6:	4f 91       	pop	r20
     8f8:	3f 91       	pop	r19
     8fa:	2f 91       	pop	r18
     8fc:	1f 91       	pop	r17
     8fe:	0f 91       	pop	r16
     900:	ff 90       	pop	r15
     902:	ef 90       	pop	r14
     904:	df 90       	pop	r13
     906:	cf 90       	pop	r12
     908:	bf 90       	pop	r11
     90a:	af 90       	pop	r10
     90c:	9f 90       	pop	r9
     90e:	8f 90       	pop	r8
     910:	7f 90       	pop	r7
     912:	6f 90       	pop	r6
     914:	5f 90       	pop	r5
     916:	4f 90       	pop	r4
     918:	3f 90       	pop	r3
     91a:	2f 90       	pop	r2
     91c:	1f 90       	pop	r1
     91e:	0f 90       	pop	r0
     920:	0c be       	out	0x3c, r0	; 60
     922:	0f 90       	pop	r0
     924:	0b be       	out	0x3b, r0	; 59
     926:	0f 90       	pop	r0
     928:	0f be       	out	0x3f, r0	; 63
     92a:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     92c:	08 95       	ret

0000092e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     92e:	0f 92       	push	r0
     930:	0f b6       	in	r0, 0x3f	; 63
     932:	f8 94       	cli
     934:	0f 92       	push	r0
     936:	0b b6       	in	r0, 0x3b	; 59
     938:	0f 92       	push	r0
     93a:	0c b6       	in	r0, 0x3c	; 60
     93c:	0f 92       	push	r0
     93e:	1f 92       	push	r1
     940:	11 24       	eor	r1, r1
     942:	2f 92       	push	r2
     944:	3f 92       	push	r3
     946:	4f 92       	push	r4
     948:	5f 92       	push	r5
     94a:	6f 92       	push	r6
     94c:	7f 92       	push	r7
     94e:	8f 92       	push	r8
     950:	9f 92       	push	r9
     952:	af 92       	push	r10
     954:	bf 92       	push	r11
     956:	cf 92       	push	r12
     958:	df 92       	push	r13
     95a:	ef 92       	push	r14
     95c:	ff 92       	push	r15
     95e:	0f 93       	push	r16
     960:	1f 93       	push	r17
     962:	2f 93       	push	r18
     964:	3f 93       	push	r19
     966:	4f 93       	push	r20
     968:	5f 93       	push	r21
     96a:	6f 93       	push	r22
     96c:	7f 93       	push	r23
     96e:	8f 93       	push	r24
     970:	9f 93       	push	r25
     972:	af 93       	push	r26
     974:	bf 93       	push	r27
     976:	cf 93       	push	r28
     978:	df 93       	push	r29
     97a:	ef 93       	push	r30
     97c:	ff 93       	push	r31
     97e:	a0 91 7c 14 	lds	r26, 0x147C	; 0x80147c <pxCurrentTCB>
     982:	b0 91 7d 14 	lds	r27, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     986:	0d b6       	in	r0, 0x3d	; 61
     988:	0d 92       	st	X+, r0
     98a:	0e b6       	in	r0, 0x3e	; 62
     98c:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
     98e:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
     990:	80 91 a2 14 	lds	r24, 0x14A2	; 0x8014a2 <ticksRemainingInSec>
     994:	90 91 a3 14 	lds	r25, 0x14A3	; 0x8014a3 <ticksRemainingInSec+0x1>
     998:	01 97       	sbiw	r24, 0x01	; 1
     99a:	90 93 a3 14 	sts	0x14A3, r25	; 0x8014a3 <ticksRemainingInSec+0x1>
     99e:	80 93 a2 14 	sts	0x14A2, r24	; 0x8014a2 <ticksRemainingInSec>
     9a2:	89 2b       	or	r24, r25
     9a4:	49 f4       	brne	.+18     	; 0x9b8 <vPortYieldFromTick+0x8a>
	{
		system_tick();
     9a6:	36 dd       	rcall	.-1428   	; 0x414 <system_tick>
		ticksRemainingInSec = portTickRateHz;
     9a8:	80 91 a0 14 	lds	r24, 0x14A0	; 0x8014a0 <portTickRateHz>
     9ac:	90 91 a1 14 	lds	r25, 0x14A1	; 0x8014a1 <portTickRateHz+0x1>
     9b0:	90 93 a3 14 	sts	0x14A3, r25	; 0x8014a3 <ticksRemainingInSec+0x1>
     9b4:	80 93 a2 14 	sts	0x14A2, r24	; 0x8014a2 <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
     9b8:	6d d3       	rcall	.+1754   	; 0x1094 <xTaskIncrementTick>
     9ba:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     9bc:	41 d4       	rcall	.+2178   	; 0x1240 <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
     9be:	a0 91 7c 14 	lds	r26, 0x147C	; 0x80147c <pxCurrentTCB>
     9c2:	b0 91 7d 14 	lds	r27, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     9c6:	cd 91       	ld	r28, X+
     9c8:	cd bf       	out	0x3d, r28	; 61
     9ca:	dd 91       	ld	r29, X+
     9cc:	de bf       	out	0x3e, r29	; 62
     9ce:	ff 91       	pop	r31
     9d0:	ef 91       	pop	r30
     9d2:	df 91       	pop	r29
     9d4:	cf 91       	pop	r28
     9d6:	bf 91       	pop	r27
     9d8:	af 91       	pop	r26
     9da:	9f 91       	pop	r25
     9dc:	8f 91       	pop	r24
     9de:	7f 91       	pop	r23
     9e0:	6f 91       	pop	r22
     9e2:	5f 91       	pop	r21
     9e4:	4f 91       	pop	r20
     9e6:	3f 91       	pop	r19
     9e8:	2f 91       	pop	r18
     9ea:	1f 91       	pop	r17
     9ec:	0f 91       	pop	r16
     9ee:	ff 90       	pop	r15
     9f0:	ef 90       	pop	r14
     9f2:	df 90       	pop	r13
     9f4:	cf 90       	pop	r12
     9f6:	bf 90       	pop	r11
     9f8:	af 90       	pop	r10
     9fa:	9f 90       	pop	r9
     9fc:	8f 90       	pop	r8
     9fe:	7f 90       	pop	r7
     a00:	6f 90       	pop	r6
     a02:	5f 90       	pop	r5
     a04:	4f 90       	pop	r4
     a06:	3f 90       	pop	r3
     a08:	2f 90       	pop	r2
     a0a:	1f 90       	pop	r1
     a0c:	0f 90       	pop	r0
     a0e:	0c be       	out	0x3c, r0	; 60
     a10:	0f 90       	pop	r0
     a12:	0b be       	out	0x3b, r0	; 59
     a14:	0f 90       	pop	r0
     a16:	0f be       	out	0x3f, r0	; 63
     a18:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     a1a:	08 95       	ret

00000a1c <__vector_17>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
     a1c:	88 df       	rcall	.-240    	; 0x92e <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
     a1e:	18 95       	reti

00000a20 <xTaskGenericCreate>:
     a20:	4f 92       	push	r4
     a22:	5f 92       	push	r5
     a24:	6f 92       	push	r6
     a26:	7f 92       	push	r7
     a28:	8f 92       	push	r8
     a2a:	9f 92       	push	r9
     a2c:	af 92       	push	r10
     a2e:	bf 92       	push	r11
     a30:	cf 92       	push	r12
     a32:	df 92       	push	r13
     a34:	ef 92       	push	r14
     a36:	ff 92       	push	r15
     a38:	0f 93       	push	r16
     a3a:	1f 93       	push	r17
     a3c:	cf 93       	push	r28
     a3e:	df 93       	push	r29
     a40:	4c 01       	movw	r8, r24
     a42:	eb 01       	movw	r28, r22
     a44:	5a 01       	movw	r10, r20
     a46:	29 01       	movw	r4, r18
     a48:	c1 14       	cp	r12, r1
     a4a:	d1 04       	cpc	r13, r1
     a4c:	31 f4       	brne	.+12     	; 0xa5a <xTaskGenericCreate+0x3a>
     a4e:	ca 01       	movw	r24, r20
     a50:	c6 dd       	rcall	.-1140   	; 0x5de <pvPortMalloc>
     a52:	6c 01       	movw	r12, r24
     a54:	89 2b       	or	r24, r25
     a56:	09 f4       	brne	.+2      	; 0xa5a <xTaskGenericCreate+0x3a>
     a58:	db c0       	rjmp	.+438    	; 0xc10 <xTaskGenericCreate+0x1f0>
     a5a:	88 e2       	ldi	r24, 0x28	; 40
     a5c:	90 e0       	ldi	r25, 0x00	; 0
     a5e:	bf dd       	rcall	.-1154   	; 0x5de <pvPortMalloc>
     a60:	3c 01       	movw	r6, r24
     a62:	00 97       	sbiw	r24, 0x00	; 0
     a64:	b9 f0       	breq	.+46     	; 0xa94 <xTaskGenericCreate+0x74>
     a66:	fc 01       	movw	r30, r24
     a68:	d0 8e       	std	Z+24, r13	; 0x18
     a6a:	c7 8a       	std	Z+23, r12	; 0x17
     a6c:	a5 01       	movw	r20, r10
     a6e:	65 ea       	ldi	r22, 0xA5	; 165
     a70:	70 e0       	ldi	r23, 0x00	; 0
     a72:	c6 01       	movw	r24, r12
     a74:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <memset>
     a78:	f1 e0       	ldi	r31, 0x01	; 1
     a7a:	af 1a       	sub	r10, r31
     a7c:	b1 08       	sbc	r11, r1
     a7e:	f3 01       	movw	r30, r6
     a80:	87 89       	ldd	r24, Z+23	; 0x17
     a82:	90 8d       	ldd	r25, Z+24	; 0x18
     a84:	a8 0e       	add	r10, r24
     a86:	b9 1e       	adc	r11, r25
     a88:	88 81       	ld	r24, Y
     a8a:	81 8f       	std	Z+25, r24	; 0x19
     a8c:	88 81       	ld	r24, Y
     a8e:	81 11       	cpse	r24, r1
     a90:	04 c0       	rjmp	.+8      	; 0xa9a <xTaskGenericCreate+0x7a>
     a92:	13 c0       	rjmp	.+38     	; 0xaba <xTaskGenericCreate+0x9a>
     a94:	c6 01       	movw	r24, r12
     a96:	d6 dd       	rcall	.-1108   	; 0x644 <vPortFree>
     a98:	bb c0       	rjmp	.+374    	; 0xc10 <xTaskGenericCreate+0x1f0>
     a9a:	d3 01       	movw	r26, r6
     a9c:	5a 96       	adiw	r26, 0x1a	; 26
     a9e:	fe 01       	movw	r30, r28
     aa0:	31 96       	adiw	r30, 0x01	; 1
     aa2:	9e 01       	movw	r18, r28
     aa4:	28 5f       	subi	r18, 0xF8	; 248
     aa6:	3f 4f       	sbci	r19, 0xFF	; 255
     aa8:	ef 01       	movw	r28, r30
     aaa:	81 91       	ld	r24, Z+
     aac:	8d 93       	st	X+, r24
     aae:	88 81       	ld	r24, Y
     ab0:	88 23       	and	r24, r24
     ab2:	19 f0       	breq	.+6      	; 0xaba <xTaskGenericCreate+0x9a>
     ab4:	e2 17       	cp	r30, r18
     ab6:	f3 07       	cpc	r31, r19
     ab8:	b9 f7       	brne	.-18     	; 0xaa8 <xTaskGenericCreate+0x88>
     aba:	f3 01       	movw	r30, r6
     abc:	10 a2       	std	Z+32, r1	; 0x20
     abe:	10 2f       	mov	r17, r16
     ac0:	04 30       	cpi	r16, 0x04	; 4
     ac2:	08 f0       	brcs	.+2      	; 0xac6 <xTaskGenericCreate+0xa6>
     ac4:	13 e0       	ldi	r17, 0x03	; 3
     ac6:	f3 01       	movw	r30, r6
     ac8:	16 8b       	std	Z+22, r17	; 0x16
     aca:	11 a3       	std	Z+33, r17	; 0x21
     acc:	12 a2       	std	Z+34, r1	; 0x22
     ace:	e3 01       	movw	r28, r6
     ad0:	22 96       	adiw	r28, 0x02	; 2
     ad2:	ce 01       	movw	r24, r28
     ad4:	c6 dd       	rcall	.-1140   	; 0x662 <vListInitialiseItem>
     ad6:	c3 01       	movw	r24, r6
     ad8:	0c 96       	adiw	r24, 0x0c	; 12
     ada:	c3 dd       	rcall	.-1146   	; 0x662 <vListInitialiseItem>
     adc:	f3 01       	movw	r30, r6
     ade:	71 86       	std	Z+9, r7	; 0x09
     ae0:	60 86       	std	Z+8, r6	; 0x08
     ae2:	84 e0       	ldi	r24, 0x04	; 4
     ae4:	90 e0       	ldi	r25, 0x00	; 0
     ae6:	81 1b       	sub	r24, r17
     ae8:	91 09       	sbc	r25, r1
     aea:	95 87       	std	Z+13, r25	; 0x0d
     aec:	84 87       	std	Z+12, r24	; 0x0c
     aee:	73 8a       	std	Z+19, r7	; 0x13
     af0:	62 8a       	std	Z+18, r6	; 0x12
     af2:	13 a2       	std	Z+35, r1	; 0x23
     af4:	14 a2       	std	Z+36, r1	; 0x24
     af6:	15 a2       	std	Z+37, r1	; 0x25
     af8:	16 a2       	std	Z+38, r1	; 0x26
     afa:	17 a2       	std	Z+39, r1	; 0x27
     afc:	a2 01       	movw	r20, r4
     afe:	b4 01       	movw	r22, r8
     b00:	c5 01       	movw	r24, r10
     b02:	fa dd       	rcall	.-1036   	; 0x6f8 <pxPortInitialiseStack>
     b04:	f3 01       	movw	r30, r6
     b06:	91 83       	std	Z+1, r25	; 0x01
     b08:	80 83       	st	Z, r24
     b0a:	e1 14       	cp	r14, r1
     b0c:	f1 04       	cpc	r15, r1
     b0e:	19 f0       	breq	.+6      	; 0xb16 <xTaskGenericCreate+0xf6>
     b10:	f7 01       	movw	r30, r14
     b12:	71 82       	std	Z+1, r7	; 0x01
     b14:	60 82       	st	Z, r6
     b16:	0f b6       	in	r0, 0x3f	; 63
     b18:	f8 94       	cli
     b1a:	0f 92       	push	r0
     b1c:	80 91 25 14 	lds	r24, 0x1425	; 0x801425 <uxCurrentNumberOfTasks>
     b20:	8f 5f       	subi	r24, 0xFF	; 255
     b22:	80 93 25 14 	sts	0x1425, r24	; 0x801425 <uxCurrentNumberOfTasks>
     b26:	80 91 7c 14 	lds	r24, 0x147C	; 0x80147c <pxCurrentTCB>
     b2a:	90 91 7d 14 	lds	r25, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     b2e:	89 2b       	or	r24, r25
     b30:	89 f5       	brne	.+98     	; 0xb94 <xTaskGenericCreate+0x174>
     b32:	70 92 7d 14 	sts	0x147D, r7	; 0x80147d <pxCurrentTCB+0x1>
     b36:	60 92 7c 14 	sts	0x147C, r6	; 0x80147c <pxCurrentTCB>
     b3a:	80 91 25 14 	lds	r24, 0x1425	; 0x801425 <uxCurrentNumberOfTasks>
     b3e:	81 30       	cpi	r24, 0x01	; 1
     b40:	09 f0       	breq	.+2      	; 0xb44 <xTaskGenericCreate+0x124>
     b42:	37 c0       	rjmp	.+110    	; 0xbb2 <xTaskGenericCreate+0x192>
     b44:	88 e5       	ldi	r24, 0x58	; 88
     b46:	94 e1       	ldi	r25, 0x14	; 20
     b48:	7e dd       	rcall	.-1284   	; 0x646 <vListInitialise>
     b4a:	81 e6       	ldi	r24, 0x61	; 97
     b4c:	94 e1       	ldi	r25, 0x14	; 20
     b4e:	7b dd       	rcall	.-1290   	; 0x646 <vListInitialise>
     b50:	8a e6       	ldi	r24, 0x6A	; 106
     b52:	94 e1       	ldi	r25, 0x14	; 20
     b54:	78 dd       	rcall	.-1296   	; 0x646 <vListInitialise>
     b56:	83 e7       	ldi	r24, 0x73	; 115
     b58:	94 e1       	ldi	r25, 0x14	; 20
     b5a:	75 dd       	rcall	.-1302   	; 0x646 <vListInitialise>
     b5c:	8f e4       	ldi	r24, 0x4F	; 79
     b5e:	94 e1       	ldi	r25, 0x14	; 20
     b60:	72 dd       	rcall	.-1308   	; 0x646 <vListInitialise>
     b62:	86 e4       	ldi	r24, 0x46	; 70
     b64:	94 e1       	ldi	r25, 0x14	; 20
     b66:	6f dd       	rcall	.-1314   	; 0x646 <vListInitialise>
     b68:	89 e3       	ldi	r24, 0x39	; 57
     b6a:	94 e1       	ldi	r25, 0x14	; 20
     b6c:	6c dd       	rcall	.-1320   	; 0x646 <vListInitialise>
     b6e:	80 e3       	ldi	r24, 0x30	; 48
     b70:	94 e1       	ldi	r25, 0x14	; 20
     b72:	69 dd       	rcall	.-1326   	; 0x646 <vListInitialise>
     b74:	86 e2       	ldi	r24, 0x26	; 38
     b76:	94 e1       	ldi	r25, 0x14	; 20
     b78:	66 dd       	rcall	.-1332   	; 0x646 <vListInitialise>
     b7a:	8f e4       	ldi	r24, 0x4F	; 79
     b7c:	94 e1       	ldi	r25, 0x14	; 20
     b7e:	90 93 45 14 	sts	0x1445, r25	; 0x801445 <pxDelayedTaskList+0x1>
     b82:	80 93 44 14 	sts	0x1444, r24	; 0x801444 <pxDelayedTaskList>
     b86:	86 e4       	ldi	r24, 0x46	; 70
     b88:	94 e1       	ldi	r25, 0x14	; 20
     b8a:	90 93 43 14 	sts	0x1443, r25	; 0x801443 <pxOverflowDelayedTaskList+0x1>
     b8e:	80 93 42 14 	sts	0x1442, r24	; 0x801442 <pxOverflowDelayedTaskList>
     b92:	0f c0       	rjmp	.+30     	; 0xbb2 <xTaskGenericCreate+0x192>
     b94:	80 91 21 14 	lds	r24, 0x1421	; 0x801421 <xSchedulerRunning>
     b98:	81 11       	cpse	r24, r1
     b9a:	0b c0       	rjmp	.+22     	; 0xbb2 <xTaskGenericCreate+0x192>
     b9c:	e0 91 7c 14 	lds	r30, 0x147C	; 0x80147c <pxCurrentTCB>
     ba0:	f0 91 7d 14 	lds	r31, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     ba4:	86 89       	ldd	r24, Z+22	; 0x16
     ba6:	08 17       	cp	r16, r24
     ba8:	20 f0       	brcs	.+8      	; 0xbb2 <xTaskGenericCreate+0x192>
     baa:	70 92 7d 14 	sts	0x147D, r7	; 0x80147d <pxCurrentTCB+0x1>
     bae:	60 92 7c 14 	sts	0x147C, r6	; 0x80147c <pxCurrentTCB>
     bb2:	80 91 1d 14 	lds	r24, 0x141D	; 0x80141d <uxTaskNumber>
     bb6:	8f 5f       	subi	r24, 0xFF	; 255
     bb8:	80 93 1d 14 	sts	0x141D, r24	; 0x80141d <uxTaskNumber>
     bbc:	f3 01       	movw	r30, r6
     bbe:	86 89       	ldd	r24, Z+22	; 0x16
     bc0:	90 91 22 14 	lds	r25, 0x1422	; 0x801422 <uxTopReadyPriority>
     bc4:	98 17       	cp	r25, r24
     bc6:	10 f4       	brcc	.+4      	; 0xbcc <xTaskGenericCreate+0x1ac>
     bc8:	80 93 22 14 	sts	0x1422, r24	; 0x801422 <uxTopReadyPriority>
     bcc:	90 e0       	ldi	r25, 0x00	; 0
     bce:	9c 01       	movw	r18, r24
     bd0:	22 0f       	add	r18, r18
     bd2:	33 1f       	adc	r19, r19
     bd4:	22 0f       	add	r18, r18
     bd6:	33 1f       	adc	r19, r19
     bd8:	22 0f       	add	r18, r18
     bda:	33 1f       	adc	r19, r19
     bdc:	82 0f       	add	r24, r18
     bde:	93 1f       	adc	r25, r19
     be0:	be 01       	movw	r22, r28
     be2:	88 5a       	subi	r24, 0xA8	; 168
     be4:	9b 4e       	sbci	r25, 0xEB	; 235
     be6:	41 dd       	rcall	.-1406   	; 0x66a <vListInsertEnd>
     be8:	0f 90       	pop	r0
     bea:	0f be       	out	0x3f, r0	; 63
     bec:	80 91 21 14 	lds	r24, 0x1421	; 0x801421 <xSchedulerRunning>
     bf0:	88 23       	and	r24, r24
     bf2:	51 f0       	breq	.+20     	; 0xc08 <xTaskGenericCreate+0x1e8>
     bf4:	e0 91 7c 14 	lds	r30, 0x147C	; 0x80147c <pxCurrentTCB>
     bf8:	f0 91 7d 14 	lds	r31, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     bfc:	86 89       	ldd	r24, Z+22	; 0x16
     bfe:	80 17       	cp	r24, r16
     c00:	28 f4       	brcc	.+10     	; 0xc0c <xTaskGenericCreate+0x1ec>
     c02:	35 de       	rcall	.-918    	; 0x86e <vPortYield>
     c04:	81 e0       	ldi	r24, 0x01	; 1
     c06:	05 c0       	rjmp	.+10     	; 0xc12 <xTaskGenericCreate+0x1f2>
     c08:	81 e0       	ldi	r24, 0x01	; 1
     c0a:	03 c0       	rjmp	.+6      	; 0xc12 <xTaskGenericCreate+0x1f2>
     c0c:	81 e0       	ldi	r24, 0x01	; 1
     c0e:	01 c0       	rjmp	.+2      	; 0xc12 <xTaskGenericCreate+0x1f2>
     c10:	8f ef       	ldi	r24, 0xFF	; 255
     c12:	df 91       	pop	r29
     c14:	cf 91       	pop	r28
     c16:	1f 91       	pop	r17
     c18:	0f 91       	pop	r16
     c1a:	ff 90       	pop	r15
     c1c:	ef 90       	pop	r14
     c1e:	df 90       	pop	r13
     c20:	cf 90       	pop	r12
     c22:	bf 90       	pop	r11
     c24:	af 90       	pop	r10
     c26:	9f 90       	pop	r9
     c28:	8f 90       	pop	r8
     c2a:	7f 90       	pop	r7
     c2c:	6f 90       	pop	r6
     c2e:	5f 90       	pop	r5
     c30:	4f 90       	pop	r4
     c32:	08 95       	ret

00000c34 <vTaskStartScheduler>:
     c34:	ef 92       	push	r14
     c36:	ff 92       	push	r15
     c38:	0f 93       	push	r16
     c3a:	1f 93       	push	r17
     c3c:	cf 93       	push	r28
     c3e:	df 93       	push	r29
     c40:	84 e6       	ldi	r24, 0x64	; 100
     c42:	90 e0       	ldi	r25, 0x00	; 0
     c44:	cc dc       	rcall	.-1640   	; 0x5de <pvPortMalloc>
     c46:	8c 01       	movw	r16, r24
     c48:	89 2b       	or	r24, r25
     c4a:	09 f4       	brne	.+2      	; 0xc4e <vTaskStartScheduler+0x1a>
     c4c:	c9 c0       	rjmp	.+402    	; 0xde0 <vTaskStartScheduler+0x1ac>
     c4e:	88 e2       	ldi	r24, 0x28	; 40
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	c5 dc       	rcall	.-1654   	; 0x5de <pvPortMalloc>
     c54:	ec 01       	movw	r28, r24
     c56:	89 2b       	or	r24, r25
     c58:	b1 f0       	breq	.+44     	; 0xc86 <vTaskStartScheduler+0x52>
     c5a:	18 8f       	std	Y+24, r17	; 0x18
     c5c:	0f 8b       	std	Y+23, r16	; 0x17
     c5e:	44 e6       	ldi	r20, 0x64	; 100
     c60:	50 e0       	ldi	r21, 0x00	; 0
     c62:	65 ea       	ldi	r22, 0xA5	; 165
     c64:	70 e0       	ldi	r23, 0x00	; 0
     c66:	c8 01       	movw	r24, r16
     c68:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <memset>
     c6c:	0f 89       	ldd	r16, Y+23	; 0x17
     c6e:	18 8d       	ldd	r17, Y+24	; 0x18
     c70:	0d 59       	subi	r16, 0x9D	; 157
     c72:	1f 4f       	sbci	r17, 0xFF	; 255
     c74:	89 e4       	ldi	r24, 0x49	; 73
     c76:	89 8f       	std	Y+25, r24	; 0x19
     c78:	e2 e1       	ldi	r30, 0x12	; 18
     c7a:	f2 e0       	ldi	r31, 0x02	; 2
     c7c:	de 01       	movw	r26, r28
     c7e:	5a 96       	adiw	r26, 0x1a	; 26
     c80:	29 e1       	ldi	r18, 0x19	; 25
     c82:	32 e0       	ldi	r19, 0x02	; 2
     c84:	03 c0       	rjmp	.+6      	; 0xc8c <vTaskStartScheduler+0x58>
     c86:	c8 01       	movw	r24, r16
     c88:	dd dc       	rcall	.-1606   	; 0x644 <vPortFree>
     c8a:	aa c0       	rjmp	.+340    	; 0xde0 <vTaskStartScheduler+0x1ac>
     c8c:	91 91       	ld	r25, Z+
     c8e:	9d 93       	st	X+, r25
     c90:	99 23       	and	r25, r25
     c92:	19 f0       	breq	.+6      	; 0xc9a <vTaskStartScheduler+0x66>
     c94:	e2 17       	cp	r30, r18
     c96:	f3 07       	cpc	r31, r19
     c98:	c9 f7       	brne	.-14     	; 0xc8c <vTaskStartScheduler+0x58>
     c9a:	18 a2       	std	Y+32, r1	; 0x20
     c9c:	1e 8a       	std	Y+22, r1	; 0x16
     c9e:	19 a2       	std	Y+33, r1	; 0x21
     ca0:	1a a2       	std	Y+34, r1	; 0x22
     ca2:	7e 01       	movw	r14, r28
     ca4:	82 e0       	ldi	r24, 0x02	; 2
     ca6:	e8 0e       	add	r14, r24
     ca8:	f1 1c       	adc	r15, r1
     caa:	c7 01       	movw	r24, r14
     cac:	da dc       	rcall	.-1612   	; 0x662 <vListInitialiseItem>
     cae:	ce 01       	movw	r24, r28
     cb0:	0c 96       	adiw	r24, 0x0c	; 12
     cb2:	d7 dc       	rcall	.-1618   	; 0x662 <vListInitialiseItem>
     cb4:	d9 87       	std	Y+9, r29	; 0x09
     cb6:	c8 87       	std	Y+8, r28	; 0x08
     cb8:	84 e0       	ldi	r24, 0x04	; 4
     cba:	90 e0       	ldi	r25, 0x00	; 0
     cbc:	9d 87       	std	Y+13, r25	; 0x0d
     cbe:	8c 87       	std	Y+12, r24	; 0x0c
     cc0:	db 8b       	std	Y+19, r29	; 0x13
     cc2:	ca 8b       	std	Y+18, r28	; 0x12
     cc4:	1b a2       	std	Y+35, r1	; 0x23
     cc6:	1c a2       	std	Y+36, r1	; 0x24
     cc8:	1d a2       	std	Y+37, r1	; 0x25
     cca:	1e a2       	std	Y+38, r1	; 0x26
     ccc:	1f a2       	std	Y+39, r1	; 0x27
     cce:	40 e0       	ldi	r20, 0x00	; 0
     cd0:	50 e0       	ldi	r21, 0x00	; 0
     cd2:	62 e8       	ldi	r22, 0x82	; 130
     cd4:	70 e0       	ldi	r23, 0x00	; 0
     cd6:	c8 01       	movw	r24, r16
     cd8:	0f dd       	rcall	.-1506   	; 0x6f8 <pxPortInitialiseStack>
     cda:	99 83       	std	Y+1, r25	; 0x01
     cdc:	88 83       	st	Y, r24
     cde:	0f b6       	in	r0, 0x3f	; 63
     ce0:	f8 94       	cli
     ce2:	0f 92       	push	r0
     ce4:	80 91 25 14 	lds	r24, 0x1425	; 0x801425 <uxCurrentNumberOfTasks>
     ce8:	8f 5f       	subi	r24, 0xFF	; 255
     cea:	80 93 25 14 	sts	0x1425, r24	; 0x801425 <uxCurrentNumberOfTasks>
     cee:	80 91 7c 14 	lds	r24, 0x147C	; 0x80147c <pxCurrentTCB>
     cf2:	90 91 7d 14 	lds	r25, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     cf6:	89 2b       	or	r24, r25
     cf8:	89 f5       	brne	.+98     	; 0xd5c <vTaskStartScheduler+0x128>
     cfa:	d0 93 7d 14 	sts	0x147D, r29	; 0x80147d <pxCurrentTCB+0x1>
     cfe:	c0 93 7c 14 	sts	0x147C, r28	; 0x80147c <pxCurrentTCB>
     d02:	80 91 25 14 	lds	r24, 0x1425	; 0x801425 <uxCurrentNumberOfTasks>
     d06:	81 30       	cpi	r24, 0x01	; 1
     d08:	09 f0       	breq	.+2      	; 0xd0c <vTaskStartScheduler+0xd8>
     d0a:	37 c0       	rjmp	.+110    	; 0xd7a <vTaskStartScheduler+0x146>
     d0c:	88 e5       	ldi	r24, 0x58	; 88
     d0e:	94 e1       	ldi	r25, 0x14	; 20
     d10:	9a dc       	rcall	.-1740   	; 0x646 <vListInitialise>
     d12:	81 e6       	ldi	r24, 0x61	; 97
     d14:	94 e1       	ldi	r25, 0x14	; 20
     d16:	97 dc       	rcall	.-1746   	; 0x646 <vListInitialise>
     d18:	8a e6       	ldi	r24, 0x6A	; 106
     d1a:	94 e1       	ldi	r25, 0x14	; 20
     d1c:	94 dc       	rcall	.-1752   	; 0x646 <vListInitialise>
     d1e:	83 e7       	ldi	r24, 0x73	; 115
     d20:	94 e1       	ldi	r25, 0x14	; 20
     d22:	91 dc       	rcall	.-1758   	; 0x646 <vListInitialise>
     d24:	8f e4       	ldi	r24, 0x4F	; 79
     d26:	94 e1       	ldi	r25, 0x14	; 20
     d28:	8e dc       	rcall	.-1764   	; 0x646 <vListInitialise>
     d2a:	86 e4       	ldi	r24, 0x46	; 70
     d2c:	94 e1       	ldi	r25, 0x14	; 20
     d2e:	8b dc       	rcall	.-1770   	; 0x646 <vListInitialise>
     d30:	89 e3       	ldi	r24, 0x39	; 57
     d32:	94 e1       	ldi	r25, 0x14	; 20
     d34:	88 dc       	rcall	.-1776   	; 0x646 <vListInitialise>
     d36:	80 e3       	ldi	r24, 0x30	; 48
     d38:	94 e1       	ldi	r25, 0x14	; 20
     d3a:	85 dc       	rcall	.-1782   	; 0x646 <vListInitialise>
     d3c:	86 e2       	ldi	r24, 0x26	; 38
     d3e:	94 e1       	ldi	r25, 0x14	; 20
     d40:	82 dc       	rcall	.-1788   	; 0x646 <vListInitialise>
     d42:	8f e4       	ldi	r24, 0x4F	; 79
     d44:	94 e1       	ldi	r25, 0x14	; 20
     d46:	90 93 45 14 	sts	0x1445, r25	; 0x801445 <pxDelayedTaskList+0x1>
     d4a:	80 93 44 14 	sts	0x1444, r24	; 0x801444 <pxDelayedTaskList>
     d4e:	86 e4       	ldi	r24, 0x46	; 70
     d50:	94 e1       	ldi	r25, 0x14	; 20
     d52:	90 93 43 14 	sts	0x1443, r25	; 0x801443 <pxOverflowDelayedTaskList+0x1>
     d56:	80 93 42 14 	sts	0x1442, r24	; 0x801442 <pxOverflowDelayedTaskList>
     d5a:	0f c0       	rjmp	.+30     	; 0xd7a <vTaskStartScheduler+0x146>
     d5c:	80 91 21 14 	lds	r24, 0x1421	; 0x801421 <xSchedulerRunning>
     d60:	81 11       	cpse	r24, r1
     d62:	0b c0       	rjmp	.+22     	; 0xd7a <vTaskStartScheduler+0x146>
     d64:	e0 91 7c 14 	lds	r30, 0x147C	; 0x80147c <pxCurrentTCB>
     d68:	f0 91 7d 14 	lds	r31, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     d6c:	86 89       	ldd	r24, Z+22	; 0x16
     d6e:	81 11       	cpse	r24, r1
     d70:	04 c0       	rjmp	.+8      	; 0xd7a <vTaskStartScheduler+0x146>
     d72:	d0 93 7d 14 	sts	0x147D, r29	; 0x80147d <pxCurrentTCB+0x1>
     d76:	c0 93 7c 14 	sts	0x147C, r28	; 0x80147c <pxCurrentTCB>
     d7a:	80 91 1d 14 	lds	r24, 0x141D	; 0x80141d <uxTaskNumber>
     d7e:	8f 5f       	subi	r24, 0xFF	; 255
     d80:	80 93 1d 14 	sts	0x141D, r24	; 0x80141d <uxTaskNumber>
     d84:	2e 89       	ldd	r18, Y+22	; 0x16
     d86:	80 91 22 14 	lds	r24, 0x1422	; 0x801422 <uxTopReadyPriority>
     d8a:	82 17       	cp	r24, r18
     d8c:	10 f4       	brcc	.+4      	; 0xd92 <vTaskStartScheduler+0x15e>
     d8e:	20 93 22 14 	sts	0x1422, r18	; 0x801422 <uxTopReadyPriority>
     d92:	30 e0       	ldi	r19, 0x00	; 0
     d94:	c9 01       	movw	r24, r18
     d96:	88 0f       	add	r24, r24
     d98:	99 1f       	adc	r25, r25
     d9a:	88 0f       	add	r24, r24
     d9c:	99 1f       	adc	r25, r25
     d9e:	88 0f       	add	r24, r24
     da0:	99 1f       	adc	r25, r25
     da2:	82 0f       	add	r24, r18
     da4:	93 1f       	adc	r25, r19
     da6:	b7 01       	movw	r22, r14
     da8:	88 5a       	subi	r24, 0xA8	; 168
     daa:	9b 4e       	sbci	r25, 0xEB	; 235
     dac:	5e dc       	rcall	.-1860   	; 0x66a <vListInsertEnd>
     dae:	0f 90       	pop	r0
     db0:	0f be       	out	0x3f, r0	; 63
     db2:	80 91 21 14 	lds	r24, 0x1421	; 0x801421 <xSchedulerRunning>
     db6:	88 23       	and	r24, r24
     db8:	21 f0       	breq	.+8      	; 0xdc2 <vTaskStartScheduler+0x18e>
     dba:	80 91 7c 14 	lds	r24, 0x147C	; 0x80147c <pxCurrentTCB>
     dbe:	90 91 7d 14 	lds	r25, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     dc2:	f8 94       	cli
     dc4:	8f ef       	ldi	r24, 0xFF	; 255
     dc6:	9f ef       	ldi	r25, 0xFF	; 255
     dc8:	90 93 1c 14 	sts	0x141C, r25	; 0x80141c <xNextTaskUnblockTime+0x1>
     dcc:	80 93 1b 14 	sts	0x141B, r24	; 0x80141b <xNextTaskUnblockTime>
     dd0:	81 e0       	ldi	r24, 0x01	; 1
     dd2:	80 93 21 14 	sts	0x1421, r24	; 0x801421 <xSchedulerRunning>
     dd6:	10 92 24 14 	sts	0x1424, r1	; 0x801424 <xTickCount+0x1>
     dda:	10 92 23 14 	sts	0x1423, r1	; 0x801423 <xTickCount>
     dde:	fe dc       	rcall	.-1540   	; 0x7dc <xPortStartScheduler>
     de0:	df 91       	pop	r29
     de2:	cf 91       	pop	r28
     de4:	1f 91       	pop	r17
     de6:	0f 91       	pop	r16
     de8:	ff 90       	pop	r15
     dea:	ef 90       	pop	r14
     dec:	08 95       	ret

00000dee <vTaskSuspendAll>:
     dee:	80 91 1a 14 	lds	r24, 0x141A	; 0x80141a <uxSchedulerSuspended>
     df2:	8f 5f       	subi	r24, 0xFF	; 255
     df4:	80 93 1a 14 	sts	0x141A, r24	; 0x80141a <uxSchedulerSuspended>
     df8:	08 95       	ret

00000dfa <xTaskResumeAll>:
     dfa:	9f 92       	push	r9
     dfc:	af 92       	push	r10
     dfe:	bf 92       	push	r11
     e00:	cf 92       	push	r12
     e02:	df 92       	push	r13
     e04:	ef 92       	push	r14
     e06:	ff 92       	push	r15
     e08:	0f 93       	push	r16
     e0a:	1f 93       	push	r17
     e0c:	cf 93       	push	r28
     e0e:	df 93       	push	r29
     e10:	0f b6       	in	r0, 0x3f	; 63
     e12:	f8 94       	cli
     e14:	0f 92       	push	r0
     e16:	80 91 1a 14 	lds	r24, 0x141A	; 0x80141a <uxSchedulerSuspended>
     e1a:	81 50       	subi	r24, 0x01	; 1
     e1c:	80 93 1a 14 	sts	0x141A, r24	; 0x80141a <uxSchedulerSuspended>
     e20:	80 91 1a 14 	lds	r24, 0x141A	; 0x80141a <uxSchedulerSuspended>
     e24:	81 11       	cpse	r24, r1
     e26:	21 c1       	rjmp	.+578    	; 0x106a <xTaskResumeAll+0x270>
     e28:	80 91 25 14 	lds	r24, 0x1425	; 0x801425 <uxCurrentNumberOfTasks>
     e2c:	81 11       	cpse	r24, r1
     e2e:	30 c0       	rjmp	.+96     	; 0xe90 <xTaskResumeAll+0x96>
     e30:	1f c1       	rjmp	.+574    	; 0x1070 <xTaskResumeAll+0x276>
     e32:	d7 01       	movw	r26, r14
     e34:	15 96       	adiw	r26, 0x05	; 5
     e36:	ed 91       	ld	r30, X+
     e38:	fc 91       	ld	r31, X
     e3a:	16 97       	sbiw	r26, 0x06	; 6
     e3c:	c6 81       	ldd	r28, Z+6	; 0x06
     e3e:	d7 81       	ldd	r29, Z+7	; 0x07
     e40:	ce 01       	movw	r24, r28
     e42:	0c 96       	adiw	r24, 0x0c	; 12
     e44:	33 dc       	rcall	.-1946   	; 0x6ac <uxListRemove>
     e46:	8e 01       	movw	r16, r28
     e48:	0e 5f       	subi	r16, 0xFE	; 254
     e4a:	1f 4f       	sbci	r17, 0xFF	; 255
     e4c:	c8 01       	movw	r24, r16
     e4e:	2e dc       	rcall	.-1956   	; 0x6ac <uxListRemove>
     e50:	2e 89       	ldd	r18, Y+22	; 0x16
     e52:	80 91 22 14 	lds	r24, 0x1422	; 0x801422 <uxTopReadyPriority>
     e56:	82 17       	cp	r24, r18
     e58:	10 f4       	brcc	.+4      	; 0xe5e <xTaskResumeAll+0x64>
     e5a:	20 93 22 14 	sts	0x1422, r18	; 0x801422 <uxTopReadyPriority>
     e5e:	30 e0       	ldi	r19, 0x00	; 0
     e60:	c9 01       	movw	r24, r18
     e62:	88 0f       	add	r24, r24
     e64:	99 1f       	adc	r25, r25
     e66:	88 0f       	add	r24, r24
     e68:	99 1f       	adc	r25, r25
     e6a:	88 0f       	add	r24, r24
     e6c:	99 1f       	adc	r25, r25
     e6e:	82 0f       	add	r24, r18
     e70:	93 1f       	adc	r25, r19
     e72:	b8 01       	movw	r22, r16
     e74:	88 5a       	subi	r24, 0xA8	; 168
     e76:	9b 4e       	sbci	r25, 0xEB	; 235
     e78:	f8 db       	rcall	.-2064   	; 0x66a <vListInsertEnd>
     e7a:	e0 91 7c 14 	lds	r30, 0x147C	; 0x80147c <pxCurrentTCB>
     e7e:	f0 91 7d 14 	lds	r31, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     e82:	9e 89       	ldd	r25, Y+22	; 0x16
     e84:	86 89       	ldd	r24, Z+22	; 0x16
     e86:	98 17       	cp	r25, r24
     e88:	58 f0       	brcs	.+22     	; 0xea0 <xTaskResumeAll+0xa6>
     e8a:	d0 92 1f 14 	sts	0x141F, r13	; 0x80141f <xYieldPending>
     e8e:	08 c0       	rjmp	.+16     	; 0xea0 <xTaskResumeAll+0xa6>
     e90:	0f 2e       	mov	r0, r31
     e92:	f9 e3       	ldi	r31, 0x39	; 57
     e94:	ef 2e       	mov	r14, r31
     e96:	f4 e1       	ldi	r31, 0x14	; 20
     e98:	ff 2e       	mov	r15, r31
     e9a:	f0 2d       	mov	r31, r0
     e9c:	dd 24       	eor	r13, r13
     e9e:	d3 94       	inc	r13
     ea0:	f7 01       	movw	r30, r14
     ea2:	80 81       	ld	r24, Z
     ea4:	81 11       	cpse	r24, r1
     ea6:	c5 cf       	rjmp	.-118    	; 0xe32 <xTaskResumeAll+0x38>
     ea8:	80 91 20 14 	lds	r24, 0x1420	; 0x801420 <uxPendedTicks>
     eac:	88 23       	and	r24, r24
     eae:	09 f4       	brne	.+2      	; 0xeb2 <xTaskResumeAll+0xb8>
     eb0:	d5 c0       	rjmp	.+426    	; 0x105c <xTaskResumeAll+0x262>
     eb2:	80 91 20 14 	lds	r24, 0x1420	; 0x801420 <uxPendedTicks>
     eb6:	88 23       	and	r24, r24
     eb8:	09 f4       	brne	.+2      	; 0xebc <xTaskResumeAll+0xc2>
     eba:	d0 c0       	rjmp	.+416    	; 0x105c <xTaskResumeAll+0x262>
     ebc:	91 2c       	mov	r9, r1
     ebe:	aa 24       	eor	r10, r10
     ec0:	a3 94       	inc	r10
     ec2:	cc 24       	eor	r12, r12
     ec4:	ca 94       	dec	r12
     ec6:	dc 2c       	mov	r13, r12
     ec8:	80 91 1a 14 	lds	r24, 0x141A	; 0x80141a <uxSchedulerSuspended>
     ecc:	81 11       	cpse	r24, r1
     ece:	ac c0       	rjmp	.+344    	; 0x1028 <xTaskResumeAll+0x22e>
     ed0:	80 91 23 14 	lds	r24, 0x1423	; 0x801423 <xTickCount>
     ed4:	90 91 24 14 	lds	r25, 0x1424	; 0x801424 <xTickCount+0x1>
     ed8:	01 96       	adiw	r24, 0x01	; 1
     eda:	90 93 24 14 	sts	0x1424, r25	; 0x801424 <xTickCount+0x1>
     ede:	80 93 23 14 	sts	0x1423, r24	; 0x801423 <xTickCount>
     ee2:	e0 90 23 14 	lds	r14, 0x1423	; 0x801423 <xTickCount>
     ee6:	f0 90 24 14 	lds	r15, 0x1424	; 0x801424 <xTickCount+0x1>
     eea:	e1 14       	cp	r14, r1
     eec:	f1 04       	cpc	r15, r1
     eee:	89 f5       	brne	.+98     	; 0xf52 <xTaskResumeAll+0x158>
     ef0:	80 91 44 14 	lds	r24, 0x1444	; 0x801444 <pxDelayedTaskList>
     ef4:	90 91 45 14 	lds	r25, 0x1445	; 0x801445 <pxDelayedTaskList+0x1>
     ef8:	20 91 42 14 	lds	r18, 0x1442	; 0x801442 <pxOverflowDelayedTaskList>
     efc:	30 91 43 14 	lds	r19, 0x1443	; 0x801443 <pxOverflowDelayedTaskList+0x1>
     f00:	30 93 45 14 	sts	0x1445, r19	; 0x801445 <pxDelayedTaskList+0x1>
     f04:	20 93 44 14 	sts	0x1444, r18	; 0x801444 <pxDelayedTaskList>
     f08:	90 93 43 14 	sts	0x1443, r25	; 0x801443 <pxOverflowDelayedTaskList+0x1>
     f0c:	80 93 42 14 	sts	0x1442, r24	; 0x801442 <pxOverflowDelayedTaskList>
     f10:	80 91 1e 14 	lds	r24, 0x141E	; 0x80141e <xNumOfOverflows>
     f14:	8f 5f       	subi	r24, 0xFF	; 255
     f16:	80 93 1e 14 	sts	0x141E, r24	; 0x80141e <xNumOfOverflows>
     f1a:	e0 91 44 14 	lds	r30, 0x1444	; 0x801444 <pxDelayedTaskList>
     f1e:	f0 91 45 14 	lds	r31, 0x1445	; 0x801445 <pxDelayedTaskList+0x1>
     f22:	80 81       	ld	r24, Z
     f24:	81 11       	cpse	r24, r1
     f26:	05 c0       	rjmp	.+10     	; 0xf32 <xTaskResumeAll+0x138>
     f28:	d0 92 1c 14 	sts	0x141C, r13	; 0x80141c <xNextTaskUnblockTime+0x1>
     f2c:	c0 92 1b 14 	sts	0x141B, r12	; 0x80141b <xNextTaskUnblockTime>
     f30:	10 c0       	rjmp	.+32     	; 0xf52 <xTaskResumeAll+0x158>
     f32:	e0 91 44 14 	lds	r30, 0x1444	; 0x801444 <pxDelayedTaskList>
     f36:	f0 91 45 14 	lds	r31, 0x1445	; 0x801445 <pxDelayedTaskList+0x1>
     f3a:	05 80       	ldd	r0, Z+5	; 0x05
     f3c:	f6 81       	ldd	r31, Z+6	; 0x06
     f3e:	e0 2d       	mov	r30, r0
     f40:	06 80       	ldd	r0, Z+6	; 0x06
     f42:	f7 81       	ldd	r31, Z+7	; 0x07
     f44:	e0 2d       	mov	r30, r0
     f46:	82 81       	ldd	r24, Z+2	; 0x02
     f48:	93 81       	ldd	r25, Z+3	; 0x03
     f4a:	90 93 1c 14 	sts	0x141C, r25	; 0x80141c <xNextTaskUnblockTime+0x1>
     f4e:	80 93 1b 14 	sts	0x141B, r24	; 0x80141b <xNextTaskUnblockTime>
     f52:	80 91 1b 14 	lds	r24, 0x141B	; 0x80141b <xNextTaskUnblockTime>
     f56:	90 91 1c 14 	lds	r25, 0x141C	; 0x80141c <xNextTaskUnblockTime+0x1>
     f5a:	e8 16       	cp	r14, r24
     f5c:	f9 06       	cpc	r15, r25
     f5e:	10 f4       	brcc	.+4      	; 0xf64 <xTaskResumeAll+0x16a>
     f60:	b9 2c       	mov	r11, r9
     f62:	4c c0       	rjmp	.+152    	; 0xffc <xTaskResumeAll+0x202>
     f64:	b9 2c       	mov	r11, r9
     f66:	e0 91 44 14 	lds	r30, 0x1444	; 0x801444 <pxDelayedTaskList>
     f6a:	f0 91 45 14 	lds	r31, 0x1445	; 0x801445 <pxDelayedTaskList+0x1>
     f6e:	80 81       	ld	r24, Z
     f70:	81 11       	cpse	r24, r1
     f72:	05 c0       	rjmp	.+10     	; 0xf7e <xTaskResumeAll+0x184>
     f74:	d0 92 1c 14 	sts	0x141C, r13	; 0x80141c <xNextTaskUnblockTime+0x1>
     f78:	c0 92 1b 14 	sts	0x141B, r12	; 0x80141b <xNextTaskUnblockTime>
     f7c:	3f c0       	rjmp	.+126    	; 0xffc <xTaskResumeAll+0x202>
     f7e:	e0 91 44 14 	lds	r30, 0x1444	; 0x801444 <pxDelayedTaskList>
     f82:	f0 91 45 14 	lds	r31, 0x1445	; 0x801445 <pxDelayedTaskList+0x1>
     f86:	05 80       	ldd	r0, Z+5	; 0x05
     f88:	f6 81       	ldd	r31, Z+6	; 0x06
     f8a:	e0 2d       	mov	r30, r0
     f8c:	c6 81       	ldd	r28, Z+6	; 0x06
     f8e:	d7 81       	ldd	r29, Z+7	; 0x07
     f90:	8a 81       	ldd	r24, Y+2	; 0x02
     f92:	9b 81       	ldd	r25, Y+3	; 0x03
     f94:	e8 16       	cp	r14, r24
     f96:	f9 06       	cpc	r15, r25
     f98:	28 f4       	brcc	.+10     	; 0xfa4 <xTaskResumeAll+0x1aa>
     f9a:	90 93 1c 14 	sts	0x141C, r25	; 0x80141c <xNextTaskUnblockTime+0x1>
     f9e:	80 93 1b 14 	sts	0x141B, r24	; 0x80141b <xNextTaskUnblockTime>
     fa2:	2c c0       	rjmp	.+88     	; 0xffc <xTaskResumeAll+0x202>
     fa4:	8e 01       	movw	r16, r28
     fa6:	0e 5f       	subi	r16, 0xFE	; 254
     fa8:	1f 4f       	sbci	r17, 0xFF	; 255
     faa:	c8 01       	movw	r24, r16
     fac:	7f db       	rcall	.-2306   	; 0x6ac <uxListRemove>
     fae:	8c 89       	ldd	r24, Y+20	; 0x14
     fb0:	9d 89       	ldd	r25, Y+21	; 0x15
     fb2:	89 2b       	or	r24, r25
     fb4:	19 f0       	breq	.+6      	; 0xfbc <xTaskResumeAll+0x1c2>
     fb6:	ce 01       	movw	r24, r28
     fb8:	0c 96       	adiw	r24, 0x0c	; 12
     fba:	78 db       	rcall	.-2320   	; 0x6ac <uxListRemove>
     fbc:	2e 89       	ldd	r18, Y+22	; 0x16
     fbe:	80 91 22 14 	lds	r24, 0x1422	; 0x801422 <uxTopReadyPriority>
     fc2:	82 17       	cp	r24, r18
     fc4:	10 f4       	brcc	.+4      	; 0xfca <xTaskResumeAll+0x1d0>
     fc6:	20 93 22 14 	sts	0x1422, r18	; 0x801422 <uxTopReadyPriority>
     fca:	30 e0       	ldi	r19, 0x00	; 0
     fcc:	c9 01       	movw	r24, r18
     fce:	88 0f       	add	r24, r24
     fd0:	99 1f       	adc	r25, r25
     fd2:	88 0f       	add	r24, r24
     fd4:	99 1f       	adc	r25, r25
     fd6:	88 0f       	add	r24, r24
     fd8:	99 1f       	adc	r25, r25
     fda:	82 0f       	add	r24, r18
     fdc:	93 1f       	adc	r25, r19
     fde:	b8 01       	movw	r22, r16
     fe0:	88 5a       	subi	r24, 0xA8	; 168
     fe2:	9b 4e       	sbci	r25, 0xEB	; 235
     fe4:	42 db       	rcall	.-2428   	; 0x66a <vListInsertEnd>
     fe6:	e0 91 7c 14 	lds	r30, 0x147C	; 0x80147c <pxCurrentTCB>
     fea:	f0 91 7d 14 	lds	r31, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
     fee:	9e 89       	ldd	r25, Y+22	; 0x16
     ff0:	86 89       	ldd	r24, Z+22	; 0x16
     ff2:	98 17       	cp	r25, r24
     ff4:	08 f4       	brcc	.+2      	; 0xff8 <xTaskResumeAll+0x1fe>
     ff6:	b7 cf       	rjmp	.-146    	; 0xf66 <xTaskResumeAll+0x16c>
     ff8:	ba 2c       	mov	r11, r10
     ffa:	b5 cf       	rjmp	.-150    	; 0xf66 <xTaskResumeAll+0x16c>
     ffc:	e0 91 7c 14 	lds	r30, 0x147C	; 0x80147c <pxCurrentTCB>
    1000:	f0 91 7d 14 	lds	r31, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
    1004:	86 89       	ldd	r24, Z+22	; 0x16
    1006:	90 e0       	ldi	r25, 0x00	; 0
    1008:	fc 01       	movw	r30, r24
    100a:	ee 0f       	add	r30, r30
    100c:	ff 1f       	adc	r31, r31
    100e:	ee 0f       	add	r30, r30
    1010:	ff 1f       	adc	r31, r31
    1012:	ee 0f       	add	r30, r30
    1014:	ff 1f       	adc	r31, r31
    1016:	8e 0f       	add	r24, r30
    1018:	9f 1f       	adc	r25, r31
    101a:	fc 01       	movw	r30, r24
    101c:	e8 5a       	subi	r30, 0xA8	; 168
    101e:	fb 4e       	sbci	r31, 0xEB	; 235
    1020:	80 81       	ld	r24, Z
    1022:	82 30       	cpi	r24, 0x02	; 2
    1024:	40 f5       	brcc	.+80     	; 0x1076 <xTaskResumeAll+0x27c>
    1026:	0a c0       	rjmp	.+20     	; 0x103c <xTaskResumeAll+0x242>
    1028:	80 91 20 14 	lds	r24, 0x1420	; 0x801420 <uxPendedTicks>
    102c:	8f 5f       	subi	r24, 0xFF	; 255
    102e:	80 93 20 14 	sts	0x1420, r24	; 0x801420 <uxPendedTicks>
    1032:	80 91 1f 14 	lds	r24, 0x141F	; 0x80141f <xYieldPending>
    1036:	81 11       	cpse	r24, r1
    1038:	06 c0       	rjmp	.+12     	; 0x1046 <xTaskResumeAll+0x24c>
    103a:	07 c0       	rjmp	.+14     	; 0x104a <xTaskResumeAll+0x250>
    103c:	80 91 1f 14 	lds	r24, 0x141F	; 0x80141f <xYieldPending>
    1040:	81 11       	cpse	r24, r1
    1042:	01 c0       	rjmp	.+2      	; 0x1046 <xTaskResumeAll+0x24c>
    1044:	b1 10       	cpse	r11, r1
    1046:	a0 92 1f 14 	sts	0x141F, r10	; 0x80141f <xYieldPending>
    104a:	80 91 20 14 	lds	r24, 0x1420	; 0x801420 <uxPendedTicks>
    104e:	81 50       	subi	r24, 0x01	; 1
    1050:	80 93 20 14 	sts	0x1420, r24	; 0x801420 <uxPendedTicks>
    1054:	80 91 20 14 	lds	r24, 0x1420	; 0x801420 <uxPendedTicks>
    1058:	81 11       	cpse	r24, r1
    105a:	36 cf       	rjmp	.-404    	; 0xec8 <xTaskResumeAll+0xce>
    105c:	80 91 1f 14 	lds	r24, 0x141F	; 0x80141f <xYieldPending>
    1060:	81 30       	cpi	r24, 0x01	; 1
    1062:	29 f4       	brne	.+10     	; 0x106e <xTaskResumeAll+0x274>
    1064:	04 dc       	rcall	.-2040   	; 0x86e <vPortYield>
    1066:	81 e0       	ldi	r24, 0x01	; 1
    1068:	03 c0       	rjmp	.+6      	; 0x1070 <xTaskResumeAll+0x276>
    106a:	80 e0       	ldi	r24, 0x00	; 0
    106c:	01 c0       	rjmp	.+2      	; 0x1070 <xTaskResumeAll+0x276>
    106e:	80 e0       	ldi	r24, 0x00	; 0
    1070:	0f 90       	pop	r0
    1072:	0f be       	out	0x3f, r0	; 63
    1074:	03 c0       	rjmp	.+6      	; 0x107c <xTaskResumeAll+0x282>
    1076:	80 91 1f 14 	lds	r24, 0x141F	; 0x80141f <xYieldPending>
    107a:	e5 cf       	rjmp	.-54     	; 0x1046 <xTaskResumeAll+0x24c>
    107c:	df 91       	pop	r29
    107e:	cf 91       	pop	r28
    1080:	1f 91       	pop	r17
    1082:	0f 91       	pop	r16
    1084:	ff 90       	pop	r15
    1086:	ef 90       	pop	r14
    1088:	df 90       	pop	r13
    108a:	cf 90       	pop	r12
    108c:	bf 90       	pop	r11
    108e:	af 90       	pop	r10
    1090:	9f 90       	pop	r9
    1092:	08 95       	ret

00001094 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    1094:	cf 92       	push	r12
    1096:	df 92       	push	r13
    1098:	ef 92       	push	r14
    109a:	ff 92       	push	r15
    109c:	0f 93       	push	r16
    109e:	1f 93       	push	r17
    10a0:	cf 93       	push	r28
    10a2:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    10a4:	80 91 1a 14 	lds	r24, 0x141A	; 0x80141a <uxSchedulerSuspended>
    10a8:	81 11       	cpse	r24, r1
    10aa:	b4 c0       	rjmp	.+360    	; 0x1214 <xTaskIncrementTick+0x180>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    10ac:	80 91 23 14 	lds	r24, 0x1423	; 0x801423 <xTickCount>
    10b0:	90 91 24 14 	lds	r25, 0x1424	; 0x801424 <xTickCount+0x1>
    10b4:	01 96       	adiw	r24, 0x01	; 1
    10b6:	90 93 24 14 	sts	0x1424, r25	; 0x801424 <xTickCount+0x1>
    10ba:	80 93 23 14 	sts	0x1423, r24	; 0x801423 <xTickCount>

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    10be:	e0 90 23 14 	lds	r14, 0x1423	; 0x801423 <xTickCount>
    10c2:	f0 90 24 14 	lds	r15, 0x1424	; 0x801424 <xTickCount+0x1>

			if( xConstTickCount == ( TickType_t ) 0U )
    10c6:	e1 14       	cp	r14, r1
    10c8:	f1 04       	cpc	r15, r1
    10ca:	99 f5       	brne	.+102    	; 0x1132 <xTaskIncrementTick+0x9e>
			{
				taskSWITCH_DELAYED_LISTS();
    10cc:	80 91 44 14 	lds	r24, 0x1444	; 0x801444 <pxDelayedTaskList>
    10d0:	90 91 45 14 	lds	r25, 0x1445	; 0x801445 <pxDelayedTaskList+0x1>
    10d4:	20 91 42 14 	lds	r18, 0x1442	; 0x801442 <pxOverflowDelayedTaskList>
    10d8:	30 91 43 14 	lds	r19, 0x1443	; 0x801443 <pxOverflowDelayedTaskList+0x1>
    10dc:	30 93 45 14 	sts	0x1445, r19	; 0x801445 <pxDelayedTaskList+0x1>
    10e0:	20 93 44 14 	sts	0x1444, r18	; 0x801444 <pxDelayedTaskList>
    10e4:	90 93 43 14 	sts	0x1443, r25	; 0x801443 <pxOverflowDelayedTaskList+0x1>
    10e8:	80 93 42 14 	sts	0x1442, r24	; 0x801442 <pxOverflowDelayedTaskList>
    10ec:	80 91 1e 14 	lds	r24, 0x141E	; 0x80141e <xNumOfOverflows>
    10f0:	8f 5f       	subi	r24, 0xFF	; 255
    10f2:	80 93 1e 14 	sts	0x141E, r24	; 0x80141e <xNumOfOverflows>

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    10f6:	e0 91 44 14 	lds	r30, 0x1444	; 0x801444 <pxDelayedTaskList>
    10fa:	f0 91 45 14 	lds	r31, 0x1445	; 0x801445 <pxDelayedTaskList+0x1>
    10fe:	80 81       	ld	r24, Z
    1100:	81 11       	cpse	r24, r1
    1102:	07 c0       	rjmp	.+14     	; 0x1112 <xTaskIncrementTick+0x7e>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1104:	8f ef       	ldi	r24, 0xFF	; 255
    1106:	9f ef       	ldi	r25, 0xFF	; 255
    1108:	90 93 1c 14 	sts	0x141C, r25	; 0x80141c <xNextTaskUnblockTime+0x1>
    110c:	80 93 1b 14 	sts	0x141B, r24	; 0x80141b <xNextTaskUnblockTime>
    1110:	10 c0       	rjmp	.+32     	; 0x1132 <xTaskIncrementTick+0x9e>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1112:	e0 91 44 14 	lds	r30, 0x1444	; 0x801444 <pxDelayedTaskList>
    1116:	f0 91 45 14 	lds	r31, 0x1445	; 0x801445 <pxDelayedTaskList+0x1>
    111a:	05 80       	ldd	r0, Z+5	; 0x05
    111c:	f6 81       	ldd	r31, Z+6	; 0x06
    111e:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    1120:	06 80       	ldd	r0, Z+6	; 0x06
    1122:	f7 81       	ldd	r31, Z+7	; 0x07
    1124:	e0 2d       	mov	r30, r0
    1126:	82 81       	ldd	r24, Z+2	; 0x02
    1128:	93 81       	ldd	r25, Z+3	; 0x03
    112a:	90 93 1c 14 	sts	0x141C, r25	; 0x80141c <xNextTaskUnblockTime+0x1>
    112e:	80 93 1b 14 	sts	0x141B, r24	; 0x80141b <xNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    1132:	80 91 1b 14 	lds	r24, 0x141B	; 0x80141b <xNextTaskUnblockTime>
    1136:	90 91 1c 14 	lds	r25, 0x141C	; 0x80141c <xNextTaskUnblockTime+0x1>
    113a:	e8 16       	cp	r14, r24
    113c:	f9 06       	cpc	r15, r25
    113e:	10 f4       	brcc	.+4      	; 0x1144 <xTaskIncrementTick+0xb0>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1140:	d1 2c       	mov	r13, r1
    1142:	50 c0       	rjmp	.+160    	; 0x11e4 <xTaskIncrementTick+0x150>
    1144:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
    1146:	cc 24       	eor	r12, r12
    1148:	c3 94       	inc	r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    114a:	e0 91 44 14 	lds	r30, 0x1444	; 0x801444 <pxDelayedTaskList>
    114e:	f0 91 45 14 	lds	r31, 0x1445	; 0x801445 <pxDelayedTaskList+0x1>
    1152:	90 81       	ld	r25, Z
    1154:	91 11       	cpse	r25, r1
    1156:	07 c0       	rjmp	.+14     	; 0x1166 <xTaskIncrementTick+0xd2>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    1158:	8f ef       	ldi	r24, 0xFF	; 255
    115a:	9f ef       	ldi	r25, 0xFF	; 255
    115c:	90 93 1c 14 	sts	0x141C, r25	; 0x80141c <xNextTaskUnblockTime+0x1>
    1160:	80 93 1b 14 	sts	0x141B, r24	; 0x80141b <xNextTaskUnblockTime>
						break;
    1164:	3f c0       	rjmp	.+126    	; 0x11e4 <xTaskIncrementTick+0x150>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1166:	e0 91 44 14 	lds	r30, 0x1444	; 0x801444 <pxDelayedTaskList>
    116a:	f0 91 45 14 	lds	r31, 0x1445	; 0x801445 <pxDelayedTaskList+0x1>
    116e:	05 80       	ldd	r0, Z+5	; 0x05
    1170:	f6 81       	ldd	r31, Z+6	; 0x06
    1172:	e0 2d       	mov	r30, r0
    1174:	c6 81       	ldd	r28, Z+6	; 0x06
    1176:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1178:	2a 81       	ldd	r18, Y+2	; 0x02
    117a:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
    117c:	e2 16       	cp	r14, r18
    117e:	f3 06       	cpc	r15, r19
    1180:	28 f4       	brcc	.+10     	; 0x118c <xTaskIncrementTick+0xf8>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    1182:	30 93 1c 14 	sts	0x141C, r19	; 0x80141c <xNextTaskUnblockTime+0x1>
    1186:	20 93 1b 14 	sts	0x141B, r18	; 0x80141b <xNextTaskUnblockTime>
							break;
    118a:	2c c0       	rjmp	.+88     	; 0x11e4 <xTaskIncrementTick+0x150>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    118c:	8e 01       	movw	r16, r28
    118e:	0e 5f       	subi	r16, 0xFE	; 254
    1190:	1f 4f       	sbci	r17, 0xFF	; 255
    1192:	c8 01       	movw	r24, r16
    1194:	8b da       	rcall	.-2794   	; 0x6ac <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1196:	8c 89       	ldd	r24, Y+20	; 0x14
    1198:	9d 89       	ldd	r25, Y+21	; 0x15
    119a:	89 2b       	or	r24, r25
    119c:	19 f0       	breq	.+6      	; 0x11a4 <xTaskIncrementTick+0x110>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    119e:	ce 01       	movw	r24, r28
    11a0:	0c 96       	adiw	r24, 0x0c	; 12
    11a2:	84 da       	rcall	.-2808   	; 0x6ac <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    11a4:	2e 89       	ldd	r18, Y+22	; 0x16
    11a6:	80 91 22 14 	lds	r24, 0x1422	; 0x801422 <uxTopReadyPriority>
    11aa:	82 17       	cp	r24, r18
    11ac:	10 f4       	brcc	.+4      	; 0x11b2 <xTaskIncrementTick+0x11e>
    11ae:	20 93 22 14 	sts	0x1422, r18	; 0x801422 <uxTopReadyPriority>
    11b2:	30 e0       	ldi	r19, 0x00	; 0
    11b4:	c9 01       	movw	r24, r18
    11b6:	88 0f       	add	r24, r24
    11b8:	99 1f       	adc	r25, r25
    11ba:	88 0f       	add	r24, r24
    11bc:	99 1f       	adc	r25, r25
    11be:	88 0f       	add	r24, r24
    11c0:	99 1f       	adc	r25, r25
    11c2:	82 0f       	add	r24, r18
    11c4:	93 1f       	adc	r25, r19
    11c6:	b8 01       	movw	r22, r16
    11c8:	88 5a       	subi	r24, 0xA8	; 168
    11ca:	9b 4e       	sbci	r25, 0xEB	; 235
    11cc:	4e da       	rcall	.-2916   	; 0x66a <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    11ce:	e0 91 7c 14 	lds	r30, 0x147C	; 0x80147c <pxCurrentTCB>
    11d2:	f0 91 7d 14 	lds	r31, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
    11d6:	9e 89       	ldd	r25, Y+22	; 0x16
    11d8:	86 89       	ldd	r24, Z+22	; 0x16
    11da:	98 17       	cp	r25, r24
    11dc:	08 f4       	brcc	.+2      	; 0x11e0 <xTaskIncrementTick+0x14c>
    11de:	b5 cf       	rjmp	.-150    	; 0x114a <xTaskIncrementTick+0xb6>
							{
								xSwitchRequired = pdTRUE;
    11e0:	dc 2c       	mov	r13, r12
    11e2:	b3 cf       	rjmp	.-154    	; 0x114a <xTaskIncrementTick+0xb6>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    11e4:	e0 91 7c 14 	lds	r30, 0x147C	; 0x80147c <pxCurrentTCB>
    11e8:	f0 91 7d 14 	lds	r31, 0x147D	; 0x80147d <pxCurrentTCB+0x1>
    11ec:	86 89       	ldd	r24, Z+22	; 0x16
    11ee:	90 e0       	ldi	r25, 0x00	; 0
    11f0:	fc 01       	movw	r30, r24
    11f2:	ee 0f       	add	r30, r30
    11f4:	ff 1f       	adc	r31, r31
    11f6:	ee 0f       	add	r30, r30
    11f8:	ff 1f       	adc	r31, r31
    11fa:	ee 0f       	add	r30, r30
    11fc:	ff 1f       	adc	r31, r31
    11fe:	8e 0f       	add	r24, r30
    1200:	9f 1f       	adc	r25, r31
    1202:	fc 01       	movw	r30, r24
    1204:	e8 5a       	subi	r30, 0xA8	; 168
    1206:	fb 4e       	sbci	r31, 0xEB	; 235
    1208:	80 81       	ld	r24, Z
    120a:	82 30       	cpi	r24, 0x02	; 2
    120c:	48 f0       	brcs	.+18     	; 0x1220 <xTaskIncrementTick+0x18c>
			{
				xSwitchRequired = pdTRUE;
    120e:	dd 24       	eor	r13, r13
    1210:	d3 94       	inc	r13
    1212:	06 c0       	rjmp	.+12     	; 0x1220 <xTaskIncrementTick+0x18c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    1214:	80 91 20 14 	lds	r24, 0x1420	; 0x801420 <uxPendedTicks>
    1218:	8f 5f       	subi	r24, 0xFF	; 255
    121a:	80 93 20 14 	sts	0x1420, r24	; 0x801420 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    121e:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    1220:	80 91 1f 14 	lds	r24, 0x141F	; 0x80141f <xYieldPending>
    1224:	88 23       	and	r24, r24
    1226:	11 f0       	breq	.+4      	; 0x122c <xTaskIncrementTick+0x198>
		{
			xSwitchRequired = pdTRUE;
    1228:	dd 24       	eor	r13, r13
    122a:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    122c:	8d 2d       	mov	r24, r13
    122e:	df 91       	pop	r29
    1230:	cf 91       	pop	r28
    1232:	1f 91       	pop	r17
    1234:	0f 91       	pop	r16
    1236:	ff 90       	pop	r15
    1238:	ef 90       	pop	r14
    123a:	df 90       	pop	r13
    123c:	cf 90       	pop	r12
    123e:	08 95       	ret

00001240 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1240:	80 91 1a 14 	lds	r24, 0x141A	; 0x80141a <uxSchedulerSuspended>
    1244:	88 23       	and	r24, r24
    1246:	21 f0       	breq	.+8      	; 0x1250 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1248:	81 e0       	ldi	r24, 0x01	; 1
    124a:	80 93 1f 14 	sts	0x141F, r24	; 0x80141f <xYieldPending>
    124e:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1250:	10 92 1f 14 	sts	0x141F, r1	; 0x80141f <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1254:	80 91 22 14 	lds	r24, 0x1422	; 0x801422 <uxTopReadyPriority>
    1258:	90 e0       	ldi	r25, 0x00	; 0
    125a:	fc 01       	movw	r30, r24
    125c:	ee 0f       	add	r30, r30
    125e:	ff 1f       	adc	r31, r31
    1260:	ee 0f       	add	r30, r30
    1262:	ff 1f       	adc	r31, r31
    1264:	ee 0f       	add	r30, r30
    1266:	ff 1f       	adc	r31, r31
    1268:	8e 0f       	add	r24, r30
    126a:	9f 1f       	adc	r25, r31
    126c:	fc 01       	movw	r30, r24
    126e:	e8 5a       	subi	r30, 0xA8	; 168
    1270:	fb 4e       	sbci	r31, 0xEB	; 235
    1272:	80 81       	ld	r24, Z
    1274:	81 11       	cpse	r24, r1
    1276:	17 c0       	rjmp	.+46     	; 0x12a6 <vTaskSwitchContext+0x66>
    1278:	80 91 22 14 	lds	r24, 0x1422	; 0x801422 <uxTopReadyPriority>
    127c:	81 50       	subi	r24, 0x01	; 1
    127e:	80 93 22 14 	sts	0x1422, r24	; 0x801422 <uxTopReadyPriority>
    1282:	80 91 22 14 	lds	r24, 0x1422	; 0x801422 <uxTopReadyPriority>
    1286:	90 e0       	ldi	r25, 0x00	; 0
    1288:	fc 01       	movw	r30, r24
    128a:	ee 0f       	add	r30, r30
    128c:	ff 1f       	adc	r31, r31
    128e:	ee 0f       	add	r30, r30
    1290:	ff 1f       	adc	r31, r31
    1292:	ee 0f       	add	r30, r30
    1294:	ff 1f       	adc	r31, r31
    1296:	8e 0f       	add	r24, r30
    1298:	9f 1f       	adc	r25, r31
    129a:	fc 01       	movw	r30, r24
    129c:	e8 5a       	subi	r30, 0xA8	; 168
    129e:	fb 4e       	sbci	r31, 0xEB	; 235
    12a0:	80 81       	ld	r24, Z
    12a2:	88 23       	and	r24, r24
    12a4:	49 f3       	breq	.-46     	; 0x1278 <vTaskSwitchContext+0x38>
    12a6:	80 91 22 14 	lds	r24, 0x1422	; 0x801422 <uxTopReadyPriority>
    12aa:	90 e0       	ldi	r25, 0x00	; 0
    12ac:	9c 01       	movw	r18, r24
    12ae:	22 0f       	add	r18, r18
    12b0:	33 1f       	adc	r19, r19
    12b2:	22 0f       	add	r18, r18
    12b4:	33 1f       	adc	r19, r19
    12b6:	22 0f       	add	r18, r18
    12b8:	33 1f       	adc	r19, r19
    12ba:	28 0f       	add	r18, r24
    12bc:	39 1f       	adc	r19, r25
    12be:	d9 01       	movw	r26, r18
    12c0:	a8 5a       	subi	r26, 0xA8	; 168
    12c2:	bb 4e       	sbci	r27, 0xEB	; 235
    12c4:	11 96       	adiw	r26, 0x01	; 1
    12c6:	ed 91       	ld	r30, X+
    12c8:	fc 91       	ld	r31, X
    12ca:	12 97       	sbiw	r26, 0x02	; 2
    12cc:	02 80       	ldd	r0, Z+2	; 0x02
    12ce:	f3 81       	ldd	r31, Z+3	; 0x03
    12d0:	e0 2d       	mov	r30, r0
    12d2:	12 96       	adiw	r26, 0x02	; 2
    12d4:	fc 93       	st	X, r31
    12d6:	ee 93       	st	-X, r30
    12d8:	11 97       	sbiw	r26, 0x01	; 1
    12da:	25 5a       	subi	r18, 0xA5	; 165
    12dc:	3b 4e       	sbci	r19, 0xEB	; 235
    12de:	e2 17       	cp	r30, r18
    12e0:	f3 07       	cpc	r31, r19
    12e2:	29 f4       	brne	.+10     	; 0x12ee <vTaskSwitchContext+0xae>
    12e4:	22 81       	ldd	r18, Z+2	; 0x02
    12e6:	33 81       	ldd	r19, Z+3	; 0x03
    12e8:	fd 01       	movw	r30, r26
    12ea:	32 83       	std	Z+2, r19	; 0x02
    12ec:	21 83       	std	Z+1, r18	; 0x01
    12ee:	fc 01       	movw	r30, r24
    12f0:	ee 0f       	add	r30, r30
    12f2:	ff 1f       	adc	r31, r31
    12f4:	ee 0f       	add	r30, r30
    12f6:	ff 1f       	adc	r31, r31
    12f8:	ee 0f       	add	r30, r30
    12fa:	ff 1f       	adc	r31, r31
    12fc:	8e 0f       	add	r24, r30
    12fe:	9f 1f       	adc	r25, r31
    1300:	fc 01       	movw	r30, r24
    1302:	e8 5a       	subi	r30, 0xA8	; 168
    1304:	fb 4e       	sbci	r31, 0xEB	; 235
    1306:	01 80       	ldd	r0, Z+1	; 0x01
    1308:	f2 81       	ldd	r31, Z+2	; 0x02
    130a:	e0 2d       	mov	r30, r0
    130c:	86 81       	ldd	r24, Z+6	; 0x06
    130e:	97 81       	ldd	r25, Z+7	; 0x07
    1310:	90 93 7d 14 	sts	0x147D, r25	; 0x80147d <pxCurrentTCB+0x1>
    1314:	80 93 7c 14 	sts	0x147C, r24	; 0x80147c <pxCurrentTCB>
    1318:	08 95       	ret

0000131a <xSerialPutChar>:

		default:
			break;
	}
	return 0;
}
    131a:	cf 93       	push	r28
    131c:	df 93       	push	r29
    131e:	dc 01       	movw	r26, r24
    1320:	0f b6       	in	r0, 0x3f	; 63
    1322:	f8 94       	cli
    1324:	0f 92       	push	r0
    1326:	1d 96       	adiw	r26, 0x0d	; 13
    1328:	2d 91       	ld	r18, X+
    132a:	3c 91       	ld	r19, X
    132c:	1e 97       	sbiw	r26, 0x0e	; 14
    132e:	0f 90       	pop	r0
    1330:	0f be       	out	0x3f, r0	; 63
    1332:	57 96       	adiw	r26, 0x17	; 23
    1334:	8d 91       	ld	r24, X+
    1336:	9c 91       	ld	r25, X
    1338:	58 97       	sbiw	r26, 0x18	; 24
    133a:	28 17       	cp	r18, r24
    133c:	39 07       	cpc	r19, r25
    133e:	f1 f0       	breq	.+60     	; 0x137c <xSerialPutChar+0x62>
    1340:	fd 01       	movw	r30, r26
    1342:	3d 96       	adiw	r30, 0x0d	; 13
    1344:	c2 81       	ldd	r28, Z+2	; 0x02
    1346:	d3 81       	ldd	r29, Z+3	; 0x03
    1348:	68 83       	st	Y, r22
    134a:	82 81       	ldd	r24, Z+2	; 0x02
    134c:	93 81       	ldd	r25, Z+3	; 0x03
    134e:	01 96       	adiw	r24, 0x01	; 1
    1350:	93 83       	std	Z+3, r25	; 0x03
    1352:	82 83       	std	Z+2, r24	; 0x02
    1354:	20 85       	ldd	r18, Z+8	; 0x08
    1356:	31 85       	ldd	r19, Z+9	; 0x09
    1358:	82 17       	cp	r24, r18
    135a:	93 07       	cpc	r25, r19
    135c:	21 f4       	brne	.+8      	; 0x1366 <xSerialPutChar+0x4c>
    135e:	86 81       	ldd	r24, Z+6	; 0x06
    1360:	97 81       	ldd	r25, Z+7	; 0x07
    1362:	93 83       	std	Z+3, r25	; 0x03
    1364:	82 83       	std	Z+2, r24	; 0x02
    1366:	0f b6       	in	r0, 0x3f	; 63
    1368:	f8 94       	cli
    136a:	0f 92       	push	r0
    136c:	80 81       	ld	r24, Z
    136e:	91 81       	ldd	r25, Z+1	; 0x01
    1370:	01 96       	adiw	r24, 0x01	; 1
    1372:	91 83       	std	Z+1, r25	; 0x01
    1374:	80 83       	st	Z, r24
    1376:	0f 90       	pop	r0
    1378:	0f be       	out	0x3f, r0	; 63
    137a:	37 c0       	rjmp	.+110    	; 0x13ea <xSerialPutChar+0xd0>
    137c:	2f ef       	ldi	r18, 0xFF	; 255
    137e:	8f e8       	ldi	r24, 0x8F	; 143
    1380:	91 e0       	ldi	r25, 0x01	; 1
    1382:	21 50       	subi	r18, 0x01	; 1
    1384:	80 40       	sbci	r24, 0x00	; 0
    1386:	90 40       	sbci	r25, 0x00	; 0
    1388:	e1 f7       	brne	.-8      	; 0x1382 <xSerialPutChar+0x68>
    138a:	00 c0       	rjmp	.+0      	; 0x138c <xSerialPutChar+0x72>
    138c:	00 00       	nop
    138e:	0f b6       	in	r0, 0x3f	; 63
    1390:	f8 94       	cli
    1392:	0f 92       	push	r0
    1394:	1d 96       	adiw	r26, 0x0d	; 13
    1396:	2d 91       	ld	r18, X+
    1398:	3c 91       	ld	r19, X
    139a:	1e 97       	sbiw	r26, 0x0e	; 14
    139c:	0f 90       	pop	r0
    139e:	0f be       	out	0x3f, r0	; 63
    13a0:	57 96       	adiw	r26, 0x17	; 23
    13a2:	8d 91       	ld	r24, X+
    13a4:	9c 91       	ld	r25, X
    13a6:	58 97       	sbiw	r26, 0x18	; 24
    13a8:	28 17       	cp	r18, r24
    13aa:	39 07       	cpc	r19, r25
    13ac:	09 f4       	brne	.+2      	; 0x13b0 <xSerialPutChar+0x96>
    13ae:	44 c0       	rjmp	.+136    	; 0x1438 <xSerialPutChar+0x11e>
    13b0:	fd 01       	movw	r30, r26
    13b2:	3d 96       	adiw	r30, 0x0d	; 13
    13b4:	c2 81       	ldd	r28, Z+2	; 0x02
    13b6:	d3 81       	ldd	r29, Z+3	; 0x03
    13b8:	68 83       	st	Y, r22
    13ba:	82 81       	ldd	r24, Z+2	; 0x02
    13bc:	93 81       	ldd	r25, Z+3	; 0x03
    13be:	01 96       	adiw	r24, 0x01	; 1
    13c0:	93 83       	std	Z+3, r25	; 0x03
    13c2:	82 83       	std	Z+2, r24	; 0x02
    13c4:	20 85       	ldd	r18, Z+8	; 0x08
    13c6:	31 85       	ldd	r19, Z+9	; 0x09
    13c8:	82 17       	cp	r24, r18
    13ca:	93 07       	cpc	r25, r19
    13cc:	21 f4       	brne	.+8      	; 0x13d6 <xSerialPutChar+0xbc>
    13ce:	86 81       	ldd	r24, Z+6	; 0x06
    13d0:	97 81       	ldd	r25, Z+7	; 0x07
    13d2:	93 83       	std	Z+3, r25	; 0x03
    13d4:	82 83       	std	Z+2, r24	; 0x02
    13d6:	0f b6       	in	r0, 0x3f	; 63
    13d8:	f8 94       	cli
    13da:	0f 92       	push	r0
    13dc:	80 81       	ld	r24, Z
    13de:	91 81       	ldd	r25, Z+1	; 0x01
    13e0:	01 96       	adiw	r24, 0x01	; 1
    13e2:	91 83       	std	Z+1, r25	; 0x01
    13e4:	80 83       	st	Z, r24
    13e6:	0f 90       	pop	r0
    13e8:	0f be       	out	0x3f, r0	; 63
    13ea:	8c 91       	ld	r24, X
    13ec:	90 e0       	ldi	r25, 0x00	; 0
    13ee:	88 30       	cpi	r24, 0x08	; 8
    13f0:	91 05       	cpc	r25, r1
    13f2:	20 f5       	brcc	.+72     	; 0x143c <xSerialPutChar+0x122>
    13f4:	fc 01       	movw	r30, r24
    13f6:	88 27       	eor	r24, r24
    13f8:	ee 58       	subi	r30, 0x8E	; 142
    13fa:	ff 4f       	sbci	r31, 0xFF	; 255
    13fc:	8f 4f       	sbci	r24, 0xFF	; 255
    13fe:	14 c5       	rjmp	.+2600   	; 0x1e28 <__tablejump2__>
    1400:	e1 ec       	ldi	r30, 0xC1	; 193
    1402:	f0 e0       	ldi	r31, 0x00	; 0
    1404:	80 81       	ld	r24, Z
    1406:	80 62       	ori	r24, 0x20	; 32
    1408:	80 83       	st	Z, r24
    140a:	81 e0       	ldi	r24, 0x01	; 1
    140c:	18 c0       	rjmp	.+48     	; 0x143e <xSerialPutChar+0x124>
    140e:	e9 ec       	ldi	r30, 0xC9	; 201
    1410:	f0 e0       	ldi	r31, 0x00	; 0
    1412:	80 81       	ld	r24, Z
    1414:	80 62       	ori	r24, 0x20	; 32
    1416:	80 83       	st	Z, r24
    1418:	81 e0       	ldi	r24, 0x01	; 1
    141a:	11 c0       	rjmp	.+34     	; 0x143e <xSerialPutChar+0x124>
    141c:	e1 ed       	ldi	r30, 0xD1	; 209
    141e:	f0 e0       	ldi	r31, 0x00	; 0
    1420:	80 81       	ld	r24, Z
    1422:	80 62       	ori	r24, 0x20	; 32
    1424:	80 83       	st	Z, r24
    1426:	81 e0       	ldi	r24, 0x01	; 1
    1428:	0a c0       	rjmp	.+20     	; 0x143e <xSerialPutChar+0x124>
    142a:	e1 e3       	ldi	r30, 0x31	; 49
    142c:	f1 e0       	ldi	r31, 0x01	; 1
    142e:	80 81       	ld	r24, Z
    1430:	80 62       	ori	r24, 0x20	; 32
    1432:	80 83       	st	Z, r24
    1434:	81 e0       	ldi	r24, 0x01	; 1
    1436:	03 c0       	rjmp	.+6      	; 0x143e <xSerialPutChar+0x124>
    1438:	80 e0       	ldi	r24, 0x00	; 0
    143a:	01 c0       	rjmp	.+2      	; 0x143e <xSerialPutChar+0x124>
    143c:	81 e0       	ldi	r24, 0x01	; 1
    143e:	df 91       	pop	r29
    1440:	cf 91       	pop	r28
    1442:	08 95       	ret

00001444 <xSerialPortInitMinimal>:
    1444:	7f 92       	push	r7
    1446:	8f 92       	push	r8
    1448:	9f 92       	push	r9
    144a:	af 92       	push	r10
    144c:	bf 92       	push	r11
    144e:	cf 92       	push	r12
    1450:	df 92       	push	r13
    1452:	ef 92       	push	r14
    1454:	ff 92       	push	r15
    1456:	0f 93       	push	r16
    1458:	1f 93       	push	r17
    145a:	cf 93       	push	r28
    145c:	df 93       	push	r29
    145e:	cd b7       	in	r28, 0x3d	; 61
    1460:	de b7       	in	r29, 0x3e	; 62
    1462:	a2 97       	sbiw	r28, 0x22	; 34
    1464:	0f b6       	in	r0, 0x3f	; 63
    1466:	f8 94       	cli
    1468:	de bf       	out	0x3e, r29	; 62
    146a:	0f be       	out	0x3f, r0	; 63
    146c:	cd bf       	out	0x3d, r28	; 61
    146e:	6c 01       	movw	r12, r24
    1470:	76 2e       	mov	r7, r22
    1472:	49 01       	movw	r8, r18
    1474:	5a 01       	movw	r10, r20
    1476:	c7 01       	movw	r24, r14
    1478:	b2 d8       	rcall	.-3740   	; 0x5de <pvPortMalloc>
    147a:	00 97       	sbiw	r24, 0x00	; 0
    147c:	a9 f0       	breq	.+42     	; 0x14a8 <xSerialPortInitMinimal+0x64>
    147e:	fe 01       	movw	r30, r28
    1480:	32 96       	adiw	r30, 0x02	; 2
    1482:	0f b6       	in	r0, 0x3f	; 63
    1484:	f8 94       	cli
    1486:	0f 92       	push	r0
    1488:	11 82       	std	Z+1, r1	; 0x01
    148a:	10 82       	st	Z, r1
    148c:	93 83       	std	Z+3, r25	; 0x03
    148e:	82 83       	std	Z+2, r24	; 0x02
    1490:	95 83       	std	Z+5, r25	; 0x05
    1492:	84 83       	std	Z+4, r24	; 0x04
    1494:	97 83       	std	Z+7, r25	; 0x07
    1496:	86 83       	std	Z+6, r24	; 0x06
    1498:	8e 0d       	add	r24, r14
    149a:	9f 1d       	adc	r25, r15
    149c:	91 87       	std	Z+9, r25	; 0x09
    149e:	80 87       	std	Z+8, r24	; 0x08
    14a0:	f3 86       	std	Z+11, r15	; 0x0b
    14a2:	e2 86       	std	Z+10, r14	; 0x0a
    14a4:	0f 90       	pop	r0
    14a6:	0f be       	out	0x3f, r0	; 63
    14a8:	c8 01       	movw	r24, r16
    14aa:	99 d8       	rcall	.-3790   	; 0x5de <pvPortMalloc>
    14ac:	00 97       	sbiw	r24, 0x00	; 0
    14ae:	a9 f0       	breq	.+42     	; 0x14da <xSerialPortInitMinimal+0x96>
    14b0:	fe 01       	movw	r30, r28
    14b2:	3e 96       	adiw	r30, 0x0e	; 14
    14b4:	0f b6       	in	r0, 0x3f	; 63
    14b6:	f8 94       	cli
    14b8:	0f 92       	push	r0
    14ba:	11 82       	std	Z+1, r1	; 0x01
    14bc:	10 82       	st	Z, r1
    14be:	93 83       	std	Z+3, r25	; 0x03
    14c0:	82 83       	std	Z+2, r24	; 0x02
    14c2:	95 83       	std	Z+5, r25	; 0x05
    14c4:	84 83       	std	Z+4, r24	; 0x04
    14c6:	97 83       	std	Z+7, r25	; 0x07
    14c8:	86 83       	std	Z+6, r24	; 0x06
    14ca:	80 0f       	add	r24, r16
    14cc:	91 1f       	adc	r25, r17
    14ce:	91 87       	std	Z+9, r25	; 0x09
    14d0:	80 87       	std	Z+8, r24	; 0x08
    14d2:	13 87       	std	Z+11, r17	; 0x0b
    14d4:	02 87       	std	Z+10, r16	; 0x0a
    14d6:	0f 90       	pop	r0
    14d8:	0f be       	out	0x3f, r0	; 63
    14da:	c8 01       	movw	r24, r16
    14dc:	80 d8       	rcall	.-3840   	; 0x5de <pvPortMalloc>
    14de:	9b 8f       	std	Y+27, r25	; 0x1b
    14e0:	8a 8f       	std	Y+26, r24	; 0x1a
    14e2:	79 82       	std	Y+1, r7	; 0x01
    14e4:	1d 8f       	std	Y+29, r17	; 0x1d
    14e6:	0c 8f       	std	Y+28, r16	; 0x1c
    14e8:	1e 8e       	std	Y+30, r1	; 0x1e
    14ea:	8f 8e       	std	Y+31, r8	; 0x1f
    14ec:	98 a2       	std	Y+32, r9	; 0x20
    14ee:	a9 a2       	std	Y+33, r10	; 0x21
    14f0:	ba a2       	std	Y+34, r11	; 0x22
    14f2:	0f b6       	in	r0, 0x3f	; 63
    14f4:	f8 94       	cli
    14f6:	0f 92       	push	r0
    14f8:	89 81       	ldd	r24, Y+1	; 0x01
    14fa:	90 e0       	ldi	r25, 0x00	; 0
    14fc:	88 30       	cpi	r24, 0x08	; 8
    14fe:	91 05       	cpc	r25, r1
    1500:	08 f0       	brcs	.+2      	; 0x1504 <xSerialPortInitMinimal+0xc0>
    1502:	b1 c1       	rjmp	.+866    	; 0x1866 <xSerialPortInitMinimal+0x422>
    1504:	fc 01       	movw	r30, r24
    1506:	88 27       	eor	r24, r24
    1508:	e6 58       	subi	r30, 0x86	; 134
    150a:	ff 4f       	sbci	r31, 0xFF	; 255
    150c:	8f 4f       	sbci	r24, 0xFF	; 255
    150e:	8c c4       	rjmp	.+2328   	; 0x1e28 <__tablejump2__>
    1510:	d5 01       	movw	r26, r10
    1512:	c4 01       	movw	r24, r8
    1514:	97 5f       	subi	r25, 0xF7	; 247
    1516:	a2 4c       	sbci	r26, 0xC2	; 194
    1518:	bf 4f       	sbci	r27, 0xFF	; 255
    151a:	bc 01       	movw	r22, r24
    151c:	cd 01       	movw	r24, r26
    151e:	66 0f       	add	r22, r22
    1520:	77 1f       	adc	r23, r23
    1522:	88 1f       	adc	r24, r24
    1524:	99 1f       	adc	r25, r25
    1526:	66 0f       	add	r22, r22
    1528:	77 1f       	adc	r23, r23
    152a:	88 1f       	adc	r24, r24
    152c:	99 1f       	adc	r25, r25
    152e:	95 01       	movw	r18, r10
    1530:	84 01       	movw	r16, r8
    1532:	00 0f       	add	r16, r16
    1534:	11 1f       	adc	r17, r17
    1536:	22 1f       	adc	r18, r18
    1538:	33 1f       	adc	r19, r19
    153a:	00 0f       	add	r16, r16
    153c:	11 1f       	adc	r17, r17
    153e:	22 1f       	adc	r18, r18
    1540:	33 1f       	adc	r19, r19
    1542:	a9 01       	movw	r20, r18
    1544:	98 01       	movw	r18, r16
    1546:	22 0f       	add	r18, r18
    1548:	33 1f       	adc	r19, r19
    154a:	44 1f       	adc	r20, r20
    154c:	55 1f       	adc	r21, r21
    154e:	4a d4       	rcall	.+2196   	; 0x1de4 <__udivmodsi4>
    1550:	21 50       	subi	r18, 0x01	; 1
    1552:	31 09       	sbc	r19, r1
    1554:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    1558:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    155c:	82 e0       	ldi	r24, 0x02	; 2
    155e:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1562:	88 e9       	ldi	r24, 0x98	; 152
    1564:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    1568:	8e e0       	ldi	r24, 0x0E	; 14
    156a:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    156e:	7b c1       	rjmp	.+758    	; 0x1866 <xSerialPortInitMinimal+0x422>
    1570:	04 ec       	ldi	r16, 0xC4	; 196
    1572:	10 e0       	ldi	r17, 0x00	; 0
    1574:	f8 01       	movw	r30, r16
    1576:	11 82       	std	Z+1, r1	; 0x01
    1578:	10 82       	st	Z, r1
    157a:	6a 9a       	sbi	0x0d, 2	; 13
    157c:	80 ec       	ldi	r24, 0xC0	; 192
    157e:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    1582:	88 e9       	ldi	r24, 0x98	; 152
    1584:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    1588:	d5 01       	movw	r26, r10
    158a:	c4 01       	movw	r24, r8
    158c:	80 58       	subi	r24, 0x80	; 128
    158e:	9b 47       	sbci	r25, 0x7B	; 123
    1590:	a1 4e       	sbci	r26, 0xE1	; 225
    1592:	bf 4f       	sbci	r27, 0xFF	; 255
    1594:	88 0f       	add	r24, r24
    1596:	99 1f       	adc	r25, r25
    1598:	aa 1f       	adc	r26, r26
    159a:	bb 1f       	adc	r27, r27
    159c:	88 0f       	add	r24, r24
    159e:	99 1f       	adc	r25, r25
    15a0:	aa 1f       	adc	r26, r26
    15a2:	bb 1f       	adc	r27, r27
    15a4:	bc 01       	movw	r22, r24
    15a6:	cd 01       	movw	r24, r26
    15a8:	66 0f       	add	r22, r22
    15aa:	77 1f       	adc	r23, r23
    15ac:	88 1f       	adc	r24, r24
    15ae:	99 1f       	adc	r25, r25
    15b0:	88 0c       	add	r8, r8
    15b2:	99 1c       	adc	r9, r9
    15b4:	aa 1c       	adc	r10, r10
    15b6:	bb 1c       	adc	r11, r11
    15b8:	88 0c       	add	r8, r8
    15ba:	99 1c       	adc	r9, r9
    15bc:	aa 1c       	adc	r10, r10
    15be:	bb 1c       	adc	r11, r11
    15c0:	a5 01       	movw	r20, r10
    15c2:	94 01       	movw	r18, r8
    15c4:	22 0f       	add	r18, r18
    15c6:	33 1f       	adc	r19, r19
    15c8:	44 1f       	adc	r20, r20
    15ca:	55 1f       	adc	r21, r21
    15cc:	22 0f       	add	r18, r18
    15ce:	33 1f       	adc	r19, r19
    15d0:	44 1f       	adc	r20, r20
    15d2:	55 1f       	adc	r21, r21
    15d4:	07 d4       	rcall	.+2062   	; 0x1de4 <__udivmodsi4>
    15d6:	21 50       	subi	r18, 0x01	; 1
    15d8:	31 09       	sbc	r19, r1
    15da:	f8 01       	movw	r30, r16
    15dc:	31 83       	std	Z+1, r19	; 0x01
    15de:	20 83       	st	Z, r18
    15e0:	42 c1       	rjmp	.+644    	; 0x1866 <xSerialPortInitMinimal+0x422>
    15e2:	d5 01       	movw	r26, r10
    15e4:	c4 01       	movw	r24, r8
    15e6:	97 5f       	subi	r25, 0xF7	; 247
    15e8:	a2 4c       	sbci	r26, 0xC2	; 194
    15ea:	bf 4f       	sbci	r27, 0xFF	; 255
    15ec:	bc 01       	movw	r22, r24
    15ee:	cd 01       	movw	r24, r26
    15f0:	66 0f       	add	r22, r22
    15f2:	77 1f       	adc	r23, r23
    15f4:	88 1f       	adc	r24, r24
    15f6:	99 1f       	adc	r25, r25
    15f8:	66 0f       	add	r22, r22
    15fa:	77 1f       	adc	r23, r23
    15fc:	88 1f       	adc	r24, r24
    15fe:	99 1f       	adc	r25, r25
    1600:	95 01       	movw	r18, r10
    1602:	84 01       	movw	r16, r8
    1604:	00 0f       	add	r16, r16
    1606:	11 1f       	adc	r17, r17
    1608:	22 1f       	adc	r18, r18
    160a:	33 1f       	adc	r19, r19
    160c:	00 0f       	add	r16, r16
    160e:	11 1f       	adc	r17, r17
    1610:	22 1f       	adc	r18, r18
    1612:	33 1f       	adc	r19, r19
    1614:	a9 01       	movw	r20, r18
    1616:	98 01       	movw	r18, r16
    1618:	22 0f       	add	r18, r18
    161a:	33 1f       	adc	r19, r19
    161c:	44 1f       	adc	r20, r20
    161e:	55 1f       	adc	r21, r21
    1620:	e1 d3       	rcall	.+1986   	; 0x1de4 <__udivmodsi4>
    1622:	21 50       	subi	r18, 0x01	; 1
    1624:	31 09       	sbc	r19, r1
    1626:	30 93 cd 00 	sts	0x00CD, r19	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    162a:	20 93 cc 00 	sts	0x00CC, r18	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    162e:	82 e0       	ldi	r24, 0x02	; 2
    1630:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1634:	88 e9       	ldi	r24, 0x98	; 152
    1636:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    163a:	8e e0       	ldi	r24, 0x0E	; 14
    163c:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    1640:	12 c1       	rjmp	.+548    	; 0x1866 <xSerialPortInitMinimal+0x422>
    1642:	0c ec       	ldi	r16, 0xCC	; 204
    1644:	10 e0       	ldi	r17, 0x00	; 0
    1646:	f8 01       	movw	r30, r16
    1648:	11 82       	std	Z+1, r1	; 0x01
    164a:	10 82       	st	Z, r1
    164c:	55 9a       	sbi	0x0a, 5	; 10
    164e:	80 ec       	ldi	r24, 0xC0	; 192
    1650:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    1654:	88 e9       	ldi	r24, 0x98	; 152
    1656:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    165a:	d5 01       	movw	r26, r10
    165c:	c4 01       	movw	r24, r8
    165e:	80 58       	subi	r24, 0x80	; 128
    1660:	9b 47       	sbci	r25, 0x7B	; 123
    1662:	a1 4e       	sbci	r26, 0xE1	; 225
    1664:	bf 4f       	sbci	r27, 0xFF	; 255
    1666:	88 0f       	add	r24, r24
    1668:	99 1f       	adc	r25, r25
    166a:	aa 1f       	adc	r26, r26
    166c:	bb 1f       	adc	r27, r27
    166e:	88 0f       	add	r24, r24
    1670:	99 1f       	adc	r25, r25
    1672:	aa 1f       	adc	r26, r26
    1674:	bb 1f       	adc	r27, r27
    1676:	bc 01       	movw	r22, r24
    1678:	cd 01       	movw	r24, r26
    167a:	66 0f       	add	r22, r22
    167c:	77 1f       	adc	r23, r23
    167e:	88 1f       	adc	r24, r24
    1680:	99 1f       	adc	r25, r25
    1682:	88 0c       	add	r8, r8
    1684:	99 1c       	adc	r9, r9
    1686:	aa 1c       	adc	r10, r10
    1688:	bb 1c       	adc	r11, r11
    168a:	88 0c       	add	r8, r8
    168c:	99 1c       	adc	r9, r9
    168e:	aa 1c       	adc	r10, r10
    1690:	bb 1c       	adc	r11, r11
    1692:	a5 01       	movw	r20, r10
    1694:	94 01       	movw	r18, r8
    1696:	22 0f       	add	r18, r18
    1698:	33 1f       	adc	r19, r19
    169a:	44 1f       	adc	r20, r20
    169c:	55 1f       	adc	r21, r21
    169e:	22 0f       	add	r18, r18
    16a0:	33 1f       	adc	r19, r19
    16a2:	44 1f       	adc	r20, r20
    16a4:	55 1f       	adc	r21, r21
    16a6:	9e d3       	rcall	.+1852   	; 0x1de4 <__udivmodsi4>
    16a8:	21 50       	subi	r18, 0x01	; 1
    16aa:	31 09       	sbc	r19, r1
    16ac:	f8 01       	movw	r30, r16
    16ae:	31 83       	std	Z+1, r19	; 0x01
    16b0:	20 83       	st	Z, r18
    16b2:	d9 c0       	rjmp	.+434    	; 0x1866 <xSerialPortInitMinimal+0x422>
    16b4:	d5 01       	movw	r26, r10
    16b6:	c4 01       	movw	r24, r8
    16b8:	97 5f       	subi	r25, 0xF7	; 247
    16ba:	a2 4c       	sbci	r26, 0xC2	; 194
    16bc:	bf 4f       	sbci	r27, 0xFF	; 255
    16be:	bc 01       	movw	r22, r24
    16c0:	cd 01       	movw	r24, r26
    16c2:	66 0f       	add	r22, r22
    16c4:	77 1f       	adc	r23, r23
    16c6:	88 1f       	adc	r24, r24
    16c8:	99 1f       	adc	r25, r25
    16ca:	66 0f       	add	r22, r22
    16cc:	77 1f       	adc	r23, r23
    16ce:	88 1f       	adc	r24, r24
    16d0:	99 1f       	adc	r25, r25
    16d2:	95 01       	movw	r18, r10
    16d4:	84 01       	movw	r16, r8
    16d6:	00 0f       	add	r16, r16
    16d8:	11 1f       	adc	r17, r17
    16da:	22 1f       	adc	r18, r18
    16dc:	33 1f       	adc	r19, r19
    16de:	00 0f       	add	r16, r16
    16e0:	11 1f       	adc	r17, r17
    16e2:	22 1f       	adc	r18, r18
    16e4:	33 1f       	adc	r19, r19
    16e6:	a9 01       	movw	r20, r18
    16e8:	98 01       	movw	r18, r16
    16ea:	22 0f       	add	r18, r18
    16ec:	33 1f       	adc	r19, r19
    16ee:	44 1f       	adc	r20, r20
    16f0:	55 1f       	adc	r21, r21
    16f2:	78 d3       	rcall	.+1776   	; 0x1de4 <__udivmodsi4>
    16f4:	21 50       	subi	r18, 0x01	; 1
    16f6:	31 09       	sbc	r19, r1
    16f8:	30 93 d5 00 	sts	0x00D5, r19	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    16fc:	20 93 d4 00 	sts	0x00D4, r18	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    1700:	82 e0       	ldi	r24, 0x02	; 2
    1702:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1706:	88 e9       	ldi	r24, 0x98	; 152
    1708:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    170c:	8e e0       	ldi	r24, 0x0E	; 14
    170e:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    1712:	a9 c0       	rjmp	.+338    	; 0x1866 <xSerialPortInitMinimal+0x422>
    1714:	04 ed       	ldi	r16, 0xD4	; 212
    1716:	10 e0       	ldi	r17, 0x00	; 0
    1718:	f8 01       	movw	r30, r16
    171a:	11 82       	std	Z+1, r1	; 0x01
    171c:	10 82       	st	Z, r1
    171e:	e1 e0       	ldi	r30, 0x01	; 1
    1720:	f1 e0       	ldi	r31, 0x01	; 1
    1722:	80 81       	ld	r24, Z
    1724:	84 60       	ori	r24, 0x04	; 4
    1726:	80 83       	st	Z, r24
    1728:	80 ec       	ldi	r24, 0xC0	; 192
    172a:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    172e:	88 e9       	ldi	r24, 0x98	; 152
    1730:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    1734:	d5 01       	movw	r26, r10
    1736:	c4 01       	movw	r24, r8
    1738:	80 58       	subi	r24, 0x80	; 128
    173a:	9b 47       	sbci	r25, 0x7B	; 123
    173c:	a1 4e       	sbci	r26, 0xE1	; 225
    173e:	bf 4f       	sbci	r27, 0xFF	; 255
    1740:	88 0f       	add	r24, r24
    1742:	99 1f       	adc	r25, r25
    1744:	aa 1f       	adc	r26, r26
    1746:	bb 1f       	adc	r27, r27
    1748:	88 0f       	add	r24, r24
    174a:	99 1f       	adc	r25, r25
    174c:	aa 1f       	adc	r26, r26
    174e:	bb 1f       	adc	r27, r27
    1750:	bc 01       	movw	r22, r24
    1752:	cd 01       	movw	r24, r26
    1754:	66 0f       	add	r22, r22
    1756:	77 1f       	adc	r23, r23
    1758:	88 1f       	adc	r24, r24
    175a:	99 1f       	adc	r25, r25
    175c:	88 0c       	add	r8, r8
    175e:	99 1c       	adc	r9, r9
    1760:	aa 1c       	adc	r10, r10
    1762:	bb 1c       	adc	r11, r11
    1764:	88 0c       	add	r8, r8
    1766:	99 1c       	adc	r9, r9
    1768:	aa 1c       	adc	r10, r10
    176a:	bb 1c       	adc	r11, r11
    176c:	a5 01       	movw	r20, r10
    176e:	94 01       	movw	r18, r8
    1770:	22 0f       	add	r18, r18
    1772:	33 1f       	adc	r19, r19
    1774:	44 1f       	adc	r20, r20
    1776:	55 1f       	adc	r21, r21
    1778:	22 0f       	add	r18, r18
    177a:	33 1f       	adc	r19, r19
    177c:	44 1f       	adc	r20, r20
    177e:	55 1f       	adc	r21, r21
    1780:	31 d3       	rcall	.+1634   	; 0x1de4 <__udivmodsi4>
    1782:	21 50       	subi	r18, 0x01	; 1
    1784:	31 09       	sbc	r19, r1
    1786:	f8 01       	movw	r30, r16
    1788:	31 83       	std	Z+1, r19	; 0x01
    178a:	20 83       	st	Z, r18
    178c:	6c c0       	rjmp	.+216    	; 0x1866 <xSerialPortInitMinimal+0x422>
    178e:	d5 01       	movw	r26, r10
    1790:	c4 01       	movw	r24, r8
    1792:	97 5f       	subi	r25, 0xF7	; 247
    1794:	a2 4c       	sbci	r26, 0xC2	; 194
    1796:	bf 4f       	sbci	r27, 0xFF	; 255
    1798:	bc 01       	movw	r22, r24
    179a:	cd 01       	movw	r24, r26
    179c:	66 0f       	add	r22, r22
    179e:	77 1f       	adc	r23, r23
    17a0:	88 1f       	adc	r24, r24
    17a2:	99 1f       	adc	r25, r25
    17a4:	66 0f       	add	r22, r22
    17a6:	77 1f       	adc	r23, r23
    17a8:	88 1f       	adc	r24, r24
    17aa:	99 1f       	adc	r25, r25
    17ac:	95 01       	movw	r18, r10
    17ae:	84 01       	movw	r16, r8
    17b0:	00 0f       	add	r16, r16
    17b2:	11 1f       	adc	r17, r17
    17b4:	22 1f       	adc	r18, r18
    17b6:	33 1f       	adc	r19, r19
    17b8:	00 0f       	add	r16, r16
    17ba:	11 1f       	adc	r17, r17
    17bc:	22 1f       	adc	r18, r18
    17be:	33 1f       	adc	r19, r19
    17c0:	a9 01       	movw	r20, r18
    17c2:	98 01       	movw	r18, r16
    17c4:	22 0f       	add	r18, r18
    17c6:	33 1f       	adc	r19, r19
    17c8:	44 1f       	adc	r20, r20
    17ca:	55 1f       	adc	r21, r21
    17cc:	0b d3       	rcall	.+1558   	; 0x1de4 <__udivmodsi4>
    17ce:	21 50       	subi	r18, 0x01	; 1
    17d0:	31 09       	sbc	r19, r1
    17d2:	30 93 35 01 	sts	0x0135, r19	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    17d6:	20 93 34 01 	sts	0x0134, r18	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    17da:	82 e0       	ldi	r24, 0x02	; 2
    17dc:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    17e0:	88 e9       	ldi	r24, 0x98	; 152
    17e2:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    17e6:	8e e0       	ldi	r24, 0x0E	; 14
    17e8:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    17ec:	3c c0       	rjmp	.+120    	; 0x1866 <xSerialPortInitMinimal+0x422>
    17ee:	04 e3       	ldi	r16, 0x34	; 52
    17f0:	11 e0       	ldi	r17, 0x01	; 1
    17f2:	f8 01       	movw	r30, r16
    17f4:	11 82       	std	Z+1, r1	; 0x01
    17f6:	10 82       	st	Z, r1
    17f8:	e4 e0       	ldi	r30, 0x04	; 4
    17fa:	f1 e0       	ldi	r31, 0x01	; 1
    17fc:	80 81       	ld	r24, Z
    17fe:	84 60       	ori	r24, 0x04	; 4
    1800:	80 83       	st	Z, r24
    1802:	80 ec       	ldi	r24, 0xC0	; 192
    1804:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    1808:	88 e9       	ldi	r24, 0x98	; 152
    180a:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    180e:	d5 01       	movw	r26, r10
    1810:	c4 01       	movw	r24, r8
    1812:	80 58       	subi	r24, 0x80	; 128
    1814:	9b 47       	sbci	r25, 0x7B	; 123
    1816:	a1 4e       	sbci	r26, 0xE1	; 225
    1818:	bf 4f       	sbci	r27, 0xFF	; 255
    181a:	88 0f       	add	r24, r24
    181c:	99 1f       	adc	r25, r25
    181e:	aa 1f       	adc	r26, r26
    1820:	bb 1f       	adc	r27, r27
    1822:	88 0f       	add	r24, r24
    1824:	99 1f       	adc	r25, r25
    1826:	aa 1f       	adc	r26, r26
    1828:	bb 1f       	adc	r27, r27
    182a:	bc 01       	movw	r22, r24
    182c:	cd 01       	movw	r24, r26
    182e:	66 0f       	add	r22, r22
    1830:	77 1f       	adc	r23, r23
    1832:	88 1f       	adc	r24, r24
    1834:	99 1f       	adc	r25, r25
    1836:	88 0c       	add	r8, r8
    1838:	99 1c       	adc	r9, r9
    183a:	aa 1c       	adc	r10, r10
    183c:	bb 1c       	adc	r11, r11
    183e:	88 0c       	add	r8, r8
    1840:	99 1c       	adc	r9, r9
    1842:	aa 1c       	adc	r10, r10
    1844:	bb 1c       	adc	r11, r11
    1846:	a5 01       	movw	r20, r10
    1848:	94 01       	movw	r18, r8
    184a:	22 0f       	add	r18, r18
    184c:	33 1f       	adc	r19, r19
    184e:	44 1f       	adc	r20, r20
    1850:	55 1f       	adc	r21, r21
    1852:	22 0f       	add	r18, r18
    1854:	33 1f       	adc	r19, r19
    1856:	44 1f       	adc	r20, r20
    1858:	55 1f       	adc	r21, r21
    185a:	c4 d2       	rcall	.+1416   	; 0x1de4 <__udivmodsi4>
    185c:	21 50       	subi	r18, 0x01	; 1
    185e:	31 09       	sbc	r19, r1
    1860:	f8 01       	movw	r30, r16
    1862:	31 83       	std	Z+1, r19	; 0x01
    1864:	20 83       	st	Z, r18
    1866:	0f 90       	pop	r0
    1868:	0f be       	out	0x3f, r0	; 63
    186a:	82 e2       	ldi	r24, 0x22	; 34
    186c:	fe 01       	movw	r30, r28
    186e:	31 96       	adiw	r30, 0x01	; 1
    1870:	d6 01       	movw	r26, r12
    1872:	01 90       	ld	r0, Z+
    1874:	0d 92       	st	X+, r0
    1876:	8a 95       	dec	r24
    1878:	e1 f7       	brne	.-8      	; 0x1872 <xSerialPortInitMinimal+0x42e>
    187a:	c6 01       	movw	r24, r12
    187c:	a2 96       	adiw	r28, 0x22	; 34
    187e:	0f b6       	in	r0, 0x3f	; 63
    1880:	f8 94       	cli
    1882:	de bf       	out	0x3e, r29	; 62
    1884:	0f be       	out	0x3f, r0	; 63
    1886:	cd bf       	out	0x3d, r28	; 61
    1888:	df 91       	pop	r29
    188a:	cf 91       	pop	r28
    188c:	1f 91       	pop	r17
    188e:	0f 91       	pop	r16
    1890:	ff 90       	pop	r15
    1892:	ef 90       	pop	r14
    1894:	df 90       	pop	r13
    1896:	cf 90       	pop	r12
    1898:	bf 90       	pop	r11
    189a:	af 90       	pop	r10
    189c:	9f 90       	pop	r9
    189e:	8f 90       	pop	r8
    18a0:	7f 90       	pop	r7
    18a2:	08 95       	ret

000018a4 <__vector_25>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART0_RX_vect )

#endif
{
    18a4:	1f 92       	push	r1
    18a6:	0f 92       	push	r0
    18a8:	0f b6       	in	r0, 0x3f	; 63
    18aa:	0f 92       	push	r0
    18ac:	11 24       	eor	r1, r1
    18ae:	0b b6       	in	r0, 0x3b	; 59
    18b0:	0f 92       	push	r0
    18b2:	2f 93       	push	r18
    18b4:	3f 93       	push	r19
    18b6:	4f 93       	push	r20
    18b8:	8f 93       	push	r24
    18ba:	9f 93       	push	r25
    18bc:	af 93       	push	r26
    18be:	bf 93       	push	r27
    18c0:	ef 93       	push	r30
    18c2:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR0A & (_BV(FE0)|_BV(DOR0)|_BV(UPE0)) ) )
    18c4:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    18c8:	8c 71       	andi	r24, 0x1C	; 28
    18ca:	71 f0       	breq	.+28     	; 0x18e8 <__vector_25+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR0A & (1<<RXC0) ) erroredByte = UDR0;
    18cc:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    18d0:	88 23       	and	r24, r24
    18d2:	0c f0       	brlt	.+2      	; 0x18d6 <__vector_25+0x32>
    18d4:	36 c0       	rjmp	.+108    	; 0x1942 <__vector_25+0x9e>
    18d6:	a6 ec       	ldi	r26, 0xC6	; 198
    18d8:	b0 e0       	ldi	r27, 0x00	; 0
    18da:	e0 ec       	ldi	r30, 0xC0	; 192
    18dc:	f0 e0       	ldi	r31, 0x00	; 0
    18de:	8c 91       	ld	r24, X
    18e0:	80 81       	ld	r24, Z
    18e2:	88 23       	and	r24, r24
    18e4:	e4 f3       	brlt	.-8      	; 0x18de <__vector_25+0x3a>
    18e6:	2d c0       	rjmp	.+90     	; 0x1942 <__vector_25+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR0;
    18e8:	40 91 c6 00 	lds	r20, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    18ec:	0f b6       	in	r0, 0x3f	; 63
    18ee:	f8 94       	cli
    18f0:	0f 92       	push	r0
	{
	    count = buffer->count;
    18f2:	ee e7       	ldi	r30, 0x7E	; 126
    18f4:	f4 e1       	ldi	r31, 0x14	; 20
    18f6:	21 81       	ldd	r18, Z+1	; 0x01
    18f8:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    18fa:	0f 90       	pop	r0
    18fc:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerialPort.xRxedChars) ) )
    18fe:	83 85       	ldd	r24, Z+11	; 0x0b
    1900:	94 85       	ldd	r25, Z+12	; 0x0c
    1902:	28 17       	cp	r18, r24
    1904:	39 07       	cpc	r19, r25
    1906:	e9 f0       	breq	.+58     	; 0x1942 <__vector_25+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1908:	ef e7       	ldi	r30, 0x7F	; 127
    190a:	f4 e1       	ldi	r31, 0x14	; 20

	*buffer->in = data;
    190c:	a2 81       	ldd	r26, Z+2	; 0x02
    190e:	b3 81       	ldd	r27, Z+3	; 0x03
    1910:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1912:	82 81       	ldd	r24, Z+2	; 0x02
    1914:	93 81       	ldd	r25, Z+3	; 0x03
    1916:	01 96       	adiw	r24, 0x01	; 1
    1918:	93 83       	std	Z+3, r25	; 0x03
    191a:	82 83       	std	Z+2, r24	; 0x02
    191c:	20 85       	ldd	r18, Z+8	; 0x08
    191e:	31 85       	ldd	r19, Z+9	; 0x09
    1920:	82 17       	cp	r24, r18
    1922:	93 07       	cpc	r25, r19
    1924:	21 f4       	brne	.+8      	; 0x192e <__vector_25+0x8a>
	  buffer->in = buffer->start;
    1926:	86 81       	ldd	r24, Z+6	; 0x06
    1928:	97 81       	ldd	r25, Z+7	; 0x07
    192a:	93 83       	std	Z+3, r25	; 0x03
    192c:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    192e:	0f b6       	in	r0, 0x3f	; 63
    1930:	f8 94       	cli
    1932:	0f 92       	push	r0
	{
	    buffer->count++;
    1934:	80 81       	ld	r24, Z
    1936:	91 81       	ldd	r25, Z+1	; 0x01
    1938:	01 96       	adiw	r24, 0x01	; 1
    193a:	91 83       	std	Z+1, r25	; 0x01
    193c:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    193e:	0f 90       	pop	r0
    1940:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerialPort.xRxedChars), cChar);
	}
}
    1942:	ff 91       	pop	r31
    1944:	ef 91       	pop	r30
    1946:	bf 91       	pop	r27
    1948:	af 91       	pop	r26
    194a:	9f 91       	pop	r25
    194c:	8f 91       	pop	r24
    194e:	4f 91       	pop	r20
    1950:	3f 91       	pop	r19
    1952:	2f 91       	pop	r18
    1954:	0f 90       	pop	r0
    1956:	0b be       	out	0x3b, r0	; 59
    1958:	0f 90       	pop	r0
    195a:	0f be       	out	0x3f, r0	; 63
    195c:	0f 90       	pop	r0
    195e:	1f 90       	pop	r1
    1960:	18 95       	reti

00001962 <__vector_26>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
    1962:	1f 92       	push	r1
    1964:	0f 92       	push	r0
    1966:	0f b6       	in	r0, 0x3f	; 63
    1968:	0f 92       	push	r0
    196a:	11 24       	eor	r1, r1
    196c:	0b b6       	in	r0, 0x3b	; 59
    196e:	0f 92       	push	r0
    1970:	2f 93       	push	r18
    1972:	8f 93       	push	r24
    1974:	9f 93       	push	r25
    1976:	af 93       	push	r26
    1978:	bf 93       	push	r27
    197a:	ef 93       	push	r30
    197c:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    197e:	0f b6       	in	r0, 0x3f	; 63
    1980:	f8 94       	cli
    1982:	0f 92       	push	r0
	{
	    count = buffer->count;
    1984:	80 91 8b 14 	lds	r24, 0x148B	; 0x80148b <xSerialPort+0xd>
    1988:	90 91 8c 14 	lds	r25, 0x148C	; 0x80148c <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
    198c:	0f 90       	pop	r0
    198e:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
    1990:	89 2b       	or	r24, r25
    1992:	31 f4       	brne	.+12     	; 0x19a0 <__vector_26+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
    1994:	e1 ec       	ldi	r30, 0xC1	; 193
    1996:	f0 e0       	ldi	r31, 0x00	; 0
    1998:	80 81       	ld	r24, Z
    199a:	8f 7d       	andi	r24, 0xDF	; 223
    199c:	80 83       	st	Z, r24
    199e:	1c c0       	rjmp	.+56     	; 0x19d8 <__vector_26+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    19a0:	eb e8       	ldi	r30, 0x8B	; 139
    19a2:	f4 e1       	ldi	r31, 0x14	; 20

	uint8_t data = *buffer->out;
    19a4:	a4 81       	ldd	r26, Z+4	; 0x04
    19a6:	b5 81       	ldd	r27, Z+5	; 0x05
    19a8:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    19aa:	b5 83       	std	Z+5, r27	; 0x05
    19ac:	a4 83       	std	Z+4, r26	; 0x04
    19ae:	80 85       	ldd	r24, Z+8	; 0x08
    19b0:	91 85       	ldd	r25, Z+9	; 0x09
    19b2:	a8 17       	cp	r26, r24
    19b4:	b9 07       	cpc	r27, r25
    19b6:	21 f4       	brne	.+8      	; 0x19c0 <__vector_26+0x5e>
	  buffer->out = buffer->start;
    19b8:	86 81       	ldd	r24, Z+6	; 0x06
    19ba:	97 81       	ldd	r25, Z+7	; 0x07
    19bc:	95 83       	std	Z+5, r25	; 0x05
    19be:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    19c0:	0f b6       	in	r0, 0x3f	; 63
    19c2:	f8 94       	cli
    19c4:	0f 92       	push	r0
	{
	    buffer->count--;
    19c6:	80 81       	ld	r24, Z
    19c8:	91 81       	ldd	r25, Z+1	; 0x01
    19ca:	01 97       	sbiw	r24, 0x01	; 1
    19cc:	91 83       	std	Z+1, r25	; 0x01
    19ce:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    19d0:	0f 90       	pop	r0
    19d2:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
    19d4:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	}
}
    19d8:	ff 91       	pop	r31
    19da:	ef 91       	pop	r30
    19dc:	bf 91       	pop	r27
    19de:	af 91       	pop	r26
    19e0:	9f 91       	pop	r25
    19e2:	8f 91       	pop	r24
    19e4:	2f 91       	pop	r18
    19e6:	0f 90       	pop	r0
    19e8:	0b be       	out	0x3b, r0	; 59
    19ea:	0f 90       	pop	r0
    19ec:	0f be       	out	0x3f, r0	; 63
    19ee:	0f 90       	pop	r0
    19f0:	1f 90       	pop	r1
    19f2:	18 95       	reti

000019f4 <__vector_36>:

#if defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART1_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART1_RX_vect )
{
    19f4:	1f 92       	push	r1
    19f6:	0f 92       	push	r0
    19f8:	0f b6       	in	r0, 0x3f	; 63
    19fa:	0f 92       	push	r0
    19fc:	11 24       	eor	r1, r1
    19fe:	0b b6       	in	r0, 0x3b	; 59
    1a00:	0f 92       	push	r0
    1a02:	2f 93       	push	r18
    1a04:	3f 93       	push	r19
    1a06:	4f 93       	push	r20
    1a08:	8f 93       	push	r24
    1a0a:	9f 93       	push	r25
    1a0c:	af 93       	push	r26
    1a0e:	bf 93       	push	r27
    1a10:	ef 93       	push	r30
    1a12:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR1A &  (_BV(FE1)|_BV(DOR1)|_BV(UPE1)) ) )
    1a14:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1a18:	8c 71       	andi	r24, 0x1C	; 28
    1a1a:	71 f0       	breq	.+28     	; 0x1a38 <__vector_36+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR1A & (1<<RXC1) ) erroredByte = UDR1;
    1a1c:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1a20:	88 23       	and	r24, r24
    1a22:	0c f0       	brlt	.+2      	; 0x1a26 <__vector_36+0x32>
    1a24:	36 c0       	rjmp	.+108    	; 0x1a92 <__vector_36+0x9e>
    1a26:	ae ec       	ldi	r26, 0xCE	; 206
    1a28:	b0 e0       	ldi	r27, 0x00	; 0
    1a2a:	e8 ec       	ldi	r30, 0xC8	; 200
    1a2c:	f0 e0       	ldi	r31, 0x00	; 0
    1a2e:	8c 91       	ld	r24, X
    1a30:	80 81       	ld	r24, Z
    1a32:	88 23       	and	r24, r24
    1a34:	e4 f3       	brlt	.-8      	; 0x1a2e <__vector_36+0x3a>
    1a36:	2d c0       	rjmp	.+90     	; 0x1a92 <__vector_36+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR1;
    1a38:	40 91 ce 00 	lds	r20, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1a3c:	0f b6       	in	r0, 0x3f	; 63
    1a3e:	f8 94       	cli
    1a40:	0f 92       	push	r0
	{
	    count = buffer->count;
    1a42:	e8 ee       	ldi	r30, 0xE8	; 232
    1a44:	f4 e1       	ldi	r31, 0x14	; 20
    1a46:	21 81       	ldd	r18, Z+1	; 0x01
    1a48:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    1a4a:	0f 90       	pop	r0
    1a4c:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial1Port.xRxedChars) ) )
    1a4e:	83 85       	ldd	r24, Z+11	; 0x0b
    1a50:	94 85       	ldd	r25, Z+12	; 0x0c
    1a52:	28 17       	cp	r18, r24
    1a54:	39 07       	cpc	r19, r25
    1a56:	e9 f0       	breq	.+58     	; 0x1a92 <__vector_36+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1a58:	e9 ee       	ldi	r30, 0xE9	; 233
    1a5a:	f4 e1       	ldi	r31, 0x14	; 20

	*buffer->in = data;
    1a5c:	a2 81       	ldd	r26, Z+2	; 0x02
    1a5e:	b3 81       	ldd	r27, Z+3	; 0x03
    1a60:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1a62:	82 81       	ldd	r24, Z+2	; 0x02
    1a64:	93 81       	ldd	r25, Z+3	; 0x03
    1a66:	01 96       	adiw	r24, 0x01	; 1
    1a68:	93 83       	std	Z+3, r25	; 0x03
    1a6a:	82 83       	std	Z+2, r24	; 0x02
    1a6c:	20 85       	ldd	r18, Z+8	; 0x08
    1a6e:	31 85       	ldd	r19, Z+9	; 0x09
    1a70:	82 17       	cp	r24, r18
    1a72:	93 07       	cpc	r25, r19
    1a74:	21 f4       	brne	.+8      	; 0x1a7e <__vector_36+0x8a>
	  buffer->in = buffer->start;
    1a76:	86 81       	ldd	r24, Z+6	; 0x06
    1a78:	97 81       	ldd	r25, Z+7	; 0x07
    1a7a:	93 83       	std	Z+3, r25	; 0x03
    1a7c:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1a7e:	0f b6       	in	r0, 0x3f	; 63
    1a80:	f8 94       	cli
    1a82:	0f 92       	push	r0
	{
	    buffer->count++;
    1a84:	80 81       	ld	r24, Z
    1a86:	91 81       	ldd	r25, Z+1	; 0x01
    1a88:	01 96       	adiw	r24, 0x01	; 1
    1a8a:	91 83       	std	Z+1, r25	; 0x01
    1a8c:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1a8e:	0f 90       	pop	r0
    1a90:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial1Port.xRxedChars), cChar);
	}
}
    1a92:	ff 91       	pop	r31
    1a94:	ef 91       	pop	r30
    1a96:	bf 91       	pop	r27
    1a98:	af 91       	pop	r26
    1a9a:	9f 91       	pop	r25
    1a9c:	8f 91       	pop	r24
    1a9e:	4f 91       	pop	r20
    1aa0:	3f 91       	pop	r19
    1aa2:	2f 91       	pop	r18
    1aa4:	0f 90       	pop	r0
    1aa6:	0b be       	out	0x3b, r0	; 59
    1aa8:	0f 90       	pop	r0
    1aaa:	0f be       	out	0x3f, r0	; 63
    1aac:	0f 90       	pop	r0
    1aae:	1f 90       	pop	r1
    1ab0:	18 95       	reti

00001ab2 <__vector_37>:
/*-----------------------------------------------------------*/

ISR( USART1_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART1_UDRE_vect )
{
    1ab2:	1f 92       	push	r1
    1ab4:	0f 92       	push	r0
    1ab6:	0f b6       	in	r0, 0x3f	; 63
    1ab8:	0f 92       	push	r0
    1aba:	11 24       	eor	r1, r1
    1abc:	0b b6       	in	r0, 0x3b	; 59
    1abe:	0f 92       	push	r0
    1ac0:	2f 93       	push	r18
    1ac2:	8f 93       	push	r24
    1ac4:	9f 93       	push	r25
    1ac6:	af 93       	push	r26
    1ac8:	bf 93       	push	r27
    1aca:	ef 93       	push	r30
    1acc:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1ace:	0f b6       	in	r0, 0x3f	; 63
    1ad0:	f8 94       	cli
    1ad2:	0f 92       	push	r0
	{
	    count = buffer->count;
    1ad4:	80 91 f5 14 	lds	r24, 0x14F5	; 0x8014f5 <xSerial1Port+0xd>
    1ad8:	90 91 f6 14 	lds	r25, 0x14F6	; 0x8014f6 <xSerial1Port+0xe>
	}
	portEXIT_CRITICAL();
    1adc:	0f 90       	pop	r0
    1ade:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) ) )
    1ae0:	89 2b       	or	r24, r25
    1ae2:	31 f4       	brne	.+12     	; 0x1af0 <__vector_37+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt1_Off();
    1ae4:	e9 ec       	ldi	r30, 0xC9	; 201
    1ae6:	f0 e0       	ldi	r31, 0x00	; 0
    1ae8:	80 81       	ld	r24, Z
    1aea:	8f 7d       	andi	r24, 0xDF	; 223
    1aec:	80 83       	st	Z, r24
    1aee:	1c c0       	rjmp	.+56     	; 0x1b28 <__vector_37+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1af0:	e5 ef       	ldi	r30, 0xF5	; 245
    1af2:	f4 e1       	ldi	r31, 0x14	; 20

	uint8_t data = *buffer->out;
    1af4:	a4 81       	ldd	r26, Z+4	; 0x04
    1af6:	b5 81       	ldd	r27, Z+5	; 0x05
    1af8:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1afa:	b5 83       	std	Z+5, r27	; 0x05
    1afc:	a4 83       	std	Z+4, r26	; 0x04
    1afe:	80 85       	ldd	r24, Z+8	; 0x08
    1b00:	91 85       	ldd	r25, Z+9	; 0x09
    1b02:	a8 17       	cp	r26, r24
    1b04:	b9 07       	cpc	r27, r25
    1b06:	21 f4       	brne	.+8      	; 0x1b10 <__vector_37+0x5e>
	  buffer->out = buffer->start;
    1b08:	86 81       	ldd	r24, Z+6	; 0x06
    1b0a:	97 81       	ldd	r25, Z+7	; 0x07
    1b0c:	95 83       	std	Z+5, r25	; 0x05
    1b0e:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1b10:	0f b6       	in	r0, 0x3f	; 63
    1b12:	f8 94       	cli
    1b14:	0f 92       	push	r0
	{
	    buffer->count--;
    1b16:	80 81       	ld	r24, Z
    1b18:	91 81       	ldd	r25, Z+1	; 0x01
    1b1a:	01 97       	sbiw	r24, 0x01	; 1
    1b1c:	91 83       	std	Z+1, r25	; 0x01
    1b1e:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1b20:	0f 90       	pop	r0
    1b22:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR1 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) );
    1b24:	20 93 ce 00 	sts	0x00CE, r18	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
	}
}
    1b28:	ff 91       	pop	r31
    1b2a:	ef 91       	pop	r30
    1b2c:	bf 91       	pop	r27
    1b2e:	af 91       	pop	r26
    1b30:	9f 91       	pop	r25
    1b32:	8f 91       	pop	r24
    1b34:	2f 91       	pop	r18
    1b36:	0f 90       	pop	r0
    1b38:	0b be       	out	0x3b, r0	; 59
    1b3a:	0f 90       	pop	r0
    1b3c:	0f be       	out	0x3f, r0	; 63
    1b3e:	0f 90       	pop	r0
    1b40:	1f 90       	pop	r1
    1b42:	18 95       	reti

00001b44 <__vector_51>:

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART2_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART2_RX_vect )
{
    1b44:	1f 92       	push	r1
    1b46:	0f 92       	push	r0
    1b48:	0f b6       	in	r0, 0x3f	; 63
    1b4a:	0f 92       	push	r0
    1b4c:	11 24       	eor	r1, r1
    1b4e:	0b b6       	in	r0, 0x3b	; 59
    1b50:	0f 92       	push	r0
    1b52:	2f 93       	push	r18
    1b54:	3f 93       	push	r19
    1b56:	4f 93       	push	r20
    1b58:	8f 93       	push	r24
    1b5a:	9f 93       	push	r25
    1b5c:	af 93       	push	r26
    1b5e:	bf 93       	push	r27
    1b60:	ef 93       	push	r30
    1b62:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR2A & (_BV(FE2)|_BV(DOR2)|_BV(UPE2)) ) )
    1b64:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1b68:	8c 71       	andi	r24, 0x1C	; 28
    1b6a:	71 f0       	breq	.+28     	; 0x1b88 <__vector_51+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR2A & (1<<RXC2) ) erroredByte = UDR2;
    1b6c:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1b70:	88 23       	and	r24, r24
    1b72:	0c f0       	brlt	.+2      	; 0x1b76 <__vector_51+0x32>
    1b74:	36 c0       	rjmp	.+108    	; 0x1be2 <__vector_51+0x9e>
    1b76:	a6 ed       	ldi	r26, 0xD6	; 214
    1b78:	b0 e0       	ldi	r27, 0x00	; 0
    1b7a:	e0 ed       	ldi	r30, 0xD0	; 208
    1b7c:	f0 e0       	ldi	r31, 0x00	; 0
    1b7e:	8c 91       	ld	r24, X
    1b80:	80 81       	ld	r24, Z
    1b82:	88 23       	and	r24, r24
    1b84:	e4 f3       	brlt	.-8      	; 0x1b7e <__vector_51+0x3a>
    1b86:	2d c0       	rjmp	.+90     	; 0x1be2 <__vector_51+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR2;
    1b88:	40 91 d6 00 	lds	r20, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1b8c:	0f b6       	in	r0, 0x3f	; 63
    1b8e:	f8 94       	cli
    1b90:	0f 92       	push	r0
	{
	    count = buffer->count;
    1b92:	e4 ea       	ldi	r30, 0xA4	; 164
    1b94:	f4 e1       	ldi	r31, 0x14	; 20
    1b96:	21 81       	ldd	r18, Z+1	; 0x01
    1b98:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    1b9a:	0f 90       	pop	r0
    1b9c:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial2Port.xRxedChars) ) )
    1b9e:	83 85       	ldd	r24, Z+11	; 0x0b
    1ba0:	94 85       	ldd	r25, Z+12	; 0x0c
    1ba2:	28 17       	cp	r18, r24
    1ba4:	39 07       	cpc	r19, r25
    1ba6:	e9 f0       	breq	.+58     	; 0x1be2 <__vector_51+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1ba8:	e5 ea       	ldi	r30, 0xA5	; 165
    1baa:	f4 e1       	ldi	r31, 0x14	; 20

	*buffer->in = data;
    1bac:	a2 81       	ldd	r26, Z+2	; 0x02
    1bae:	b3 81       	ldd	r27, Z+3	; 0x03
    1bb0:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1bb2:	82 81       	ldd	r24, Z+2	; 0x02
    1bb4:	93 81       	ldd	r25, Z+3	; 0x03
    1bb6:	01 96       	adiw	r24, 0x01	; 1
    1bb8:	93 83       	std	Z+3, r25	; 0x03
    1bba:	82 83       	std	Z+2, r24	; 0x02
    1bbc:	20 85       	ldd	r18, Z+8	; 0x08
    1bbe:	31 85       	ldd	r19, Z+9	; 0x09
    1bc0:	82 17       	cp	r24, r18
    1bc2:	93 07       	cpc	r25, r19
    1bc4:	21 f4       	brne	.+8      	; 0x1bce <__vector_51+0x8a>
	  buffer->in = buffer->start;
    1bc6:	86 81       	ldd	r24, Z+6	; 0x06
    1bc8:	97 81       	ldd	r25, Z+7	; 0x07
    1bca:	93 83       	std	Z+3, r25	; 0x03
    1bcc:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1bce:	0f b6       	in	r0, 0x3f	; 63
    1bd0:	f8 94       	cli
    1bd2:	0f 92       	push	r0
	{
	    buffer->count++;
    1bd4:	80 81       	ld	r24, Z
    1bd6:	91 81       	ldd	r25, Z+1	; 0x01
    1bd8:	01 96       	adiw	r24, 0x01	; 1
    1bda:	91 83       	std	Z+1, r25	; 0x01
    1bdc:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1bde:	0f 90       	pop	r0
    1be0:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial2Port.xRxedChars), cChar);
	}
}
    1be2:	ff 91       	pop	r31
    1be4:	ef 91       	pop	r30
    1be6:	bf 91       	pop	r27
    1be8:	af 91       	pop	r26
    1bea:	9f 91       	pop	r25
    1bec:	8f 91       	pop	r24
    1bee:	4f 91       	pop	r20
    1bf0:	3f 91       	pop	r19
    1bf2:	2f 91       	pop	r18
    1bf4:	0f 90       	pop	r0
    1bf6:	0b be       	out	0x3b, r0	; 59
    1bf8:	0f 90       	pop	r0
    1bfa:	0f be       	out	0x3f, r0	; 63
    1bfc:	0f 90       	pop	r0
    1bfe:	1f 90       	pop	r1
    1c00:	18 95       	reti

00001c02 <__vector_52>:
/*-----------------------------------------------------------*/

ISR( USART2_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART2_UDRE_vect )
{
    1c02:	1f 92       	push	r1
    1c04:	0f 92       	push	r0
    1c06:	0f b6       	in	r0, 0x3f	; 63
    1c08:	0f 92       	push	r0
    1c0a:	11 24       	eor	r1, r1
    1c0c:	0b b6       	in	r0, 0x3b	; 59
    1c0e:	0f 92       	push	r0
    1c10:	2f 93       	push	r18
    1c12:	8f 93       	push	r24
    1c14:	9f 93       	push	r25
    1c16:	af 93       	push	r26
    1c18:	bf 93       	push	r27
    1c1a:	ef 93       	push	r30
    1c1c:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1c1e:	0f b6       	in	r0, 0x3f	; 63
    1c20:	f8 94       	cli
    1c22:	0f 92       	push	r0
	{
	    count = buffer->count;
    1c24:	80 91 b1 14 	lds	r24, 0x14B1	; 0x8014b1 <xSerial2Port+0xd>
    1c28:	90 91 b2 14 	lds	r25, 0x14B2	; 0x8014b2 <xSerial2Port+0xe>
	}
	portEXIT_CRITICAL();
    1c2c:	0f 90       	pop	r0
    1c2e:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) ) )
    1c30:	89 2b       	or	r24, r25
    1c32:	31 f4       	brne	.+12     	; 0x1c40 <__vector_52+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt2_Off();
    1c34:	e1 ed       	ldi	r30, 0xD1	; 209
    1c36:	f0 e0       	ldi	r31, 0x00	; 0
    1c38:	80 81       	ld	r24, Z
    1c3a:	8f 7d       	andi	r24, 0xDF	; 223
    1c3c:	80 83       	st	Z, r24
    1c3e:	1c c0       	rjmp	.+56     	; 0x1c78 <__vector_52+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1c40:	e1 eb       	ldi	r30, 0xB1	; 177
    1c42:	f4 e1       	ldi	r31, 0x14	; 20

	uint8_t data = *buffer->out;
    1c44:	a4 81       	ldd	r26, Z+4	; 0x04
    1c46:	b5 81       	ldd	r27, Z+5	; 0x05
    1c48:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1c4a:	b5 83       	std	Z+5, r27	; 0x05
    1c4c:	a4 83       	std	Z+4, r26	; 0x04
    1c4e:	80 85       	ldd	r24, Z+8	; 0x08
    1c50:	91 85       	ldd	r25, Z+9	; 0x09
    1c52:	a8 17       	cp	r26, r24
    1c54:	b9 07       	cpc	r27, r25
    1c56:	21 f4       	brne	.+8      	; 0x1c60 <__vector_52+0x5e>
	  buffer->out = buffer->start;
    1c58:	86 81       	ldd	r24, Z+6	; 0x06
    1c5a:	97 81       	ldd	r25, Z+7	; 0x07
    1c5c:	95 83       	std	Z+5, r25	; 0x05
    1c5e:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1c60:	0f b6       	in	r0, 0x3f	; 63
    1c62:	f8 94       	cli
    1c64:	0f 92       	push	r0
	{
	    buffer->count--;
    1c66:	80 81       	ld	r24, Z
    1c68:	91 81       	ldd	r25, Z+1	; 0x01
    1c6a:	01 97       	sbiw	r24, 0x01	; 1
    1c6c:	91 83       	std	Z+1, r25	; 0x01
    1c6e:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1c70:	0f 90       	pop	r0
    1c72:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR2 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) );
    1c74:	20 93 d6 00 	sts	0x00D6, r18	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
	}
}
    1c78:	ff 91       	pop	r31
    1c7a:	ef 91       	pop	r30
    1c7c:	bf 91       	pop	r27
    1c7e:	af 91       	pop	r26
    1c80:	9f 91       	pop	r25
    1c82:	8f 91       	pop	r24
    1c84:	2f 91       	pop	r18
    1c86:	0f 90       	pop	r0
    1c88:	0b be       	out	0x3b, r0	; 59
    1c8a:	0f 90       	pop	r0
    1c8c:	0f be       	out	0x3f, r0	; 63
    1c8e:	0f 90       	pop	r0
    1c90:	1f 90       	pop	r1
    1c92:	18 95       	reti

00001c94 <__vector_54>:
/*-----------------------------------------------------------*/

ISR( USART3_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART3_RX_vect )
{
    1c94:	1f 92       	push	r1
    1c96:	0f 92       	push	r0
    1c98:	0f b6       	in	r0, 0x3f	; 63
    1c9a:	0f 92       	push	r0
    1c9c:	11 24       	eor	r1, r1
    1c9e:	0b b6       	in	r0, 0x3b	; 59
    1ca0:	0f 92       	push	r0
    1ca2:	2f 93       	push	r18
    1ca4:	3f 93       	push	r19
    1ca6:	4f 93       	push	r20
    1ca8:	8f 93       	push	r24
    1caa:	9f 93       	push	r25
    1cac:	af 93       	push	r26
    1cae:	bf 93       	push	r27
    1cb0:	ef 93       	push	r30
    1cb2:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR3A & (_BV(FE3)|_BV(DOR3)|_BV(UPE3)) ) )
    1cb4:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1cb8:	8c 71       	andi	r24, 0x1C	; 28
    1cba:	71 f0       	breq	.+28     	; 0x1cd8 <__vector_54+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR3A & (1<<RXC3) ) erroredByte = UDR3;
    1cbc:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1cc0:	88 23       	and	r24, r24
    1cc2:	0c f0       	brlt	.+2      	; 0x1cc6 <__vector_54+0x32>
    1cc4:	36 c0       	rjmp	.+108    	; 0x1d32 <__vector_54+0x9e>
    1cc6:	a6 e3       	ldi	r26, 0x36	; 54
    1cc8:	b1 e0       	ldi	r27, 0x01	; 1
    1cca:	e0 e3       	ldi	r30, 0x30	; 48
    1ccc:	f1 e0       	ldi	r31, 0x01	; 1
    1cce:	8c 91       	ld	r24, X
    1cd0:	80 81       	ld	r24, Z
    1cd2:	88 23       	and	r24, r24
    1cd4:	e4 f3       	brlt	.-8      	; 0x1cce <__vector_54+0x3a>
    1cd6:	2d c0       	rjmp	.+90     	; 0x1d32 <__vector_54+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR3;
    1cd8:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1cdc:	0f b6       	in	r0, 0x3f	; 63
    1cde:	f8 94       	cli
    1ce0:	0f 92       	push	r0
	{
	    count = buffer->count;
    1ce2:	e6 ec       	ldi	r30, 0xC6	; 198
    1ce4:	f4 e1       	ldi	r31, 0x14	; 20
    1ce6:	21 81       	ldd	r18, Z+1	; 0x01
    1ce8:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    1cea:	0f 90       	pop	r0
    1cec:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial3Port.xRxedChars) ) )
    1cee:	83 85       	ldd	r24, Z+11	; 0x0b
    1cf0:	94 85       	ldd	r25, Z+12	; 0x0c
    1cf2:	28 17       	cp	r18, r24
    1cf4:	39 07       	cpc	r19, r25
    1cf6:	e9 f0       	breq	.+58     	; 0x1d32 <__vector_54+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1cf8:	e7 ec       	ldi	r30, 0xC7	; 199
    1cfa:	f4 e1       	ldi	r31, 0x14	; 20

	*buffer->in = data;
    1cfc:	a2 81       	ldd	r26, Z+2	; 0x02
    1cfe:	b3 81       	ldd	r27, Z+3	; 0x03
    1d00:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1d02:	82 81       	ldd	r24, Z+2	; 0x02
    1d04:	93 81       	ldd	r25, Z+3	; 0x03
    1d06:	01 96       	adiw	r24, 0x01	; 1
    1d08:	93 83       	std	Z+3, r25	; 0x03
    1d0a:	82 83       	std	Z+2, r24	; 0x02
    1d0c:	20 85       	ldd	r18, Z+8	; 0x08
    1d0e:	31 85       	ldd	r19, Z+9	; 0x09
    1d10:	82 17       	cp	r24, r18
    1d12:	93 07       	cpc	r25, r19
    1d14:	21 f4       	brne	.+8      	; 0x1d1e <__vector_54+0x8a>
	  buffer->in = buffer->start;
    1d16:	86 81       	ldd	r24, Z+6	; 0x06
    1d18:	97 81       	ldd	r25, Z+7	; 0x07
    1d1a:	93 83       	std	Z+3, r25	; 0x03
    1d1c:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1d1e:	0f b6       	in	r0, 0x3f	; 63
    1d20:	f8 94       	cli
    1d22:	0f 92       	push	r0
	{
	    buffer->count++;
    1d24:	80 81       	ld	r24, Z
    1d26:	91 81       	ldd	r25, Z+1	; 0x01
    1d28:	01 96       	adiw	r24, 0x01	; 1
    1d2a:	91 83       	std	Z+1, r25	; 0x01
    1d2c:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1d2e:	0f 90       	pop	r0
    1d30:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial3Port.xRxedChars), cChar);
	}
}
    1d32:	ff 91       	pop	r31
    1d34:	ef 91       	pop	r30
    1d36:	bf 91       	pop	r27
    1d38:	af 91       	pop	r26
    1d3a:	9f 91       	pop	r25
    1d3c:	8f 91       	pop	r24
    1d3e:	4f 91       	pop	r20
    1d40:	3f 91       	pop	r19
    1d42:	2f 91       	pop	r18
    1d44:	0f 90       	pop	r0
    1d46:	0b be       	out	0x3b, r0	; 59
    1d48:	0f 90       	pop	r0
    1d4a:	0f be       	out	0x3f, r0	; 63
    1d4c:	0f 90       	pop	r0
    1d4e:	1f 90       	pop	r1
    1d50:	18 95       	reti

00001d52 <__vector_55>:
/*-----------------------------------------------------------*/

ISR( USART3_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART3_UDRE_vect )
{
    1d52:	1f 92       	push	r1
    1d54:	0f 92       	push	r0
    1d56:	0f b6       	in	r0, 0x3f	; 63
    1d58:	0f 92       	push	r0
    1d5a:	11 24       	eor	r1, r1
    1d5c:	0b b6       	in	r0, 0x3b	; 59
    1d5e:	0f 92       	push	r0
    1d60:	2f 93       	push	r18
    1d62:	8f 93       	push	r24
    1d64:	9f 93       	push	r25
    1d66:	af 93       	push	r26
    1d68:	bf 93       	push	r27
    1d6a:	ef 93       	push	r30
    1d6c:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1d6e:	0f b6       	in	r0, 0x3f	; 63
    1d70:	f8 94       	cli
    1d72:	0f 92       	push	r0
	{
	    count = buffer->count;
    1d74:	80 91 d3 14 	lds	r24, 0x14D3	; 0x8014d3 <xSerial3Port+0xd>
    1d78:	90 91 d4 14 	lds	r25, 0x14D4	; 0x8014d4 <xSerial3Port+0xe>
	}
	portEXIT_CRITICAL();
    1d7c:	0f 90       	pop	r0
    1d7e:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) ) )
    1d80:	89 2b       	or	r24, r25
    1d82:	31 f4       	brne	.+12     	; 0x1d90 <__vector_55+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt3_Off();
    1d84:	e1 e3       	ldi	r30, 0x31	; 49
    1d86:	f1 e0       	ldi	r31, 0x01	; 1
    1d88:	80 81       	ld	r24, Z
    1d8a:	8f 7d       	andi	r24, 0xDF	; 223
    1d8c:	80 83       	st	Z, r24
    1d8e:	1c c0       	rjmp	.+56     	; 0x1dc8 <__vector_55+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1d90:	e3 ed       	ldi	r30, 0xD3	; 211
    1d92:	f4 e1       	ldi	r31, 0x14	; 20

	uint8_t data = *buffer->out;
    1d94:	a4 81       	ldd	r26, Z+4	; 0x04
    1d96:	b5 81       	ldd	r27, Z+5	; 0x05
    1d98:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1d9a:	b5 83       	std	Z+5, r27	; 0x05
    1d9c:	a4 83       	std	Z+4, r26	; 0x04
    1d9e:	80 85       	ldd	r24, Z+8	; 0x08
    1da0:	91 85       	ldd	r25, Z+9	; 0x09
    1da2:	a8 17       	cp	r26, r24
    1da4:	b9 07       	cpc	r27, r25
    1da6:	21 f4       	brne	.+8      	; 0x1db0 <__vector_55+0x5e>
	  buffer->out = buffer->start;
    1da8:	86 81       	ldd	r24, Z+6	; 0x06
    1daa:	97 81       	ldd	r25, Z+7	; 0x07
    1dac:	95 83       	std	Z+5, r25	; 0x05
    1dae:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1db0:	0f b6       	in	r0, 0x3f	; 63
    1db2:	f8 94       	cli
    1db4:	0f 92       	push	r0
	{
	    buffer->count--;
    1db6:	80 81       	ld	r24, Z
    1db8:	91 81       	ldd	r25, Z+1	; 0x01
    1dba:	01 97       	sbiw	r24, 0x01	; 1
    1dbc:	91 83       	std	Z+1, r25	; 0x01
    1dbe:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1dc0:	0f 90       	pop	r0
    1dc2:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR3 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) );
    1dc4:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	}
}
    1dc8:	ff 91       	pop	r31
    1dca:	ef 91       	pop	r30
    1dcc:	bf 91       	pop	r27
    1dce:	af 91       	pop	r26
    1dd0:	9f 91       	pop	r25
    1dd2:	8f 91       	pop	r24
    1dd4:	2f 91       	pop	r18
    1dd6:	0f 90       	pop	r0
    1dd8:	0b be       	out	0x3b, r0	; 59
    1dda:	0f 90       	pop	r0
    1ddc:	0f be       	out	0x3f, r0	; 63
    1dde:	0f 90       	pop	r0
    1de0:	1f 90       	pop	r1
    1de2:	18 95       	reti

00001de4 <__udivmodsi4>:
    1de4:	a1 e2       	ldi	r26, 0x21	; 33
    1de6:	1a 2e       	mov	r1, r26
    1de8:	aa 1b       	sub	r26, r26
    1dea:	bb 1b       	sub	r27, r27
    1dec:	fd 01       	movw	r30, r26
    1dee:	0d c0       	rjmp	.+26     	; 0x1e0a <__udivmodsi4_ep>

00001df0 <__udivmodsi4_loop>:
    1df0:	aa 1f       	adc	r26, r26
    1df2:	bb 1f       	adc	r27, r27
    1df4:	ee 1f       	adc	r30, r30
    1df6:	ff 1f       	adc	r31, r31
    1df8:	a2 17       	cp	r26, r18
    1dfa:	b3 07       	cpc	r27, r19
    1dfc:	e4 07       	cpc	r30, r20
    1dfe:	f5 07       	cpc	r31, r21
    1e00:	20 f0       	brcs	.+8      	; 0x1e0a <__udivmodsi4_ep>
    1e02:	a2 1b       	sub	r26, r18
    1e04:	b3 0b       	sbc	r27, r19
    1e06:	e4 0b       	sbc	r30, r20
    1e08:	f5 0b       	sbc	r31, r21

00001e0a <__udivmodsi4_ep>:
    1e0a:	66 1f       	adc	r22, r22
    1e0c:	77 1f       	adc	r23, r23
    1e0e:	88 1f       	adc	r24, r24
    1e10:	99 1f       	adc	r25, r25
    1e12:	1a 94       	dec	r1
    1e14:	69 f7       	brne	.-38     	; 0x1df0 <__udivmodsi4_loop>
    1e16:	60 95       	com	r22
    1e18:	70 95       	com	r23
    1e1a:	80 95       	com	r24
    1e1c:	90 95       	com	r25
    1e1e:	9b 01       	movw	r18, r22
    1e20:	ac 01       	movw	r20, r24
    1e22:	bd 01       	movw	r22, r26
    1e24:	cf 01       	movw	r24, r30
    1e26:	08 95       	ret

00001e28 <__tablejump2__>:
    1e28:	ee 0f       	add	r30, r30
    1e2a:	ff 1f       	adc	r31, r31
    1e2c:	88 1f       	adc	r24, r24
    1e2e:	8b bf       	out	0x3b, r24	; 59
    1e30:	07 90       	elpm	r0, Z+
    1e32:	f6 91       	elpm	r31, Z
    1e34:	e0 2d       	mov	r30, r0
    1e36:	19 94       	eijmp

00001e38 <memset>:
    1e38:	dc 01       	movw	r26, r24
    1e3a:	01 c0       	rjmp	.+2      	; 0x1e3e <memset+0x6>
    1e3c:	6d 93       	st	X+, r22
    1e3e:	41 50       	subi	r20, 0x01	; 1
    1e40:	50 40       	sbci	r21, 0x00	; 0
    1e42:	e0 f7       	brcc	.-8      	; 0x1e3c <memset+0x4>
    1e44:	08 95       	ret

00001e46 <_exit>:
    1e46:	f8 94       	cli

00001e48 <__stop_program>:
    1e48:	ff cf       	rjmp	.-2      	; 0x1e48 <__stop_program>
